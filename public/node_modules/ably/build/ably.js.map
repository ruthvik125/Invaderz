{
  "version": 3,
  "sources": ["../src/platform/web/index.ts", "../src/common/platform.ts", "../src/common/lib/util/logger.ts", "../src/common/lib/util/utils.ts", "../src/common/lib/types/errorinfo.ts", "../package.json", "../src/common/lib/util/defaults.ts", "../src/common/lib/util/multicaster.ts", "../src/common/constants/HttpMethods.ts", "../src/common/constants/HttpStatusCodes.ts", "../src/common/lib/client/auth.ts", "../src/common/types/http.ts", "../src/common/lib/client/baseclient.ts", "../src/common/lib/types/devicedetails.ts", "../src/common/lib/client/resource.ts", "../src/common/lib/client/paginatedresource.ts", "../src/common/lib/types/pushchannelsubscription.ts", "../src/common/lib/client/push.ts", "../src/common/lib/types/message.ts", "../src/common/lib/types/presencemessage.ts", "../src/common/lib/client/restpresence.ts", "../src/common/lib/client/restchannel.ts", "../src/common/lib/types/stats.ts", "../src/common/lib/client/restchannelmixin.ts", "../src/common/lib/client/restpresencemixin.ts", "../src/common/lib/client/rest.ts", "../src/common/lib/client/baserest.ts", "../src/common/lib/client/modularplugins.ts", "../src/common/lib/types/defaultmessage.ts", "../src/common/lib/types/defaultpresencemessage.ts", "../src/common/lib/client/defaultrest.ts", "../src/common/lib/util/eventemitter.ts", "../src/common/lib/types/protocolmessage.ts", "../src/common/lib/transport/messagequeue.ts", "../src/common/lib/transport/protocol.ts", "../src/common/lib/client/connectionstatechange.ts", "../src/common/lib/transport/connectionerrors.ts", "../src/common/lib/transport/transport.ts", "../src/common/constants/TransportName.ts", "../src/common/lib/transport/connectionmanager.ts", "../src/common/lib/client/connection.ts", "../src/common/lib/client/channelstatechange.ts", "../src/common/lib/client/realtimechannel.ts", "../src/common/lib/client/baserealtime.ts", "../src/common/lib/client/realtimepresence.ts", "../src/common/lib/transport/websockettransport.ts", "../src/common/lib/client/filteredsubscriptions.ts", "../src/common/lib/client/defaultrealtime.ts", "../src/platform/web/lib/util/hmac-sha256.ts", "../src/platform/web/lib/util/bufferutils.ts", "../src/platform/web/lib/util/crypto.ts", "../src/common/constants/XHRStates.ts", "../src/platform/web/lib/http/http.ts", "../src/platform/web/config.ts", "../src/common/lib/transport/comettransport.ts", "../src/platform/web/lib/http/request/xhrrequest.ts", "../src/platform/web/lib/transport/xhrpollingtransport.ts", "../src/platform/web/lib/transport/index.ts", "../src/platform/web/lib/util/webstorage.ts", "../src/platform/web/lib/util/defaults.ts", "../src/platform/web/lib/util/msgpack.ts", "../src/platform/web/lib/http/request/fetchrequest.ts", "../src/platform/web/lib/http/request/index.ts"],
  "sourcesContent": ["// Common\r\nimport { DefaultRest } from '../../common/lib/client/defaultrest';\r\nimport { DefaultRealtime } from '../../common/lib/client/defaultrealtime';\r\nimport Platform from '../../common/platform';\r\nimport ErrorInfo from '../../common/lib/types/errorinfo';\r\nimport { fromDeserializedIncludingDependencies as protocolMessageFromDeserialized } from '../../common/lib/types/protocolmessage';\r\n\r\n// Platform Specific\r\nimport BufferUtils from './lib/util/bufferutils';\r\n// @ts-ignore\r\nimport { createCryptoClass } from './lib/util/crypto';\r\nimport Http from './lib/http/http';\r\nimport Config from './config';\r\n// @ts-ignore\r\nimport Transports from './lib/transport';\r\nimport Logger from '../../common/lib/util/logger';\r\nimport { getDefaults } from '../../common/lib/util/defaults';\r\nimport WebStorage from './lib/util/webstorage';\r\nimport PlatformDefaults from './lib/util/defaults';\r\nimport msgpack from './lib/util/msgpack';\r\nimport { defaultBundledRequestImplementations } from './lib/http/request';\r\n\r\nconst Crypto = createCryptoClass(Config, BufferUtils);\r\n\r\nPlatform.Crypto = Crypto;\r\nPlatform.BufferUtils = BufferUtils;\r\nPlatform.Http = Http;\r\nPlatform.Config = Config;\r\nPlatform.Transports = Transports;\r\nPlatform.WebStorage = WebStorage;\r\n\r\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\r\n  clientClass.Crypto = Crypto;\r\n  clientClass._MsgPack = msgpack;\r\n}\r\n\r\nHttp.bundledRequestImplementations = defaultBundledRequestImplementations;\r\n\r\nLogger.initLogHandlers();\r\n\r\nPlatform.Defaults = getDefaults(PlatformDefaults);\r\n\r\nif (Platform.Config.agent) {\r\n  // @ts-ignore\r\n  Platform.Defaults.agent += ' ' + Platform.Config.agent;\r\n}\r\n\r\nexport { DefaultRest as Rest, DefaultRealtime as Realtime, msgpack, protocolMessageFromDeserialized, ErrorInfo };\r\n\r\nexport default {\r\n  ErrorInfo,\r\n  Rest: DefaultRest,\r\n  Realtime: DefaultRealtime,\r\n  msgpack,\r\n};\r\n", "import { IPlatformConfig } from './types/IPlatformConfig';\r\nimport { IPlatformHttpStatic } from './types/http';\r\nimport IDefaults from './types/IDefaults';\r\nimport IWebStorage from './types/IWebStorage';\r\nimport IBufferUtils from './types/IBufferUtils';\r\nimport * as WebBufferUtils from '../platform/web/lib/util/bufferutils';\r\nimport * as NodeBufferUtils from '../platform/nodejs/lib/util/bufferutils';\r\nimport { IUntypedCryptoStatic } from '../common/types/ICryptoStatic';\r\nimport TransportName from './constants/TransportName';\r\nimport { TransportCtor } from './lib/transport/transport';\r\n\r\nexport type Bufferlike = WebBufferUtils.Bufferlike | NodeBufferUtils.Bufferlike;\r\ntype BufferUtilsOutput = WebBufferUtils.Output | NodeBufferUtils.Output;\r\ntype ToBufferOutput = WebBufferUtils.ToBufferOutput | NodeBufferUtils.ToBufferOutput;\r\n\r\nexport type TransportImplementations = Partial<Record<TransportName, TransportCtor>>;\r\n\r\nexport default class Platform {\r\n  static Config: IPlatformConfig;\r\n  /*\r\n     What we actually _want_ is for Platform to be a generic class\r\n     parameterised by Bufferlike etc, but that requires far-reaching changes to\r\n     components that make use of Platform. So instead we have to advertise a\r\n     BufferUtils object that accepts a broader range of data types than it\r\n     can in reality handle.\r\n   */\r\n  static BufferUtils: IBufferUtils<Bufferlike, BufferUtilsOutput, ToBufferOutput>;\r\n  /*\r\n     We\u2019d like this to be ICryptoStatic with the correct generic arguments,\r\n     but Platform doesn\u2019t currently allow that, as described in the BufferUtils\r\n     comment above.\r\n   */\r\n  static Crypto: IUntypedCryptoStatic | null;\r\n  static Http: IPlatformHttpStatic;\r\n  static Transports: {\r\n    order: TransportName[];\r\n    // Transport implementations that always come with this platform\r\n    bundledImplementations: TransportImplementations;\r\n  };\r\n  static Defaults: IDefaults;\r\n  static WebStorage: IWebStorage | null;\r\n}\r\n", "import Platform from 'common/platform';\r\n\r\nexport type LoggerOptions = {\r\n  handler: LoggerFunction;\r\n  level: LogLevels;\r\n};\r\ntype LoggerFunction = (...args: string[]) => void;\r\n\r\n// Workaround for salesforce lightning locker compatibility\r\n// This is a shorthand version of Utils.getGlobalObject (which we can't use here without creating a circular import)\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nenum LogLevels {\r\n  None = 0,\r\n  Error = 1,\r\n  Major = 2,\r\n  Minor = 3,\r\n  Micro = 4,\r\n}\r\n\r\nfunction pad(timeSegment: number, three?: number) {\r\n  return `${timeSegment}`.padStart(three ? 3 : 2, '0');\r\n}\r\n\r\nfunction getHandler(logger: Function): Function {\r\n  return Platform.Config.logTimestamps\r\n    ? function (msg: unknown) {\r\n        const time = new Date();\r\n        logger(\r\n          pad(time.getHours()) +\r\n            ':' +\r\n            pad(time.getMinutes()) +\r\n            ':' +\r\n            pad(time.getSeconds()) +\r\n            '.' +\r\n            pad(time.getMilliseconds(), 1) +\r\n            ' ' +\r\n            msg,\r\n        );\r\n      }\r\n    : function (msg: string) {\r\n        logger(msg);\r\n      };\r\n}\r\n\r\nconst getDefaultLoggers = (): [Function, Function] => {\r\n  let consoleLogger;\r\n  let errorLogger;\r\n\r\n  // we expect ably-js to be run in environments which have `console` object available with its `log` function\r\n  if (typeof globalObject?.console?.log === 'function') {\r\n    consoleLogger = function (...args: unknown[]) {\r\n      console.log.apply(console, args);\r\n    };\r\n\r\n    errorLogger = console.warn\r\n      ? function (...args: unknown[]) {\r\n          console.warn.apply(console, args);\r\n        }\r\n      : consoleLogger;\r\n  } else {\r\n    // otherwise we should fallback to noop for log functions\r\n    consoleLogger = errorLogger = function () {};\r\n  }\r\n\r\n  return [consoleLogger, errorLogger].map(getHandler) as [Function, Function];\r\n};\r\n\r\nclass Logger {\r\n  private static defaultLogLevel: LogLevels = LogLevels.Error;\r\n  private static defaultLogHandler: Function;\r\n  private static defaultLogErrorHandler: Function;\r\n\r\n  private logLevel: LogLevels;\r\n  private logHandler: Function;\r\n  private logErrorHandler: Function;\r\n\r\n  // public constants\r\n  static readonly LOG_NONE: LogLevels = LogLevels.None;\r\n  static readonly LOG_ERROR: LogLevels = LogLevels.Error;\r\n  static readonly LOG_MAJOR: LogLevels = LogLevels.Major;\r\n  static readonly LOG_MINOR: LogLevels = LogLevels.Minor;\r\n  static readonly LOG_MICRO: LogLevels = LogLevels.Micro;\r\n\r\n  /**\r\n   * This logger instance should only be used when there is no more appropriate logger to use, for example when implementing a public static method or function whose API doesn\u2019t accept any logging configuration.\r\n   */\r\n  static defaultLogger: Logger;\r\n\r\n  static initLogHandlers() {\r\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\r\n    this.defaultLogHandler = logHandler;\r\n    this.defaultLogErrorHandler = logErrorHandler;\r\n    this.defaultLogger = new Logger();\r\n  }\r\n\r\n  constructor() {\r\n    this.logLevel = Logger.defaultLogLevel;\r\n    this.logHandler = Logger.defaultLogHandler;\r\n    this.logErrorHandler = Logger.defaultLogErrorHandler;\r\n  }\r\n\r\n  /* public static functions */\r\n  /**\r\n   * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\r\n   *\r\n   * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you can\u2019t dynamically specify the log level.\r\n   */\r\n  static logAction = (logger: Logger, level: LogLevels, action: string, message?: string) => {\r\n    this.logActionNoStrip(logger, level, action, message);\r\n  };\r\n\r\n  /**\r\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\r\n   */\r\n  static logActionNoStrip(logger: Logger, level: LogLevels, action: string, message?: string) {\r\n    logger.logAction(level, action, message);\r\n  }\r\n\r\n  private logAction(level: LogLevels, action: string, message?: string) {\r\n    if (this.shouldLog(level)) {\r\n      (level === LogLevels.Error ? this.logErrorHandler : this.logHandler)('Ably: ' + action + ': ' + message, level);\r\n    }\r\n  }\r\n\r\n  deprecated = (description: string, msg: string) => {\r\n    this.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\r\n  };\r\n\r\n  renamedClientOption(oldName: string, newName: string) {\r\n    this.deprecationWarning(\r\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`,\r\n    );\r\n  }\r\n\r\n  renamedMethod(className: string, oldName: string, newName: string) {\r\n    this.deprecationWarning(\r\n      `\\`${className}\\`\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`,\r\n    );\r\n  }\r\n\r\n  deprecationWarning(message: string) {\r\n    if (this.shouldLog(LogLevels.Error)) {\r\n      this.logErrorHandler(`Ably: Deprecation warning - ${message}`, LogLevels.Error);\r\n    }\r\n  }\r\n\r\n  /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\r\n\t   the object being serialised if the log level will not output the message */\r\n  shouldLog = (level: LogLevels) => {\r\n    return level <= this.logLevel;\r\n  };\r\n\r\n  setLog = (level: LogLevels | undefined, handler: Function | undefined) => {\r\n    if (level !== undefined) this.logLevel = level;\r\n    if (handler !== undefined) this.logHandler = this.logErrorHandler = handler;\r\n  };\r\n}\r\n\r\nexport default Logger;\r\n", "import Platform from 'common/platform';\r\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport { ModularPlugins } from '../client/modularplugins';\r\nimport { MsgPack } from 'common/types/msgpack';\r\n\r\nfunction randomPosn(arrOrStr: Array<unknown> | string) {\r\n  return Math.floor(Math.random() * arrOrStr.length);\r\n}\r\n\r\n/**\r\n * Add a set of properties to a target object\r\n *\r\n * @param target the target object\r\n * @param args objects, which enumerable properties are added to target, by reference only\r\n * @returns target object with added properties\r\n */\r\nexport function mixin(\r\n  target: Record<string, unknown>,\r\n  ...args: Array<object | undefined | null>\r\n): Record<string, unknown> {\r\n  for (let i = 0; i < args.length; i++) {\r\n    const source = args[i];\r\n    if (!source) {\r\n      break;\r\n    }\r\n\r\n    for (const key in source) {\r\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n        target[key] = (source as Record<string, unknown>)[key];\r\n      }\r\n    }\r\n  }\r\n  return target;\r\n}\r\n\r\n/**\r\n * Creates a copy of enumerable properties of the source object\r\n *\r\n * @param src object to copy\r\n * @returns copy of src\r\n */\r\nexport function copy<T = Record<string, unknown>>(src: T | Record<string, unknown> | null | undefined): T {\r\n  return mixin({}, src as Record<string, unknown>) as T;\r\n}\r\n\r\n/*\r\n * Ensures that an Array object is always returned\r\n * returning the original Array of obj is an Array\r\n * else wrapping the obj in a single element Array\r\n */\r\nexport function ensureArray(obj: Record<string, unknown>): unknown[] {\r\n  if (isNil(obj)) {\r\n    return [];\r\n  }\r\n  if (Array.isArray(obj)) {\r\n    return obj;\r\n  }\r\n  return [obj];\r\n}\r\n\r\nexport function isObject(ob: unknown): ob is Record<string, unknown> {\r\n  return Object.prototype.toString.call(ob) == '[object Object]';\r\n}\r\n\r\n/*\r\n * Determine whether or not an object contains\r\n * any enumerable properties.\r\n * ob: the object\r\n */\r\nexport function isEmpty(ob: Record<string, unknown> | unknown[]): boolean {\r\n  for (const prop in ob) return false;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Checks if `value` is `null` or `undefined`.\r\n *\r\n * Source: https://github.com/lodash/lodash/blob/main/src/isNil.ts\r\n */\r\nexport function isNil(arg: unknown): arg is null | undefined {\r\n  return arg == null;\r\n}\r\n\r\n/*\r\n * Perform a simple shallow clone of an object.\r\n * Result is an object irrespective of whether\r\n * the input is an object or array. All\r\n * enumerable properties are copied.\r\n * ob: the object\r\n */\r\nexport function shallowClone(ob: Record<string, unknown>): Record<string, unknown> {\r\n  const result = new Object() as Record<string, unknown>;\r\n  for (const prop in ob) result[prop] = ob[prop];\r\n  return result;\r\n}\r\n\r\n/*\r\n * Clone an object by creating a new object with the\r\n * given object as its prototype. Optionally\r\n * a set of additional own properties can be\r\n * supplied to be added to the newly created clone.\r\n * ob:            the object to be cloned\r\n * ownProperties: optional object with additional\r\n *                properties to add\r\n */\r\nexport function prototypicalClone(\r\n  ob: Record<string, unknown>,\r\n  ownProperties: Record<string, unknown>,\r\n): Record<string, unknown> {\r\n  class F {}\r\n  F.prototype = ob;\r\n  const result = new F() as Record<string, unknown>;\r\n  if (ownProperties) mixin(result, ownProperties);\r\n  return result;\r\n}\r\n\r\n/*\r\n * Declare a constructor to represent a subclass\r\n * of another constructor\r\n * If platform has a built-in version we use that from Platform, else we\r\n * define here (so can make use of other Utils fns)\r\n * See node.js util.inherits\r\n */\r\nexport const inherits = function (ctor: any, superCtor: Function) {\r\n  if (Platform.Config.inherits) {\r\n    Platform.Config.inherits(ctor, superCtor);\r\n    return;\r\n  }\r\n  ctor.super_ = superCtor;\r\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\r\n};\r\n\r\n/*\r\n * Determine whether or not an object has an enumerable\r\n * property whose value equals a given value.\r\n * ob:  the object\r\n * val: the value to find\r\n */\r\nexport function containsValue(ob: Record<string, unknown>, val: unknown): boolean {\r\n  for (const i in ob) {\r\n    if (ob[i] == val) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function intersect<K extends string, T>(arr: Array<K>, ob: K[] | Partial<Record<K, T>>): K[] {\r\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\r\n}\r\n\r\nexport function arrIntersect<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\r\n  const result = [];\r\n  for (let i = 0; i < arr1.length; i++) {\r\n    const member = arr1[i];\r\n    if (arr2.indexOf(member) != -1) result.push(member);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function arrIntersectOb<K extends string>(arr: Array<K>, ob: Partial<Record<K, unknown>>): K[] {\r\n  const result = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const member = arr[i];\r\n    if (member in ob) result.push(member);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function arrSubtract<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\r\n  const result = [];\r\n  for (let i = 0; i < arr1.length; i++) {\r\n    const element = arr1[i];\r\n    if (arr2.indexOf(element) == -1) result.push(element);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function arrDeleteValue<T>(arr: Array<T>, val: T): boolean {\r\n  const idx = arr.indexOf(val);\r\n  const res = idx != -1;\r\n  if (res) arr.splice(idx, 1);\r\n  return res;\r\n}\r\n\r\nexport function arrWithoutValue<T>(arr: Array<T>, val: T): Array<T> {\r\n  const newArr = arr.slice();\r\n  arrDeleteValue(newArr, val);\r\n  return newArr;\r\n}\r\n\r\n/*\r\n * Construct an array of the keys of the enumerable\r\n * properties of a given object, optionally limited\r\n * to only the own properties.\r\n * ob:      the object\r\n * ownOnly: boolean, get own properties only\r\n */\r\nexport function keysArray(ob: Record<string, unknown>, ownOnly?: boolean): Array<string> {\r\n  const result = [];\r\n  for (const prop in ob) {\r\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\r\n    result.push(prop);\r\n  }\r\n  return result;\r\n}\r\n\r\n/*\r\n * Construct an array of the values of the enumerable\r\n * properties of a given object, optionally limited\r\n * to only the own properties.\r\n * ob:      the object\r\n * ownOnly: boolean, get own properties only\r\n */\r\nexport function valuesArray<T>(ob: Record<string, T>, ownOnly?: boolean): T[] {\r\n  const result = [];\r\n  for (const prop in ob) {\r\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\r\n    result.push(ob[prop]);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function forInOwnNonNullProperties(ob: Record<string, unknown>, fn: (prop: string) => void): void {\r\n  for (const prop in ob) {\r\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\r\n      fn(prop);\r\n    }\r\n  }\r\n}\r\n\r\nexport function allSame(arr: Array<Record<string, unknown>>, prop: string): boolean {\r\n  if (arr.length === 0) {\r\n    return true;\r\n  }\r\n  const first = arr[0][prop];\r\n  return arr.every(function (item) {\r\n    return item[prop] === first;\r\n  });\r\n}\r\n\r\nexport enum Format {\r\n  msgpack = 'msgpack',\r\n  json = 'json',\r\n}\r\n\r\nexport function arrPopRandomElement<T>(arr: Array<T>): T {\r\n  return arr.splice(randomPosn(arr), 1)[0];\r\n}\r\n\r\nexport function toQueryString(params?: Record<string, string> | null): string {\r\n  const parts = [];\r\n  if (params) {\r\n    for (const key in params) parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));\r\n  }\r\n  return parts.length ? '?' + parts.join('&') : '';\r\n}\r\n\r\nexport function parseQueryString(query: string): Record<string, string> {\r\n  let match;\r\n  const search = /([^?&=]+)=?([^&]*)/g;\r\n  const result: Record<string, string> = {};\r\n\r\n  while ((match = search.exec(query))) result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\r\n\r\n  return result;\r\n}\r\n\r\nexport function isErrorInfoOrPartialErrorInfo(err: unknown): err is ErrorInfo | PartialErrorInfo {\r\n  return typeof err == 'object' && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\r\n}\r\n\r\nexport function inspectError(err: unknown): string {\r\n  if (\r\n    err instanceof Error ||\r\n    (err as ErrorInfo)?.constructor?.name === 'ErrorInfo' ||\r\n    (err as PartialErrorInfo)?.constructor?.name === 'PartialErrorInfo'\r\n  )\r\n    return (err as Error).toString();\r\n  return Platform.Config.inspect(err);\r\n}\r\n\r\nexport function inspectBody(body: unknown): string {\r\n  if (Platform.BufferUtils.isBuffer(body)) {\r\n    return (body as any).toString();\r\n  } else if (typeof body === 'string') {\r\n    return body;\r\n  } else {\r\n    return Platform.Config.inspect(body);\r\n  }\r\n}\r\n\r\n/* Data is assumed to be either a string or a buffer. */\r\nexport function dataSizeBytes(data: string | Buffer): number {\r\n  if (Platform.BufferUtils.isBuffer(data)) {\r\n    return Platform.BufferUtils.byteLength(data);\r\n  }\r\n  if (typeof data === 'string') {\r\n    return Platform.Config.stringByteSize(data);\r\n  }\r\n  throw new Error('Expected input of Utils.dataSizeBytes to be a buffer or string, but was: ' + typeof data);\r\n}\r\n\r\nexport function cheapRandStr(): string {\r\n  return String(Math.random()).substr(2);\r\n}\r\n\r\n/* Takes param the minimum number of bytes of entropy the string must\r\n * include, not the length of the string. String length produced is not\r\n * guaranteed. */\r\nexport const randomString = async (numBytes: number): Promise<string> => {\r\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\r\n  return Platform.BufferUtils.base64Encode(buffer);\r\n};\r\n\r\n/* Pick n elements at random without replacement from an array */\r\nexport function arrChooseN<T>(arr: Array<T>, n: number): Array<T> {\r\n  const numItems = Math.min(n, arr.length),\r\n    mutableArr = arr.slice(),\r\n    result: Array<T> = [];\r\n  for (let i = 0; i < numItems; i++) {\r\n    result.push(arrPopRandomElement(mutableArr));\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Uses a callback to communicate the result of a `Promise`. The first argument passed to the callback will be either an error (when the promise is rejected) or `null` (when the promise is fulfilled). In the case where the promise is fulfilled, the resulting value will be passed to the callback as a second argument.\r\n */\r\nexport function whenPromiseSettles<T, E = unknown>(\r\n  promise: Promise<T>,\r\n  callback?: (err: E | null, result?: T) => void,\r\n) {\r\n  promise\r\n    .then((result) => {\r\n      callback?.(null, result);\r\n    })\r\n    .catch((err: unknown) => {\r\n      // We make no guarantees about the type of the error that gets passed to the callback. Issue https://github.com/ably/ably-js/issues/1617 will think about how to correctly handle error types.\r\n      callback?.(err as E);\r\n    });\r\n}\r\n\r\nexport function decodeBody<T>(body: unknown, MsgPack: MsgPack | null, format?: Format | null): T {\r\n  if (format == 'msgpack') {\r\n    if (!MsgPack) {\r\n      throwMissingPluginError('MsgPack');\r\n    }\r\n    return MsgPack.decode(body as Buffer);\r\n  }\r\n\r\n  return JSON.parse(String(body));\r\n}\r\n\r\nexport function encodeBody(body: unknown, MsgPack: MsgPack | null, format?: Format): string | Buffer {\r\n  if (format == 'msgpack') {\r\n    if (!MsgPack) {\r\n      throwMissingPluginError('MsgPack');\r\n    }\r\n    return MsgPack.encode(body, true) as Buffer;\r\n  }\r\n\r\n  return JSON.stringify(body);\r\n}\r\n\r\nexport function allToLowerCase(arr: Array<string>): Array<string> {\r\n  return arr.map(function (element) {\r\n    return element && element.toLowerCase();\r\n  });\r\n}\r\n\r\nexport function allToUpperCase(arr: Array<string>): Array<string> {\r\n  return arr.map(function (element) {\r\n    return element && element.toUpperCase();\r\n  });\r\n}\r\n\r\nexport function getBackoffCoefficient(count: number) {\r\n  return Math.min((count + 2) / 3, 2);\r\n}\r\n\r\nexport function getJitterCoefficient() {\r\n  return 1 - Math.random() * 0.2;\r\n}\r\n\r\n/**\r\n *\r\n * @param initialTimeout initial timeout value\r\n * @param retryAttempt integer indicating retryAttempt\r\n * @returns RetryTimeout value for given timeout and retryAttempt.\r\n * If x is the value generated then,\r\n * Upper bound = min((retryAttempt + 2) / 3, 2) * initialTimeout,\r\n * Lower bound = 0.8 * Upper bound,\r\n * Lower bound < x < Upper bound\r\n */\r\nexport function getRetryTime(initialTimeout: number, retryAttempt: number) {\r\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\r\n}\r\n\r\nexport function getGlobalObject() {\r\n  if (typeof global !== 'undefined') {\r\n    return global;\r\n  }\r\n\r\n  if (typeof window !== 'undefined') {\r\n    return window;\r\n  }\r\n\r\n  return self;\r\n}\r\n\r\nexport function shallowEquals(source: Record<string, unknown>, target: Record<string, unknown>) {\r\n  return (\r\n    Object.keys(source).every((key) => source[key] === target[key]) &&\r\n    Object.keys(target).every((key) => target[key] === source[key])\r\n  );\r\n}\r\n\r\nexport function matchDerivedChannel(name: string) {\r\n  /**\r\n   * This regex check is to retain existing channel params if any e.g [?rewind=1]foo to\r\n   * [filter=xyz?rewind=1]foo. This is to keep channel compatibility around use of\r\n   * channel params that work with derived channels.\r\n   *\r\n   * This eslint unsafe regex warning is triggered because the RegExp uses nested quantifiers,\r\n   * but it does not create any situation where the regex engine has to\r\n   * explore a large number of possible matches so it\u2019s safe to ignore\r\n   */\r\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/; // eslint-disable-line\r\n  const match = name.match(regex);\r\n  if (!match || !match.length || match.length < 5) {\r\n    throw new ErrorInfo('regex match failed', 400, 40010);\r\n  }\r\n  // Fail if there is already a channel qualifier, eg [meta]foo should fail instead of just overriding with [filter=xyz]foo\r\n  if (match![2]) {\r\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\r\n  }\r\n  // Return match values to be added to derive channel quantifier.\r\n  return {\r\n    qualifierParam: match[3] || '',\r\n    channelName: match[4],\r\n  };\r\n}\r\n\r\nexport function toBase64(str: string) {\r\n  const bufferUtils = Platform.BufferUtils;\r\n  const textBuffer = bufferUtils.utf8Encode(str);\r\n  return bufferUtils.base64Encode(textBuffer);\r\n}\r\n\r\nexport function arrEquals(a: any[], b: any[]) {\r\n  return (\r\n    a.length === b.length &&\r\n    a.every(function (val, i) {\r\n      return val === b[i];\r\n    })\r\n  );\r\n}\r\n\r\nexport function createMissingPluginError(pluginName: keyof ModularPlugins): ErrorInfo {\r\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\r\n}\r\n\r\nexport function throwMissingPluginError(pluginName: keyof ModularPlugins): never {\r\n  throw createMissingPluginError(pluginName);\r\n}\r\n\r\nexport async function withTimeoutAsync<A>(promise: Promise<A>, timeout = 5000, err = 'Timeout expired'): Promise<A> {\r\n  const e = new ErrorInfo(err, 50000, 500);\r\n  return Promise.race([promise, new Promise<A>((_resolve, reject) => setTimeout(() => reject(e), timeout))]);\r\n}\r\n", "import Platform from 'common/platform';\r\nimport * as Utils from '../util/utils';\r\nimport * as API from '../../../../ably';\r\n\r\nexport interface IPartialErrorInfo extends Error {\r\n  code: number | null;\r\n  statusCode?: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n}\r\n\r\nfunction toString(err: ErrorInfo | PartialErrorInfo) {\r\n  let result = '[' + err.constructor.name;\r\n  if (err.message) result += ': ' + err.message;\r\n  if (err.statusCode) result += '; statusCode=' + err.statusCode;\r\n  if (err.code) result += '; code=' + err.code;\r\n  if (err.cause) result += '; cause=' + Utils.inspectError(err.cause);\r\n  if (err.href && !(err.message && err.message.indexOf('help.ably.io') > -1)) result += '; see ' + err.href + ' ';\r\n  result += ']';\r\n  return result;\r\n}\r\n\r\nexport interface IConvertibleToErrorInfo {\r\n  message: string;\r\n  code: number;\r\n  statusCode: number;\r\n}\r\n\r\nexport interface IConvertibleToPartialErrorInfo {\r\n  message: string;\r\n  code: number | null;\r\n  statusCode?: number;\r\n}\r\n\r\nexport default class ErrorInfo extends Error implements IPartialErrorInfo, API.ErrorInfo {\r\n  code: number;\r\n  statusCode: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n\r\n  constructor(message: string, code: number, statusCode: number, cause?: string | Error | ErrorInfo) {\r\n    super(message);\r\n    if (typeof Object.setPrototypeOf !== 'undefined') {\r\n      Object.setPrototypeOf(this, ErrorInfo.prototype);\r\n    }\r\n    this.code = code;\r\n    this.statusCode = statusCode;\r\n    this.cause = cause;\r\n  }\r\n\r\n  toString(): string {\r\n    return toString(this);\r\n  }\r\n\r\n  static fromValues(values: IConvertibleToErrorInfo): ErrorInfo {\r\n    const { message, code, statusCode } = values;\r\n    if (typeof message !== 'string' || typeof code !== 'number' || typeof statusCode !== 'number') {\r\n      throw new Error('ErrorInfo.fromValues(): invalid values: ' + Platform.Config.inspect(values));\r\n    }\r\n    const result = Object.assign(new ErrorInfo(message, code, statusCode), values);\r\n    if (result.code && !result.href) {\r\n      result.href = 'https://help.ably.io/error/' + result.code;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\nexport class PartialErrorInfo extends Error implements IPartialErrorInfo {\r\n  code: number | null;\r\n  statusCode?: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n\r\n  constructor(message: string, code: number | null, statusCode?: number, cause?: string | Error | ErrorInfo) {\r\n    super(message);\r\n    if (typeof Object.setPrototypeOf !== 'undefined') {\r\n      Object.setPrototypeOf(this, PartialErrorInfo.prototype);\r\n    }\r\n    this.code = code;\r\n    this.statusCode = statusCode;\r\n    this.cause = cause;\r\n  }\r\n\r\n  toString(): string {\r\n    return toString(this);\r\n  }\r\n\r\n  static fromValues(values: IConvertibleToPartialErrorInfo): PartialErrorInfo {\r\n    const { message, code, statusCode } = values;\r\n    if (\r\n      typeof message !== 'string' ||\r\n      (!Utils.isNil(code) && typeof code !== 'number') ||\r\n      (!Utils.isNil(statusCode) && typeof statusCode !== 'number')\r\n    ) {\r\n      throw new Error('PartialErrorInfo.fromValues(): invalid values: ' + Platform.Config.inspect(values));\r\n    }\r\n    const result = Object.assign(new PartialErrorInfo(message, code, statusCode), values);\r\n    if (result.code && !result.href) {\r\n      result.href = 'https://help.ably.io/error/' + result.code;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n", "{\r\n  \"name\": \"ably\",\r\n  \"description\": \"Realtime client library for Ably, the realtime messaging service\",\r\n  \"version\": \"2.2.0\",\r\n  \"license\": \"Apache-2.0\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/ably/ably-js/issues\",\r\n    \"email\": \"support@ably.com\"\r\n  },\r\n  \"main\": \"./build/ably-node.js\",\r\n  \"browser\": \"./build/ably.js\",\r\n  \"react-native\": \"./build/ably-reactnative.js\",\r\n  \"typings\": \"./ably.d.ts\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"types\": \"./ably.d.ts\",\r\n      \"node\": \"./build/ably-node.js\",\r\n      \"react-native\": \"./build/ably-reactnative.js\",\r\n      \"default\": \"./build/ably.js\"\r\n    },\r\n    \"./modular\": {\r\n      \"types\": \"./modular.d.ts\",\r\n      \"import\": \"./build/modular/index.mjs\"\r\n    },\r\n    \"./react\": {\r\n      \"require\": \"./react/cjs/index.js\",\r\n      \"import\": \"./react/mjs/index.js\"\r\n    }\r\n  },\r\n  \"files\": [\r\n    \"build/**\",\r\n    \"ably.d.ts\",\r\n    \"modular.d.ts\",\r\n    \"resources/**\",\r\n    \"src/**\",\r\n    \"react/**\"\r\n  ],\r\n  \"dependencies\": {\r\n    \"@ably/msgpack-js\": \"^0.4.0\",\r\n    \"fastestsmallesttextencoderdecoder\": \"^1.0.22\",\r\n    \"got\": \"^11.8.5\",\r\n    \"ws\": \"^8.17.1\"\r\n  },\r\n  \"peerDependencies\": {\r\n    \"react\": \">=16.8.0\",\r\n    \"react-dom\": \">=16.8.0\"\r\n  },\r\n  \"peerDependenciesMeta\": {\r\n    \"react\": {\r\n      \"optional\": true\r\n    },\r\n    \"react-dom\": {\r\n      \"optional\": true\r\n    }\r\n  },\r\n  \"devDependencies\": {\r\n    \"@ably/vcdiff-decoder\": \"1.0.6\",\r\n    \"@arethetypeswrong/cli\": \"^0.13.1\",\r\n    \"@babel/generator\": \"^7.23.6\",\r\n    \"@babel/parser\": \"^7.23.6\",\r\n    \"@babel/traverse\": \"^7.23.7\",\r\n    \"@testing-library/react\": \"^13.3.0\",\r\n    \"@types/cli-table\": \"^0.3.4\",\r\n    \"@types/jmespath\": \"^0.15.2\",\r\n    \"@types/node\": \"^18.0.0\",\r\n    \"@types/request\": \"^2.48.7\",\r\n    \"@types/ws\": \"^8.2.0\",\r\n    \"@typescript-eslint/eslint-plugin\": \"^5.59.6\",\r\n    \"@typescript-eslint/parser\": \"^5.59.6\",\r\n    \"@vitejs/plugin-react\": \"^1.3.2\",\r\n    \"async\": \"ably-forks/async#requirejs\",\r\n    \"aws-sdk\": \"^2.1413.0\",\r\n    \"chai\": \"^4.2.0\",\r\n    \"cli-table\": \"^0.3.11\",\r\n    \"cors\": \"^2.8.5\",\r\n    \"esbuild\": \"^0.18.10\",\r\n    \"esbuild-plugin-umd-wrapper\": \"ably-forks/esbuild-plugin-umd-wrapper#1.0.7-optional-amd-named-module\",\r\n    \"esbuild-runner\": \"^2.2.2\",\r\n    \"eslint\": \"^7.13.0\",\r\n    \"eslint-plugin-import\": \"^2.28.0\",\r\n    \"eslint-plugin-jsdoc\": \"^40.0.0\",\r\n    \"eslint-plugin-react\": \"^7.32.2\",\r\n    \"eslint-plugin-react-hooks\": \"^4.6.0\",\r\n    \"eslint-plugin-security\": \"^1.4.0\",\r\n    \"express\": \"^4.17.1\",\r\n    \"glob\": \"~4.4\",\r\n    \"grunt\": \"^1.6.1\",\r\n    \"grunt-cli\": \"~1.2.0\",\r\n    \"grunt-shell\": \"~1.1\",\r\n    \"grunt-webpack\": \"^5.0.0\",\r\n    \"hexy\": \"~0.2\",\r\n    \"jmespath\": \"^0.16.0\",\r\n    \"jsdom\": \"^20.0.0\",\r\n    \"minimist\": \"^1.2.5\",\r\n    \"mocha\": \"^8.1.3\",\r\n    \"mocha-junit-reporter\": \"^2.2.1\",\r\n    \"path-browserify\": \"^1.0.1\",\r\n    \"playwright\": \"^1.39.0\",\r\n    \"prettier\": \"^2.8.8\",\r\n    \"process\": \"^0.11.10\",\r\n    \"react\": \">=18.1.0\",\r\n    \"react-dom\": \">=18.1.0\",\r\n    \"requirejs\": \"~2.1\",\r\n    \"shelljs\": \"~0.8\",\r\n    \"source-map-explorer\": \"^2.5.2\",\r\n    \"source-map-support\": \"^0.5.21\",\r\n    \"stream-browserify\": \"^3.0.0\",\r\n    \"ts-loader\": \"^9.4.2\",\r\n    \"tsconfig-paths-webpack-plugin\": \"^4.0.1\",\r\n    \"tslib\": \"^2.3.1\",\r\n    \"typedoc\": \"^0.24.7\",\r\n    \"typescript\": \"^4.9.5\",\r\n    \"vite\": \"^4.4.9\",\r\n    \"vitest\": \"^0.18.0\",\r\n    \"webpack\": \"^5.79.0\",\r\n    \"webpack-cli\": \"^5.0.1\"\r\n  },\r\n  \"engines\": {\r\n    \"node\": \">=16\"\r\n  },\r\n  \"repository\": \"ably/ably-js\",\r\n  \"jspm\": {\r\n    \"registry\": \"npm\",\r\n    \"directories\": {\r\n      \"lib\": \"build\"\r\n    },\r\n    \"main\": \"ably\"\r\n  },\r\n  \"scripts\": {\r\n    \"start:react\": \"npx vite serve\",\r\n    \"grunt\": \"grunt\",\r\n    \"test\": \"npm run test:node\",\r\n    \"test:node\": \"npm run build:node && mocha\",\r\n    \"test:node:skip-build\": \"mocha\",\r\n    \"test:webserver\": \"grunt test:webserver\",\r\n    \"test:playwright\": \"node test/support/runPlaywrightTests.js\",\r\n    \"test:react\": \"vitest run\",\r\n    \"test:package\": \"grunt test:package\",\r\n    \"concat\": \"grunt concat\",\r\n    \"build\": \"grunt build:all && npm run build:react\",\r\n    \"build:node\": \"grunt build:node\",\r\n    \"build:browser\": \"grunt build:browser\",\r\n    \"build:react\": \"npm run build:react:mjs && npm run build:react:cjs && cp src/platform/react-hooks/res/package.react.json react/package.json\",\r\n    \"build:react:mjs\": \"tsc --project src/platform/react-hooks/tsconfig.mjs.json && cp src/platform/react-hooks/res/package.mjs.json react/mjs/package.json\",\r\n    \"build:react:cjs\": \"tsc --project src/platform/react-hooks/tsconfig.cjs.json && cp src/platform/react-hooks/res/package.cjs.json react/cjs/package.json\",\r\n    \"requirejs\": \"grunt requirejs\",\r\n    \"lint\": \"eslint .\",\r\n    \"lint:fix\": \"eslint --fix .\",\r\n    \"prepare\": \"npm run build\",\r\n    \"format\": \"prettier --write --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts modular.d.ts webpack.config.js Gruntfile.js scripts/*.[jt]s docs/**/*.md grunt\",\r\n    \"format:check\": \"prettier --check --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts modular.d.ts webpack.config.js Gruntfile.js scripts/*.[jt]s docs/**/*.md grunt\",\r\n    \"sourcemap\": \"source-map-explorer build/ably.min.js\",\r\n    \"modulereport\": \"tsc --noEmit --esModuleInterop scripts/moduleReport.ts && esr scripts/moduleReport.ts\",\r\n    \"docs\": \"typedoc\"\r\n  }\r\n}\r\n", "import Platform from 'common/platform';\r\nimport * as Utils from './utils';\r\nimport Logger from './logger';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport { version } from '../../../../package.json';\r\nimport ClientOptions, { NormalisedClientOptions } from 'common/types/ClientOptions';\r\nimport IDefaults from '../../types/IDefaults';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { ChannelOptions } from 'common/types/channel';\r\nimport { ModularPlugins } from '../client/modularplugins';\r\n\r\nlet agent = 'ably-js/' + version;\r\n\r\ntype CompleteDefaults = IDefaults & {\r\n  ENVIRONMENT: string;\r\n  REST_HOST: string;\r\n  REALTIME_HOST: string;\r\n  FALLBACK_HOSTS: string[];\r\n  PORT: number;\r\n  TLS_PORT: number;\r\n  TIMEOUTS: {\r\n    disconnectedRetryTimeout: number;\r\n    suspendedRetryTimeout: number;\r\n    httpRequestTimeout: number;\r\n    httpMaxRetryDuration: number;\r\n    channelRetryTimeout: number;\r\n    fallbackRetryTimeout: number;\r\n    connectionStateTtl: number;\r\n    realtimeRequestTimeout: number;\r\n    recvTimeout: number;\r\n    webSocketConnectTimeout: number;\r\n    webSocketSlowTimeout: number;\r\n  };\r\n  httpMaxRetryCount: number;\r\n  maxMessageSize: number;\r\n  version: string;\r\n  protocolVersion: number;\r\n  agent: string;\r\n  getHost(options: ClientOptions, host?: string | null, ws?: boolean): string;\r\n  getPort(options: ClientOptions, tls?: boolean): number | undefined;\r\n  getHttpScheme(options: ClientOptions): string;\r\n  environmentFallbackHosts(environment: string): string[];\r\n  getFallbackHosts(options: NormalisedClientOptions): string[];\r\n  getHosts(options: NormalisedClientOptions, ws?: boolean): string[];\r\n  checkHost(host: string): void;\r\n  objectifyOptions(\r\n    options: undefined | ClientOptions | string,\r\n    allowKeyOrToken: boolean,\r\n    sourceForErrorMessage: string,\r\n    logger: Logger,\r\n    modularPluginsToInclude?: ModularPlugins,\r\n  ): ClientOptions;\r\n  normaliseOptions(options: ClientOptions, MsgPack: MsgPack | null, logger: Logger | null): NormalisedClientOptions;\r\n  defaultGetHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\r\n  defaultPostHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\r\n};\r\n\r\nconst Defaults = {\r\n  ENVIRONMENT: '',\r\n  REST_HOST: 'rest.ably.io',\r\n  REALTIME_HOST: 'realtime.ably.io',\r\n  FALLBACK_HOSTS: [\r\n    'A.ably-realtime.com',\r\n    'B.ably-realtime.com',\r\n    'C.ably-realtime.com',\r\n    'D.ably-realtime.com',\r\n    'E.ably-realtime.com',\r\n  ],\r\n  PORT: 80,\r\n  TLS_PORT: 443,\r\n  TIMEOUTS: {\r\n    /* Documented as options params: */\r\n    disconnectedRetryTimeout: 15000,\r\n    suspendedRetryTimeout: 30000,\r\n    /* Undocumented, but part of the api and can be used by customers: */\r\n    httpRequestTimeout: 10000,\r\n    httpMaxRetryDuration: 15000,\r\n    channelRetryTimeout: 15000,\r\n    fallbackRetryTimeout: 600000,\r\n    /* For internal / test use only: */\r\n    connectionStateTtl: 120000,\r\n    realtimeRequestTimeout: 10000,\r\n    recvTimeout: 90000,\r\n    webSocketConnectTimeout: 10000,\r\n    webSocketSlowTimeout: 4000,\r\n  },\r\n  httpMaxRetryCount: 3,\r\n  maxMessageSize: 65536,\r\n\r\n  version,\r\n  protocolVersion: 3,\r\n  agent,\r\n  getHost,\r\n  getPort,\r\n  getHttpScheme,\r\n  environmentFallbackHosts,\r\n  getFallbackHosts,\r\n  getHosts,\r\n  checkHost,\r\n  objectifyOptions,\r\n  normaliseOptions,\r\n  defaultGetHeaders,\r\n  defaultPostHeaders,\r\n};\r\n\r\nexport function getHost(options: ClientOptions, host?: string | null, ws?: boolean): string {\r\n  if (ws) host = (host == options.restHost && options.realtimeHost) || host || options.realtimeHost;\r\n  else host = host || options.restHost;\r\n\r\n  return host as string;\r\n}\r\n\r\nexport function getPort(options: ClientOptions, tls?: boolean): number | undefined {\r\n  return tls || options.tls ? options.tlsPort : options.port;\r\n}\r\n\r\nexport function getHttpScheme(options: ClientOptions): string {\r\n  return options.tls ? 'https://' : 'http://';\r\n}\r\n\r\n// construct environment fallback hosts as per RSC15i\r\nexport function environmentFallbackHosts(environment: string): string[] {\r\n  return [\r\n    environment + '-a-fallback.ably-realtime.com',\r\n    environment + '-b-fallback.ably-realtime.com',\r\n    environment + '-c-fallback.ably-realtime.com',\r\n    environment + '-d-fallback.ably-realtime.com',\r\n    environment + '-e-fallback.ably-realtime.com',\r\n  ];\r\n}\r\n\r\nexport function getFallbackHosts(options: NormalisedClientOptions): string[] {\r\n  const fallbackHosts = options.fallbackHosts,\r\n    httpMaxRetryCount =\r\n      typeof options.httpMaxRetryCount !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\r\n\r\n  return fallbackHosts ? Utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\r\n}\r\n\r\nexport function getHosts(options: NormalisedClientOptions, ws?: boolean): string[] {\r\n  const hosts = [options.restHost].concat(getFallbackHosts(options));\r\n  return ws ? hosts.map((host) => getHost(options, host, true)) : hosts;\r\n}\r\n\r\nfunction checkHost(host: string): void {\r\n  if (typeof host !== 'string') {\r\n    throw new ErrorInfo('host must be a string; was a ' + typeof host, 40000, 400);\r\n  }\r\n  if (!host.length) {\r\n    throw new ErrorInfo('host must not be zero-length', 40000, 400);\r\n  }\r\n}\r\n\r\nfunction getRealtimeHost(options: ClientOptions, production: boolean, environment: string, logger: Logger): string {\r\n  if (options.realtimeHost) return options.realtimeHost;\r\n  /* prefer setting realtimeHost to restHost as a custom restHost typically indicates\r\n   * a development environment is being used that can't be inferred by the library */\r\n  if (options.restHost) {\r\n    Logger.logAction(\r\n      logger,\r\n      Logger.LOG_MINOR,\r\n      'Defaults.normaliseOptions',\r\n      'restHost is set to \"' +\r\n        options.restHost +\r\n        '\" but realtimeHost is not set, so setting realtimeHost to \"' +\r\n        options.restHost +\r\n        '\" too. If this is not what you want, please set realtimeHost explicitly.',\r\n    );\r\n    return options.restHost;\r\n  }\r\n  return production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;\r\n}\r\n\r\nfunction getTimeouts(options: ClientOptions) {\r\n  /* Allow values passed in options to override default timeouts */\r\n  const timeouts: Record<string, number> = {};\r\n  for (const prop in Defaults.TIMEOUTS) {\r\n    timeouts[prop] = (options as Record<string, number>)[prop] || (Defaults.TIMEOUTS as Record<string, number>)[prop];\r\n  }\r\n  return timeouts;\r\n}\r\n\r\nexport function getAgentString(options: ClientOptions): string {\r\n  let agentStr = Defaults.agent;\r\n  if (options.agents) {\r\n    for (var agent in options.agents) {\r\n      agentStr += ' ' + agent + '/' + options.agents[agent];\r\n    }\r\n  }\r\n  return agentStr;\r\n}\r\n\r\nexport function objectifyOptions(\r\n  options: undefined | ClientOptions | string,\r\n  allowKeyOrToken: boolean,\r\n  sourceForErrorMessage: string,\r\n  logger: Logger,\r\n  modularPluginsToInclude?: ModularPlugins,\r\n): ClientOptions {\r\n  if (options === undefined) {\r\n    const msg = allowKeyOrToken\r\n      ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token`\r\n      : `${sourceForErrorMessage} must be initialized with a client options object`;\r\n    Logger.logAction(logger, Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n    throw new Error(msg);\r\n  }\r\n\r\n  let optionsObj: ClientOptions;\r\n\r\n  if (typeof options === 'string') {\r\n    if (options.indexOf(':') == -1) {\r\n      if (!allowKeyOrToken) {\r\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\u2019s \\`token\\` property.)`;\r\n        Logger.logAction(logger, Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n        throw new Error(msg);\r\n      }\r\n\r\n      optionsObj = { token: options };\r\n    } else {\r\n      if (!allowKeyOrToken) {\r\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\u2019s \\`key\\` property.)`;\r\n        Logger.logAction(logger, Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n        throw new Error(msg);\r\n      }\r\n\r\n      optionsObj = { key: options };\r\n    }\r\n  } else {\r\n    optionsObj = options;\r\n  }\r\n\r\n  if (modularPluginsToInclude) {\r\n    optionsObj = { ...optionsObj, plugins: { ...modularPluginsToInclude, ...optionsObj.plugins } };\r\n  }\r\n\r\n  return optionsObj;\r\n}\r\n\r\nexport function normaliseOptions(\r\n  options: ClientOptions,\r\n  MsgPack: MsgPack | null,\r\n  logger: Logger | null, // should only be omitted by tests\r\n): NormalisedClientOptions {\r\n  const loggerToUse = logger ?? Logger.defaultLogger;\r\n\r\n  if (typeof options.recover === 'function' && options.closeOnUnload === true) {\r\n    Logger.logAction(\r\n      loggerToUse,\r\n      Logger.LOG_ERROR,\r\n      'Defaults.normaliseOptions',\r\n      'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter',\r\n    );\r\n    options.recover = undefined;\r\n  }\r\n\r\n  if (!('closeOnUnload' in options)) {\r\n    /* Have closeOnUnload default to true unless we have any indication that\r\n     * the user may want to recover the connection */\r\n    options.closeOnUnload = !options.recover;\r\n  }\r\n\r\n  if (!('queueMessages' in options)) options.queueMessages = true;\r\n\r\n  /* infer hosts and fallbacks based on the configured environment */\r\n  const environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;\r\n  const production = !environment || environment === 'production';\r\n\r\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\r\n    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\r\n  }\r\n\r\n  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST);\r\n  const realtimeHost = getRealtimeHost(options, production, environment, loggerToUse);\r\n\r\n  (options.fallbackHosts || []).concat(restHost, realtimeHost).forEach(checkHost);\r\n\r\n  options.port = options.port || Defaults.PORT;\r\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\r\n  if (!('tls' in options)) options.tls = true;\r\n\r\n  const timeouts = getTimeouts(options);\r\n\r\n  if (MsgPack) {\r\n    if ('useBinaryProtocol' in options) {\r\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\r\n    } else {\r\n      options.useBinaryProtocol = Platform.Config.preferBinary;\r\n    }\r\n  } else {\r\n    options.useBinaryProtocol = false;\r\n  }\r\n\r\n  const headers: Record<string, string> = {};\r\n  if (options.clientId) {\r\n    headers['X-Ably-ClientId'] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\r\n  }\r\n\r\n  if (!('idempotentRestPublishing' in options)) {\r\n    options.idempotentRestPublishing = true;\r\n  }\r\n\r\n  let connectivityCheckParams = null;\r\n  let connectivityCheckUrl = options.connectivityCheckUrl;\r\n  if (options.connectivityCheckUrl) {\r\n    let [uri, qs] = options.connectivityCheckUrl.split('?');\r\n    connectivityCheckParams = qs ? Utils.parseQueryString(qs) : {};\r\n    if (uri.indexOf('://') === -1) {\r\n      uri = 'https://' + uri;\r\n    }\r\n    connectivityCheckUrl = uri;\r\n  }\r\n\r\n  return {\r\n    ...options,\r\n    realtimeHost,\r\n    restHost,\r\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\r\n    timeouts,\r\n    connectivityCheckParams,\r\n    connectivityCheckUrl,\r\n    headers,\r\n  };\r\n}\r\n\r\nexport function normaliseChannelOptions(Crypto: IUntypedCryptoStatic | null, logger: Logger, options?: ChannelOptions) {\r\n  const channelOptions = options || {};\r\n  if (channelOptions.cipher) {\r\n    if (!Crypto) Utils.throwMissingPluginError('Crypto');\r\n    const cipher = Crypto.getCipher(channelOptions.cipher, logger);\r\n    channelOptions.cipher = cipher.cipherParams;\r\n    channelOptions.channelCipher = cipher.cipher;\r\n  } else if ('cipher' in channelOptions) {\r\n    /* Don't deactivate an existing cipher unless options\r\n     * has a 'cipher' key that's falsey */\r\n    channelOptions.cipher = undefined;\r\n    channelOptions.channelCipher = null;\r\n  }\r\n  return channelOptions;\r\n}\r\n\r\nconst contentTypes = {\r\n  json: 'application/json',\r\n  xml: 'application/xml',\r\n  html: 'text/html',\r\n  msgpack: 'application/x-msgpack',\r\n};\r\n\r\nexport interface HeadersOptions {\r\n  format?: Utils.Format;\r\n  protocolVersion?: number;\r\n}\r\n\r\nconst defaultHeadersOptions: Required<HeadersOptions> = {\r\n  format: Utils.Format.json,\r\n  protocolVersion: Defaults.protocolVersion,\r\n};\r\n\r\nexport function defaultGetHeaders(\r\n  options: NormalisedClientOptions,\r\n  {\r\n    format = defaultHeadersOptions.format,\r\n    protocolVersion = defaultHeadersOptions.protocolVersion,\r\n  }: HeadersOptions = {},\r\n): Record<string, string> {\r\n  const accept = contentTypes[format];\r\n  return {\r\n    accept: accept,\r\n    'X-Ably-Version': protocolVersion.toString(),\r\n    'Ably-Agent': getAgentString(options),\r\n  };\r\n}\r\n\r\nexport function defaultPostHeaders(\r\n  options: NormalisedClientOptions,\r\n  {\r\n    format = defaultHeadersOptions.format,\r\n    protocolVersion = defaultHeadersOptions.protocolVersion,\r\n  }: HeadersOptions = {},\r\n): Record<string, string> {\r\n  let contentType;\r\n  const accept = (contentType = contentTypes[format]);\r\n\r\n  return {\r\n    accept: accept,\r\n    'content-type': contentType,\r\n    'X-Ably-Version': protocolVersion.toString(),\r\n    'Ably-Agent': getAgentString(options),\r\n  };\r\n}\r\n\r\nexport default Defaults as CompleteDefaults;\r\n\r\nexport function getDefaults(platformDefaults: IDefaults) {\r\n  return Object.assign(Defaults, platformDefaults);\r\n}\r\n", "import { StandardCallback } from 'common/types/utils';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport Logger from './logger';\r\n\r\nexport interface MulticasterInstance<T> extends Function {\r\n  (err?: ErrorInfo | null, result?: T): void;\r\n  push: (fn: StandardCallback<T>) => void;\r\n  /**\r\n   * Creates a promise that will be resolved or rejected when this instance is called.\r\n   */\r\n  createPromise: () => Promise<T>;\r\n  /**\r\n   * Syntatic sugar for when working in a context that uses promises; equivalent to calling as a function with arguments (null, result).\r\n   */\r\n  resolveAll(result: T): void;\r\n  /**\r\n   * Syntatic sugar for when working in a context that uses promises; equivalent to calling as a function with arguments (err).\r\n   */\r\n  rejectAll(err: ErrorInfo): void;\r\n}\r\n\r\nclass Multicaster<T> {\r\n  members: Array<StandardCallback<T>>;\r\n\r\n  // Private constructor; use static Multicaster.create instead\r\n  private constructor(private readonly logger: Logger, members?: Array<StandardCallback<T> | undefined>) {\r\n    this.members = (members as Array<StandardCallback<T>>) || [];\r\n  }\r\n\r\n  private call(err?: ErrorInfo | null, result?: T): void {\r\n    for (const member of this.members) {\r\n      if (member) {\r\n        try {\r\n          member(err, result);\r\n        } catch (e) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_ERROR,\r\n            'Multicaster multiple callback handler',\r\n            'Unexpected exception: ' + e + '; stack = ' + (e as Error).stack,\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  push(...args: Array<StandardCallback<T>>): void {\r\n    this.members.push(...args);\r\n  }\r\n\r\n  createPromise(): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      this.push((err, result) => {\r\n        err ? reject(err) : resolve(result!);\r\n      });\r\n    });\r\n  }\r\n\r\n  resolveAll(result: T) {\r\n    this.call(null, result);\r\n  }\r\n\r\n  rejectAll(err: ErrorInfo) {\r\n    this.call(err);\r\n  }\r\n\r\n  static create<T>(logger: Logger, members?: Array<StandardCallback<T> | undefined>): MulticasterInstance<T> {\r\n    const instance = new Multicaster(logger, members);\r\n    return Object.assign((err?: ErrorInfo | null, result?: T) => instance.call(err, result), {\r\n      push: (fn: StandardCallback<T>) => instance.push(fn),\r\n      createPromise: () => instance.createPromise(),\r\n      resolveAll: (result: T) => instance.resolveAll(result),\r\n      rejectAll: (err: ErrorInfo) => instance.rejectAll(err),\r\n    });\r\n  }\r\n}\r\n\r\nexport default Multicaster;\r\n", "enum HttpMethods {\r\n  Get = 'get',\r\n  Delete = 'delete',\r\n  Post = 'post',\r\n  Put = 'put',\r\n  Patch = 'patch',\r\n}\r\n\r\nexport default HttpMethods;\r\n", "enum HttpStatusCodes {\r\n  Success = 200,\r\n  NoContent = 204,\r\n  BadRequest = 400,\r\n  Unauthorized = 401,\r\n  Forbidden = 403,\r\n  RequestTimeout = 408,\r\n  InternalServerError = 500,\r\n}\r\n\r\nexport function isSuccessCode(statusCode: number) {\r\n  return statusCode >= HttpStatusCodes.Success && statusCode < HttpStatusCodes.BadRequest;\r\n}\r\n\r\nexport default HttpStatusCodes;\r\n", "import Logger from '../util/logger';\r\nimport * as Utils from '../util/utils';\r\nimport Multicaster, { MulticasterInstance } from '../util/multicaster';\r\nimport ErrorInfo, { IPartialErrorInfo } from '../types/errorinfo';\r\nimport { RequestResultError, RequestParams, RequestResult } from '../../types/http';\r\nimport * as API from '../../../../ably';\r\nimport BaseClient from './baseclient';\r\nimport BaseRealtime from './baserealtime';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport HttpStatusCodes from 'common/constants/HttpStatusCodes';\r\nimport Platform, { Bufferlike } from '../../platform';\r\nimport Defaults from '../util/defaults';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\ntype TokenRevocationTargetSpecifier = API.TokenRevocationTargetSpecifier;\r\ntype TokenRevocationOptions = API.TokenRevocationOptions;\r\ntype TokenRevocationSuccessResult = API.TokenRevocationSuccessResult;\r\ntype TokenRevocationFailureResult = API.TokenRevocationFailureResult;\r\ntype TokenRevocationResult = BatchResult<TokenRevocationSuccessResult | TokenRevocationFailureResult>;\r\n\r\nconst MAX_TOKEN_LENGTH = Math.pow(2, 17);\r\nfunction random() {\r\n  return ('000000' + Math.floor(Math.random() * 1e16)).slice(-16);\r\n}\r\n\r\nfunction isRealtime(client: BaseClient): client is BaseRealtime {\r\n  return !!(client as BaseRealtime).connection;\r\n}\r\n\r\n/* A client auth callback may give errors in any number of formats; normalise to an ErrorInfo or PartialErrorInfo */\r\nfunction normaliseAuthcallbackError(err: any) {\r\n  if (!Utils.isErrorInfoOrPartialErrorInfo(err)) {\r\n    return new ErrorInfo(Utils.inspectError(err), err.code || 40170, err.statusCode || 401);\r\n  }\r\n  /* network errors will not have an inherent error code */\r\n  if (!err.code) {\r\n    if (err.statusCode === 403) {\r\n      err.code = 40300;\r\n    } else {\r\n      err.code = 40170;\r\n      /* normalise statusCode to 401 per RSA4e */\r\n      err.statusCode = 401;\r\n    }\r\n  }\r\n  return err;\r\n}\r\n\r\nlet hmac = (text: string, key: string): string => {\r\n  const bufferUtils = Platform.BufferUtils;\r\n\r\n  const textBuffer = bufferUtils.utf8Encode(text);\r\n  const keyBuffer = bufferUtils.utf8Encode(key);\r\n\r\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\r\n\r\n  return bufferUtils.base64Encode(digest);\r\n};\r\n\r\nfunction c14n(capability?: string | Record<string, Array<string>>) {\r\n  if (!capability) return '';\r\n\r\n  if (typeof capability == 'string') capability = JSON.parse(capability);\r\n\r\n  const c14nCapability: Record<string, Array<string>> = Object.create(null);\r\n  const keys = Utils.keysArray(capability as Record<string, Array<string>>, true);\r\n  if (!keys) return '';\r\n  keys.sort();\r\n  for (let i = 0; i < keys.length; i++) {\r\n    c14nCapability[keys[i]] = (capability as Record<string, Array<string>>)[keys[i]].sort();\r\n  }\r\n  return JSON.stringify(c14nCapability);\r\n}\r\n\r\nfunction logAndValidateTokenAuthMethod(authOptions: AuthOptions, logger: Logger) {\r\n  if (authOptions.authCallback) {\r\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with authCallback');\r\n  } else if (authOptions.authUrl) {\r\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with authUrl');\r\n  } else if (authOptions.key) {\r\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');\r\n  } else if (authOptions.tokenDetails) {\r\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');\r\n  } else {\r\n    const msg = 'authOptions must include valid authentication parameters';\r\n    Logger.logAction(logger, Logger.LOG_ERROR, 'Auth()', msg);\r\n    throw new Error(msg);\r\n  }\r\n}\r\n\r\nfunction basicAuthForced(options: ClientOptions) {\r\n  return 'useTokenAuth' in options && !options.useTokenAuth;\r\n}\r\n\r\n/* RSA4 */\r\nexport function useTokenAuth(options: ClientOptions) {\r\n  return (\r\n    options.useTokenAuth ||\r\n    (!basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails))\r\n  );\r\n}\r\n\r\n/* RSA4a */\r\nfunction noWayToRenew(options: ClientOptions) {\r\n  return !options.key && !options.authCallback && !options.authUrl;\r\n}\r\n\r\nlet trId = 0;\r\nfunction getTokenRequestId() {\r\n  return trId++;\r\n}\r\n\r\n/**\r\n * Auth options used only for testing.\r\n */\r\ntype PrivateAuthOptions = {\r\n  requestHeaders?: Record<string, string>;\r\n  suppressMaxLengthCheck?: boolean;\r\n};\r\n\r\ntype AuthOptions = API.AuthOptions & PrivateAuthOptions;\r\n\r\nclass Auth {\r\n  client: BaseClient;\r\n  tokenParams: API.TokenParams;\r\n  currentTokenRequestId: number | null;\r\n  waitingForTokenRequest: MulticasterInstance<API.TokenDetails> | null;\r\n  // This initialization is always overwritten and only used to prevent a TypeScript compiler error\r\n  authOptions: AuthOptions = {} as AuthOptions;\r\n  tokenDetails?: API.TokenDetails | null;\r\n  method?: string;\r\n  key?: string;\r\n  basicKey?: string;\r\n  clientId?: string | null;\r\n\r\n  constructor(client: BaseClient, options: ClientOptions) {\r\n    this.client = client;\r\n    this.tokenParams = options.defaultTokenParams || {};\r\n    /* The id of the current token request if one is in progress, else null */\r\n    this.currentTokenRequestId = null;\r\n    this.waitingForTokenRequest = null;\r\n\r\n    if (useTokenAuth(options)) {\r\n      /* Token auth */\r\n      if (noWayToRenew(options)) {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_ERROR,\r\n          'Auth()',\r\n          'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help',\r\n        );\r\n      }\r\n      this._saveTokenOptions(options.defaultTokenParams as API.TokenDetails, options);\r\n      logAndValidateTokenAuthMethod(this.authOptions, this.logger);\r\n    } else {\r\n      /* Basic auth */\r\n      if (!options.key) {\r\n        const msg =\r\n          'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';\r\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth()', msg);\r\n        throw new ErrorInfo(msg, 40160, 401);\r\n      }\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');\r\n      this._saveBasicOptions(options);\r\n    }\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.client.logger;\r\n  }\r\n\r\n  /**\r\n   * Instructs the library to get a token immediately and ensures Token Auth\r\n   * is used for all future requests, storing the tokenParams and authOptions\r\n   * given as the new defaults for subsequent use.\r\n   */\r\n  async authorize(): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Instructs the library to get a token immediately and ensures Token Auth\r\n   * is used for all future requests, storing the tokenParams and authOptions\r\n   * given as the new defaults for subsequent use.\r\n   *\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   *\r\n   * - ttl:        (optional) the requested life of any new token in ms. If none\r\n   *               is specified a default of 1 hour is provided. The maximum lifetime\r\n   *               is 24hours; any request exceeding that lifetime will be rejected\r\n   *               with an error.\r\n   *\r\n   * - capability: (optional) the capability to associate with the access token.\r\n   *               If none is specified, a token will be requested with all of the\r\n   *               capabilities of the specified key.\r\n   *\r\n   * - clientId:   (optional) a client ID to associate with the token\r\n   *\r\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\r\n   *               the system will be queried for a time value to use.\r\n   */\r\n  async authorize(tokenParams: API.TokenParams | null): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Instructs the library to get a token immediately and ensures Token Auth\r\n   * is used for all future requests, storing the tokenParams and authOptions\r\n   * given as the new defaults for subsequent use.\r\n   *\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   *\r\n   * - ttl:        (optional) the requested life of any new token in ms. If none\r\n   *               is specified a default of 1 hour is provided. The maximum lifetime\r\n   *               is 24hours; any request exceeding that lifetime will be rejected\r\n   *               with an error.\r\n   *\r\n   * - capability: (optional) the capability to associate with the access token.\r\n   *               If none is specified, a token will be requested with all of the\r\n   *               capabilities of the specified key.\r\n   *\r\n   * - clientId:   (optional) a client ID to associate with the token\r\n   *\r\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\r\n   *               the system will be queried for a time value to use.\r\n   *\r\n   * @param authOptions\r\n   * an object containing auth options relevant to token auth:\r\n   *\r\n   * - queryTime   (optional) boolean indicating that the Ably system should be\r\n   *               queried for the current time when none is specified explicitly.\r\n   *\r\n   * - tokenDetails: (optional) object: An authenticated TokenDetails object.\r\n   *\r\n   * - token:        (optional) string: the `token` property of a tokenDetails object\r\n   *\r\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\r\n   *                  authCallback should be a function of (tokenParams, callback) that calls\r\n   *                  the callback with (err, result), where result is any of:\r\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\r\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\r\n   *                  - a token string\r\n   *\r\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\r\n   *                  params, to obtain a signed token request.\r\n   *\r\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\r\n   *                  made to the authUrl.\r\n   *\r\n   * - authParams:    (optional) a set of application-specific query params to be added to any\r\n   *                  request made to the authUrl.\r\n   *\r\n   *\r\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\r\n   *                  requestToken request\r\n   */\r\n  async authorize(tokenParams: API.TokenParams | null, authOptions: AuthOptions | null): Promise<API.TokenDetails>;\r\n\r\n  async authorize(\r\n    tokenParams?: Record<string, any> | null,\r\n    authOptions?: AuthOptions | null,\r\n  ): Promise<API.TokenDetails> {\r\n    /* RSA10a: authorize() call implies token auth. If a key is passed it, we\r\n     * just check if it doesn't clash and assume we're generating a token from it */\r\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\r\n      throw new ErrorInfo('Unable to update auth options with incompatible key', 40102, 401);\r\n    }\r\n\r\n    try {\r\n      let tokenDetails = await this._forceNewToken(tokenParams ?? null, authOptions ?? null);\r\n\r\n      /* RTC8\r\n       * - When authorize called by an end user and have a realtime connection,\r\n       * don't call back till new token has taken effect.\r\n       * - Use this.client.connection as a proxy for (this.client instanceof BaseRealtime),\r\n       * which doesn't work in node as BaseRealtime isn't part of the vm context for Rest clients */\r\n      if (isRealtime(this.client)) {\r\n        return new Promise((resolve, reject) => {\r\n          (this.client as BaseRealtime).connection.connectionManager.onAuthUpdated(\r\n            tokenDetails,\r\n            (err: unknown, tokenDetails?: API.TokenDetails) => (err ? reject(err) : resolve(tokenDetails!)),\r\n          );\r\n        });\r\n      } else {\r\n        return tokenDetails;\r\n      }\r\n    } catch (err) {\r\n      if ((this.client as BaseRealtime).connection && (err as ErrorInfo).statusCode === HttpStatusCodes.Forbidden) {\r\n        /* Per RSA4d & RSA4d1, if the auth server explicitly repudiates our right to\r\n         * stay connecticed by returning a 403, we actively disconnect the connection\r\n         * even though we may well still have time left in the old token. */\r\n        (this.client as BaseRealtime).connection.connectionManager.actOnErrorFromAuthorize(err as ErrorInfo);\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  /* For internal use, eg by connectionManager - useful when want to call back\r\n   * as soon as we have the new token, rather than waiting for it to take\r\n   * effect on the connection as #authorize does */\r\n  async _forceNewToken(\r\n    tokenParams: API.TokenParams | null,\r\n    authOptions: AuthOptions | null,\r\n  ): Promise<API.TokenDetails> {\r\n    /* get rid of current token even if still valid */\r\n    this.tokenDetails = null;\r\n\r\n    /* _save normalises the tokenParams and authOptions and updates the auth\r\n     * object. All subsequent operations should use the values on `this`,\r\n     * not the passed in ones. */\r\n    this._saveTokenOptions(tokenParams, authOptions);\r\n\r\n    logAndValidateTokenAuthMethod(this.authOptions, this.logger);\r\n\r\n    try {\r\n      return this._ensureValidAuthCredentials(true);\r\n    } finally {\r\n      /* RSA10g */\r\n      delete this.tokenParams.timestamp;\r\n      delete this.authOptions.queryTime;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Request an access token\r\n   */\r\n  async requestToken(): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Request an access token\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\r\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\r\n   *                  exceeding that lifetime will be rejected with an error.\r\n   *\r\n   * - capability:    (optional) the capability to associate with the access token.\r\n   *                  If none is specified, a token will be requested with all of the\r\n   *                  capabilities of the specified key.\r\n   *\r\n   * - clientId:      (optional) a client ID to associate with the token; if not\r\n   *                  specified, a clientId passed in constructing the Rest interface will be used\r\n   *\r\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\r\n   *                  the system will be queried for a time value to use.\r\n   */\r\n  async requestToken(tokenParams: API.TokenParams | null): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Request an access token\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\r\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\r\n   *                  exceeding that lifetime will be rejected with an error.\r\n   *\r\n   * - capability:    (optional) the capability to associate with the access token.\r\n   *                  If none is specified, a token will be requested with all of the\r\n   *                  capabilities of the specified key.\r\n   *\r\n   * - clientId:      (optional) a client ID to associate with the token; if not\r\n   *                  specified, a clientId passed in constructing the Rest interface will be used\r\n   *\r\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\r\n   *                  the system will be queried for a time value to use.\r\n   *\r\n   * @param authOptions\r\n   * an object containing the request options:\r\n   * - key:           the key to use.\r\n   *\r\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\r\n   *                  authCallback should be a function of (tokenParams, callback) that calls\r\n   *                  the callback with (err, result), where result is any of:\r\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\r\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\r\n   *                  - a token string\r\n   *\r\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\r\n   *                  params, to obtain a signed token request.\r\n   *\r\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\r\n   *                  made to the authUrl.\r\n   *\r\n   * - authParams:    (optional) a set of application-specific query params to be added to any\r\n   *                  request made to the authUrl.\r\n   *\r\n   * - queryTime      (optional) boolean indicating that the ably system should be\r\n   *                  queried for the current time when none is specified explicitly\r\n   *\r\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\r\n   *                  requestToken request\r\n   */\r\n  async requestToken(tokenParams: API.TokenParams | null, authOptions: AuthOptions): Promise<API.TokenDetails>;\r\n\r\n  async requestToken(tokenParams?: API.TokenParams | null, authOptions?: AuthOptions): Promise<API.TokenDetails> {\r\n    /* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */\r\n    const resolvedAuthOptions = authOptions || this.authOptions;\r\n    const resolvedTokenParams = tokenParams || Utils.copy(this.tokenParams);\r\n\r\n    /* first set up whatever callback will be used to get signed\r\n     * token requests */\r\n    let tokenRequestCallback: (\r\n        data: API.TokenParams,\r\n        callback: (\r\n          error: API.ErrorInfo | RequestResultError | string | null,\r\n          tokenRequestOrDetails: API.TokenDetails | API.TokenRequest | string | null,\r\n          contentType?: string,\r\n        ) => void,\r\n      ) => void,\r\n      client = this.client;\r\n\r\n    if (resolvedAuthOptions.authCallback) {\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');\r\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\r\n    } else if (resolvedAuthOptions.authUrl) {\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');\r\n      tokenRequestCallback = (params, cb) => {\r\n        const authHeaders = Utils.mixin(\r\n          { accept: 'application/json, text/plain' },\r\n          resolvedAuthOptions.authHeaders,\r\n        ) as Record<string, string>;\r\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === 'post';\r\n        let providedQsParams;\r\n        /* Combine authParams with any qs params given in the authUrl */\r\n        const queryIdx = resolvedAuthOptions.authUrl!.indexOf('?');\r\n        if (queryIdx > -1) {\r\n          providedQsParams = Utils.parseQueryString(resolvedAuthOptions.authUrl!.slice(queryIdx));\r\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl!.slice(0, queryIdx);\r\n          if (!usePost) {\r\n            /* In case of conflict, authParams take precedence over qs params in the authUrl */\r\n            resolvedAuthOptions.authParams = Utils.mixin(\r\n              providedQsParams,\r\n              resolvedAuthOptions.authParams,\r\n            ) as typeof resolvedAuthOptions.authParams;\r\n          }\r\n        }\r\n        /* RSA8c2 */\r\n        const authParams = Utils.mixin({}, resolvedAuthOptions.authParams || {}, params) as RequestParams;\r\n        const authUrlRequestCallback = (result: RequestResult) => {\r\n          let body = (result.body ?? null) as string | Bufferlike | API.TokenDetails | API.TokenRequest | null;\r\n\r\n          let contentType: string | null = null;\r\n          if (result.error) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MICRO,\r\n              'Auth.requestToken().tokenRequestCallback',\r\n              'Received Error: ' + Utils.inspectError(result.error),\r\n            );\r\n          } else {\r\n            const contentTypeHeaderOrHeaders = result.headers!['content-type'] ?? null;\r\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\r\n              // Combine multiple header values into a comma-separated list per https://datatracker.ietf.org/doc/html/rfc9110#section-5.2; see https://github.com/ably/ably-js/issues/1616 for doing this consistently across the codebase.\r\n              contentType = contentTypeHeaderOrHeaders.join(', ');\r\n            } else {\r\n              contentType = contentTypeHeaderOrHeaders;\r\n            }\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MICRO,\r\n              'Auth.requestToken().tokenRequestCallback',\r\n              'Received; content-type: ' + contentType + '; body: ' + Utils.inspectBody(body),\r\n            );\r\n          }\r\n          if (result.error) {\r\n            cb(result.error, null);\r\n            return;\r\n          }\r\n          if (result.unpacked) {\r\n            cb(null, body as Exclude<typeof body, Bufferlike>);\r\n            return;\r\n          }\r\n          if (Platform.BufferUtils.isBuffer(body)) body = body.toString();\r\n          if (!contentType) {\r\n            cb(new ErrorInfo('authUrl response is missing a content-type header', 40170, 401), null);\r\n            return;\r\n          }\r\n          const json = contentType.indexOf('application/json') > -1,\r\n            text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;\r\n          if (!json && !text) {\r\n            cb(\r\n              new ErrorInfo(\r\n                'authUrl responded with unacceptable content-type ' +\r\n                  contentType +\r\n                  ', should be either text/plain, application/jwt or application/json',\r\n                40170,\r\n                401,\r\n              ),\r\n              null,\r\n            );\r\n            return;\r\n          }\r\n          if (json) {\r\n            if ((body as string).length > MAX_TOKEN_LENGTH) {\r\n              cb(new ErrorInfo('authUrl response exceeded max permitted length', 40170, 401), null);\r\n              return;\r\n            }\r\n            try {\r\n              body = JSON.parse(body as string);\r\n            } catch (e) {\r\n              cb(\r\n                new ErrorInfo(\r\n                  'Unexpected error processing authURL response; err = ' + (e as Error).message,\r\n                  40170,\r\n                  401,\r\n                ),\r\n                null,\r\n              );\r\n              return;\r\n            }\r\n          }\r\n          cb(null, body as Exclude<typeof body, Bufferlike>, contentType);\r\n        };\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          'Auth.requestToken().tokenRequestCallback',\r\n          'Requesting token from ' +\r\n            resolvedAuthOptions.authUrl +\r\n            '; Params: ' +\r\n            JSON.stringify(authParams) +\r\n            '; method: ' +\r\n            (usePost ? 'POST' : 'GET'),\r\n        );\r\n        if (usePost) {\r\n          /* send body form-encoded */\r\n          const headers = authHeaders || {};\r\n          headers['content-type'] = 'application/x-www-form-urlencoded';\r\n          const body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */\r\n          Utils.whenPromiseSettles(\r\n            this.client.http.doUri(\r\n              HttpMethods.Post,\r\n              resolvedAuthOptions.authUrl!,\r\n              headers,\r\n              body,\r\n              providedQsParams as Record<string, string>,\r\n            ),\r\n            (err: any, result) =>\r\n              err\r\n                ? authUrlRequestCallback(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\r\n                : authUrlRequestCallback(result!),\r\n          );\r\n        } else {\r\n          Utils.whenPromiseSettles(\r\n            this.client.http.doUri(HttpMethods.Get, resolvedAuthOptions.authUrl!, authHeaders || {}, null, authParams),\r\n            (err: any, result) =>\r\n              err\r\n                ? authUrlRequestCallback(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\r\n                : authUrlRequestCallback(result!),\r\n          );\r\n        }\r\n      };\r\n    } else if (resolvedAuthOptions.key) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'Auth.requestToken()',\r\n        'using token auth with client-side signing',\r\n      );\r\n      tokenRequestCallback = (params, cb) => {\r\n        Utils.whenPromiseSettles(this.createTokenRequest(params, resolvedAuthOptions), (err, result) =>\r\n          cb(err as string | ErrorInfo | null, result ?? null),\r\n        );\r\n      };\r\n    } else {\r\n      const msg =\r\n        'Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)';\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'Auth()',\r\n        'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help',\r\n      );\r\n      throw new ErrorInfo(msg, 40171, 403);\r\n    }\r\n\r\n    /* normalise token params */\r\n    if ('capability' in (resolvedTokenParams as Record<string, any>))\r\n      (resolvedTokenParams as Record<string, any>).capability = c14n(\r\n        (resolvedTokenParams as Record<string, any>).capability,\r\n      );\r\n\r\n    const tokenRequest = (\r\n      signedTokenParams: Record<string, any>,\r\n      tokenCb: (err: RequestResultError | null, tokenResponse?: API.TokenDetails | string, unpacked?: boolean) => void,\r\n    ) => {\r\n      const keyName = signedTokenParams.keyName,\r\n        path = '/keys/' + keyName + '/requestToken',\r\n        tokenUri = function (host: string) {\r\n          return client.baseUri(host) + path;\r\n        };\r\n\r\n      const requestHeaders = Defaults.defaultPostHeaders(this.client.options);\r\n      if (resolvedAuthOptions.requestHeaders) Utils.mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'Auth.requestToken().requestToken',\r\n        'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams),\r\n      );\r\n      Utils.whenPromiseSettles(\r\n        this.client.http.do(HttpMethods.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\r\n        (err: any, result) =>\r\n          err\r\n            ? tokenCb(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\r\n            : tokenCb(result!.error, result!.body as API.TokenDetails | string | undefined, result!.unpacked),\r\n      );\r\n    };\r\n\r\n    return new Promise((resolve, reject) => {\r\n      let tokenRequestCallbackTimeoutExpired = false,\r\n        timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,\r\n        tokenRequestCallbackTimeout = setTimeout(() => {\r\n          tokenRequestCallbackTimeoutExpired = true;\r\n          const msg = 'Token request callback timed out after ' + timeoutLength / 1000 + ' seconds';\r\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth.requestToken()', msg);\r\n          reject(new ErrorInfo(msg, 40170, 401));\r\n        }, timeoutLength);\r\n\r\n      tokenRequestCallback!(resolvedTokenParams, (err, tokenRequestOrDetails, contentType) => {\r\n        if (tokenRequestCallbackTimeoutExpired) return;\r\n        clearTimeout(tokenRequestCallbackTimeout);\r\n\r\n        if (err) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_ERROR,\r\n            'Auth.requestToken()',\r\n            'token request signing call returned error; err = ' + Utils.inspectError(err),\r\n          );\r\n          reject(normaliseAuthcallbackError(err));\r\n          return;\r\n        }\r\n        /* the response from the callback might be a token string, a signed request or a token details */\r\n        if (typeof tokenRequestOrDetails === 'string') {\r\n          if (tokenRequestOrDetails.length === 0) {\r\n            reject(new ErrorInfo('Token string is empty', 40170, 401));\r\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\r\n            reject(\r\n              new ErrorInfo(\r\n                'Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)',\r\n                40170,\r\n                401,\r\n              ),\r\n            );\r\n          } else if (tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {\r\n            /* common failure mode with poorly-implemented authCallbacks */\r\n            reject(new ErrorInfo('Token string was literal null/undefined', 40170, 401));\r\n          } else if (\r\n            tokenRequestOrDetails[0] === '{' &&\r\n            !(contentType && contentType.indexOf('application/jwt') > -1)\r\n          ) {\r\n            reject(\r\n              new ErrorInfo(\r\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\r\n                40170,\r\n                401,\r\n              ),\r\n            );\r\n          } else {\r\n            resolve({ token: tokenRequestOrDetails } as API.TokenDetails);\r\n          }\r\n          return;\r\n        }\r\n        if (typeof tokenRequestOrDetails !== 'object' || tokenRequestOrDetails === null) {\r\n          const msg =\r\n            'Expected token request callback to call back with a token string or token request/details object, but got a ' +\r\n            typeof tokenRequestOrDetails;\r\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth.requestToken()', msg);\r\n          reject(new ErrorInfo(msg, 40170, 401));\r\n          return;\r\n        }\r\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\r\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\r\n          reject(\r\n            new ErrorInfo(\r\n              'Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)',\r\n              40170,\r\n              401,\r\n            ),\r\n          );\r\n          return;\r\n        }\r\n        if ('issued' in tokenRequestOrDetails) {\r\n          /* a tokenDetails object */\r\n          resolve(tokenRequestOrDetails);\r\n          return;\r\n        }\r\n        if (!('keyName' in tokenRequestOrDetails)) {\r\n          const msg =\r\n            'Expected token request callback to call back with a token string, token request object, or token details object';\r\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth.requestToken()', msg);\r\n          reject(new ErrorInfo(msg, 40170, 401));\r\n          return;\r\n        }\r\n        /* it's a token request, so make the request */\r\n        tokenRequest(tokenRequestOrDetails, (err, tokenResponse, unpacked) => {\r\n          if (err) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_ERROR,\r\n              'Auth.requestToken()',\r\n              'token request API call returned error; err = ' + Utils.inspectError(err),\r\n            );\r\n            reject(normaliseAuthcallbackError(err));\r\n            return;\r\n          }\r\n          if (!unpacked) tokenResponse = JSON.parse(tokenResponse as string);\r\n          Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.getToken()', 'token received');\r\n          resolve(tokenResponse as API.TokenDetails);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create and sign a token request based on the given options.\r\n   * NOTE this can only be used when the key value is available locally.\r\n   * Otherwise, signed token requests must be obtained from the key\r\n   * owner (either using the token request callback or url).\r\n   *\r\n   * @param authOptions\r\n   * an object containing the request options:\r\n   * - key:           the key to use. If not specified, a key passed in constructing\r\n   *                  the Rest interface will be used\r\n   *\r\n   * - queryTime      (optional) boolean indicating that the ably system should be\r\n   *                  queried for the current time when none is specified explicitly\r\n   *\r\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\r\n   *                  requestToken request\r\n   *\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\r\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\r\n   *                  exceeding that lifetime will be rejected with an error.\r\n   *\r\n   * - capability:    (optional) the capability to associate with the access token.\r\n   *                  If none is specified, a token will be requested with all of the\r\n   *                  capabilities of the specified key.\r\n   *\r\n   * - clientId:      (optional) a client ID to associate with the token; if not\r\n   *                  specified, a clientId passed in constructing the Rest interface will be used\r\n   *\r\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\r\n   *                  the system will be queried for a time value to use.\r\n   */\r\n  async createTokenRequest(tokenParams: API.TokenParams | null, authOptions: any): Promise<API.TokenRequest> {\r\n    /* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */\r\n    authOptions = authOptions || this.authOptions;\r\n    tokenParams = tokenParams || Utils.copy<API.TokenParams>(this.tokenParams);\r\n\r\n    const key = authOptions.key;\r\n    if (!key) {\r\n      throw new ErrorInfo('No key specified', 40101, 403);\r\n    }\r\n    const keyParts = key.split(':'),\r\n      keyName = keyParts[0],\r\n      keySecret = keyParts[1];\r\n\r\n    if (!keySecret) {\r\n      throw new ErrorInfo('Invalid key specified', 40101, 403);\r\n    }\r\n\r\n    if (tokenParams.clientId === '') {\r\n      throw new ErrorInfo('clientId can\u2019t be an empty string', 40012, 400);\r\n    }\r\n\r\n    if ('capability' in tokenParams) {\r\n      tokenParams.capability = c14n(tokenParams.capability);\r\n    }\r\n\r\n    const request: Partial<API.TokenRequest> = Utils.mixin({ keyName: keyName }, tokenParams),\r\n      clientId = tokenParams.clientId || '',\r\n      ttl = tokenParams.ttl || '',\r\n      capability = tokenParams.capability || '';\r\n\r\n    if (!request.timestamp) {\r\n      request.timestamp = await this.getTimestamp(authOptions && authOptions.queryTime);\r\n    }\r\n\r\n    /* nonce */\r\n    /* NOTE: there is no expectation that the client\r\n     * specifies the nonce; this is done by the library\r\n     * However, this can be overridden by the client\r\n     * simply for testing purposes. */\r\n    const nonce = request.nonce || (request.nonce = random()),\r\n      timestamp = request.timestamp;\r\n\r\n    const signText =\r\n      request.keyName + '\\n' + ttl + '\\n' + capability + '\\n' + clientId + '\\n' + timestamp + '\\n' + nonce + '\\n';\r\n\r\n    /* mac */\r\n    /* NOTE: there is no expectation that the client\r\n     * specifies the mac; this is done by the library\r\n     * However, this can be overridden by the client\r\n     * simply for testing purposes. */\r\n    request.mac = request.mac || hmac(signText, keySecret);\r\n\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');\r\n\r\n    return request as API.TokenRequest;\r\n  }\r\n\r\n  /**\r\n   * Get the auth query params to use for a websocket connection,\r\n   * based on the current auth parameters\r\n   */\r\n  async getAuthParams(): Promise<Record<string, string>> {\r\n    if (this.method == 'basic') return { key: this.key! };\r\n    else {\r\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\r\n      if (!tokenDetails) {\r\n        throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\r\n      }\r\n      return { access_token: tokenDetails.token };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the authorization header to use for a REST or comet request,\r\n   * based on the current auth parameters\r\n   */\r\n  async getAuthHeaders(): Promise<Record<string, string>> {\r\n    if (this.method == 'basic') {\r\n      return { authorization: 'Basic ' + this.basicKey };\r\n    } else {\r\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\r\n      if (!tokenDetails) {\r\n        throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\r\n      }\r\n      return { authorization: 'Bearer ' + Utils.toBase64(tokenDetails.token) };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the current time based on the local clock,\r\n   * or if the option queryTime is true, return the server time.\r\n   * The server time offset from the local time is stored so that\r\n   * only one request to the server to get the time is ever needed\r\n   */\r\n  async getTimestamp(queryTime: boolean): Promise<number> {\r\n    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\r\n      return this.client.time();\r\n    } else {\r\n      return this.getTimestampUsingOffset();\r\n    }\r\n  }\r\n\r\n  getTimestampUsingOffset() {\r\n    return Date.now() + (this.client.serverTimeOffset || 0);\r\n  }\r\n\r\n  isTimeOffsetSet() {\r\n    return this.client.serverTimeOffset !== null;\r\n  }\r\n\r\n  _saveBasicOptions(authOptions: AuthOptions) {\r\n    this.method = 'basic';\r\n    this.key = authOptions.key;\r\n    this.basicKey = Utils.toBase64(authOptions.key as string);\r\n    this.authOptions = authOptions || {};\r\n    if ('clientId' in authOptions) {\r\n      this._userSetClientId(authOptions.clientId);\r\n    }\r\n  }\r\n\r\n  _saveTokenOptions(tokenParams: API.TokenParams | null, authOptions: AuthOptions | null) {\r\n    this.method = 'token';\r\n\r\n    if (tokenParams) {\r\n      /* We temporarily persist tokenParams.timestamp in case a new token needs\r\n       * to be requested, then null it out in the callback of\r\n       * _ensureValidAuthCredentials for RSA10g compliance */\r\n      this.tokenParams = tokenParams;\r\n    }\r\n\r\n    if (authOptions) {\r\n      /* normalise */\r\n      if (authOptions.token) {\r\n        /* options.token may contain a token string or, for convenience, a TokenDetails */\r\n        authOptions.tokenDetails =\r\n          typeof authOptions.token === 'string'\r\n            ? ({ token: authOptions.token } as API.TokenDetails)\r\n            : authOptions.token;\r\n      }\r\n\r\n      if (authOptions.tokenDetails) {\r\n        this.tokenDetails = authOptions.tokenDetails;\r\n      }\r\n\r\n      if ('clientId' in authOptions) {\r\n        this._userSetClientId(authOptions.clientId);\r\n      }\r\n\r\n      this.authOptions = authOptions;\r\n    }\r\n  }\r\n\r\n  /* @param forceSupersede: force a new token request even if there's one in\r\n   * progress, making all pending callbacks wait for the new one */\r\n  async _ensureValidAuthCredentials(forceSupersede: boolean): Promise<API.TokenDetails> {\r\n    const token = this.tokenDetails;\r\n\r\n    if (token) {\r\n      if (this._tokenClientIdMismatch(token.clientId)) {\r\n        /* 403 to trigger a permanently failed client - RSA15c */\r\n        throw new ErrorInfo(\r\n          'Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')',\r\n          40102,\r\n          403,\r\n        );\r\n      }\r\n      /* RSA4b1 -- if we have a server time offset set already, we can\r\n       * automatically remove expired tokens. Else just use the cached token. If it is\r\n       * expired Ably will tell us and we'll discard it then. */\r\n      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'Auth.getToken()',\r\n          'using cached token; expires = ' + token.expires,\r\n        );\r\n        return token;\r\n      }\r\n      /* expired, so remove and fallthrough to getting a new one */\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');\r\n      this.tokenDetails = null;\r\n    }\r\n\r\n    const promise = (\r\n      this.waitingForTokenRequest || (this.waitingForTokenRequest = Multicaster.create(this.logger))\r\n    ).createPromise();\r\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\r\n      return promise;\r\n    }\r\n\r\n    /* Request a new token */\r\n    const tokenRequestId = (this.currentTokenRequestId = getTokenRequestId());\r\n\r\n    let tokenResponse: API.TokenDetails,\r\n      caughtError: ErrorInfo | null = null;\r\n    try {\r\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\r\n    } catch (err) {\r\n      caughtError = err as ErrorInfo;\r\n    }\r\n\r\n    if ((this.currentTokenRequestId as number) > tokenRequestId) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'Auth._ensureValidAuthCredentials()',\r\n        'Discarding token request response; overtaken by newer one',\r\n      );\r\n      return promise;\r\n    }\r\n\r\n    this.currentTokenRequestId = null;\r\n    const multicaster = this.waitingForTokenRequest;\r\n    this.waitingForTokenRequest = null;\r\n    if (caughtError) {\r\n      multicaster?.rejectAll(caughtError);\r\n      return promise;\r\n    }\r\n    multicaster?.resolveAll((this.tokenDetails = tokenResponse!));\r\n\r\n    return promise;\r\n  }\r\n\r\n  /* User-set: check types, '*' is disallowed, throw any errors */\r\n  _userSetClientId(clientId: string | undefined) {\r\n    if (!(typeof clientId === 'string' || clientId === null)) {\r\n      throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\r\n    } else if (clientId === '*') {\r\n      throw new ErrorInfo(\r\n        'Can\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\r\n        40012,\r\n        400,\r\n      );\r\n    } else {\r\n      const err = this._uncheckedSetClientId(clientId);\r\n      if (err) throw err;\r\n    }\r\n  }\r\n\r\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\r\n  _uncheckedSetClientId(clientId: string | undefined) {\r\n    if (this._tokenClientIdMismatch(clientId)) {\r\n      /* Should never happen in normal circumstances as realtime should\r\n       * recognise mismatch and return an error */\r\n      const msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;\r\n      const err = new ErrorInfo(msg, 40102, 401);\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);\r\n      return err;\r\n    } else {\r\n      /* RSA7a4: if options.clientId is provided and is not\r\n       * null, it overrides defaultTokenParams.clientId */\r\n      this.clientId = this.tokenParams.clientId = clientId;\r\n      return null;\r\n    }\r\n  }\r\n\r\n  _tokenClientIdMismatch(tokenClientId?: string | null): boolean {\r\n    return !!(\r\n      this.clientId &&\r\n      this.clientId !== '*' &&\r\n      tokenClientId &&\r\n      tokenClientId !== '*' &&\r\n      this.clientId !== tokenClientId\r\n    );\r\n  }\r\n\r\n  static isTokenErr(error: IPartialErrorInfo) {\r\n    return error.code && error.code >= 40140 && error.code < 40150;\r\n  }\r\n\r\n  revokeTokens(\r\n    specifiers: TokenRevocationTargetSpecifier[],\r\n    options?: TokenRevocationOptions,\r\n  ): Promise<TokenRevocationResult> {\r\n    return this.client.rest.revokeTokens(specifiers, options);\r\n  }\r\n}\r\n\r\nexport default Auth;\r\n", "import Defaults from 'common/lib/util/defaults';\r\nimport Platform from 'common/platform';\r\nimport BaseRealtime from 'common/lib/client/baserealtime';\r\nimport HttpMethods from '../constants/HttpMethods';\r\nimport BaseClient from '../lib/client/baseclient';\r\nimport ErrorInfo, { IPartialErrorInfo } from '../lib/types/errorinfo';\r\nimport Logger from 'common/lib/util/logger';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\nexport type PathParameter = string | ((host: string) => string);\r\nexport type ResponseHeaders = Partial<Record<string, string | string[]>>;\r\nexport type RequestResultError = ErrnoException | IPartialErrorInfo;\r\n\r\n/**\r\n * The `body`, `headers`, `unpacked`, and `statusCode` properties of a `RequestResult` may be populated even if its `error` property is non-null.\r\n */\r\nexport type RequestResult = {\r\n  error: RequestResultError | null;\r\n  body?: unknown;\r\n  headers?: ResponseHeaders;\r\n  unpacked?: boolean;\r\n  statusCode?: number;\r\n};\r\n\r\nexport type RequestParams = Record<string, string> | null;\r\nexport type RequestBody =\r\n  | Buffer // only on Node\r\n  | ArrayBuffer // only on web\r\n  | string;\r\n\r\nexport interface IPlatformHttpStatic {\r\n  new (client?: BaseClient): IPlatformHttp;\r\n  methods: Array<HttpMethods>;\r\n  methodsWithBody: Array<HttpMethods>;\r\n  methodsWithoutBody: Array<HttpMethods>;\r\n}\r\n\r\nexport interface IPlatformHttp {\r\n  supportsAuthHeaders: boolean;\r\n  supportsLinkHeaders: boolean;\r\n\r\n  /**\r\n   * This method should not throw any errors; rather, it should communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult>;\r\n\r\n  checkConnectivity?: () => Promise<boolean>;\r\n\r\n  /**\r\n   * @param error An error from the {@link RequestResult.error} property of a result returned by {@link doUri}.\r\n   */\r\n  shouldFallback(error: RequestResultError): boolean;\r\n}\r\n\r\nexport function paramString(params: Record<string, any> | null) {\r\n  const paramPairs = [];\r\n  if (params) {\r\n    for (const needle in params) {\r\n      paramPairs.push(needle + '=' + params[needle]);\r\n    }\r\n  }\r\n  return paramPairs.join('&');\r\n}\r\n\r\nexport function appendingParams(uri: string, params: Record<string, any> | null) {\r\n  return uri + (params ? '?' : '') + paramString(params);\r\n}\r\n\r\nfunction logResult(\r\n  result: RequestResult,\r\n  method: HttpMethods,\r\n  uri: string,\r\n  params: Record<string, string> | null,\r\n  logger: Logger,\r\n) {\r\n  if (result.error) {\r\n    Logger.logActionNoStrip(\r\n      logger,\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Received Error; ' + appendingParams(uri, params) + '; Error: ' + Utils.inspectError(result.error),\r\n    );\r\n  } else {\r\n    Logger.logActionNoStrip(\r\n      logger,\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Received; ' +\r\n        appendingParams(uri, params) +\r\n        '; Headers: ' +\r\n        paramString(result.headers as Record<string, any>) +\r\n        '; StatusCode: ' +\r\n        result.statusCode +\r\n        '; Body' +\r\n        (Platform.BufferUtils.isBuffer(result.body)\r\n          ? ' (Base64): ' + Platform.BufferUtils.base64Encode(result.body)\r\n          : ': ' + result.body),\r\n    );\r\n  }\r\n}\r\n\r\nfunction logRequest(method: HttpMethods, uri: string, body: RequestBody | null, params: RequestParams, logger: Logger) {\r\n  if (logger.shouldLog(Logger.LOG_MICRO)) {\r\n    Logger.logActionNoStrip(\r\n      logger,\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Sending; ' +\r\n        appendingParams(uri, params) +\r\n        '; Body' +\r\n        (Platform.BufferUtils.isBuffer(body) ? ' (Base64): ' + Platform.BufferUtils.base64Encode(body) : ': ' + body),\r\n    );\r\n  }\r\n}\r\n\r\nexport class Http {\r\n  private readonly platformHttp: IPlatformHttp;\r\n  checkConnectivity?: () => Promise<boolean>;\r\n\r\n  constructor(private readonly client?: BaseClient) {\r\n    this.platformHttp = new Platform.Http(client);\r\n\r\n    this.checkConnectivity = this.platformHttp.checkConnectivity\r\n      ? () => this.platformHttp.checkConnectivity!()\r\n      : undefined;\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.client?.logger ?? Logger.defaultLogger;\r\n  }\r\n\r\n  get supportsAuthHeaders() {\r\n    return this.platformHttp.supportsAuthHeaders;\r\n  }\r\n\r\n  get supportsLinkHeaders() {\r\n    return this.platformHttp.supportsLinkHeaders;\r\n  }\r\n\r\n  _getHosts(client: BaseClient) {\r\n    /* If we're a connected realtime client, try the endpoint we're connected\r\n     * to first -- but still have fallbacks, being connected is not an absolute\r\n     * guarantee that a datacenter has free capacity to service REST requests. */\r\n    const connection = (client as BaseRealtime).connection,\r\n      connectionHost = connection && connection.connectionManager.host;\r\n\r\n    if (connectionHost) {\r\n      return [connectionHost].concat(Defaults.getFallbackHosts(client.options));\r\n    }\r\n\r\n    return Defaults.getHosts(client.options);\r\n  }\r\n\r\n  /**\r\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  async do(\r\n    method: HttpMethods,\r\n    path: PathParameter,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    try {\r\n      /* Unlike for doUri, the presence of `this.client` here is mandatory, as it's used to generate the hosts */\r\n      const client = this.client;\r\n      if (!client) {\r\n        return { error: new ErrorInfo('http.do called without client', 50000, 500) };\r\n      }\r\n\r\n      const uriFromHost =\r\n        typeof path === 'function'\r\n          ? path\r\n          : function (host: string) {\r\n              return client.baseUri(host) + path;\r\n            };\r\n\r\n      const currentFallback = client._currentFallback;\r\n      if (currentFallback) {\r\n        if (currentFallback.validUntil > Date.now()) {\r\n          /* Use stored fallback */\r\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\r\n          if (result.error && this.platformHttp.shouldFallback(result.error as ErrnoException)) {\r\n            /* unstore the fallback and start from the top with the default sequence */\r\n            client._currentFallback = null;\r\n            return this.do(method, path, headers, body, params);\r\n          }\r\n          return result;\r\n        } else {\r\n          /* Fallback expired; remove it and fallthrough to normal sequence */\r\n          client._currentFallback = null;\r\n        }\r\n      }\r\n\r\n      const hosts = this._getHosts(client);\r\n\r\n      /* see if we have one or more than one host */\r\n      if (hosts.length === 1) {\r\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\r\n      }\r\n\r\n      let tryAHostStartedAt: Date | null = null;\r\n      const tryAHost = async (candidateHosts: Array<string>, persistOnSuccess?: boolean): Promise<RequestResult> => {\r\n        const host = candidateHosts.shift();\r\n        tryAHostStartedAt = tryAHostStartedAt ?? new Date();\r\n        const result = await this.doUri(method, uriFromHost(host as string), headers, body, params);\r\n        if (result.error && this.platformHttp.shouldFallback(result.error as ErrnoException) && candidateHosts.length) {\r\n          // TO3l6\r\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\r\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\r\n            return {\r\n              error: new ErrorInfo(\r\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\r\n                50003,\r\n                500,\r\n              ),\r\n            };\r\n          }\r\n\r\n          return tryAHost(candidateHosts, true);\r\n        }\r\n        if (persistOnSuccess) {\r\n          /* RSC15f */\r\n          client._currentFallback = {\r\n            host: host as string,\r\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout,\r\n          };\r\n        }\r\n        return result;\r\n      };\r\n      return tryAHost(hosts);\r\n    } catch (err) {\r\n      // Handle any unexpected error, to ensure we always meet our contract of not throwing any errors\r\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${Utils.inspectError(err)}`, 500, 50000) };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  async doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    try {\r\n      logRequest(method, uri, body, params, this.logger);\r\n\r\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\r\n\r\n      if (this.logger.shouldLog(Logger.LOG_MICRO)) {\r\n        logResult(result, method, uri, params, this.logger);\r\n      }\r\n\r\n      return result;\r\n    } catch (err) {\r\n      // Handle any unexpected error, to ensure we always meet our contract of not throwing any errors\r\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${Utils.inspectError(err)}`, 500, 50000) };\r\n    }\r\n  }\r\n}\r\n\r\nexport interface ErrnoException extends Error {\r\n  errno?: number;\r\n  code?: string;\r\n  path?: string;\r\n  syscall?: string;\r\n  stack?: string;\r\n  statusCode: number;\r\n}\r\n", "import Logger, { LoggerOptions } from '../util/logger';\r\nimport Defaults from '../util/defaults';\r\nimport Auth from './auth';\r\nimport { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Stats from '../types/stats';\r\nimport { Http, RequestParams } from '../../types/http';\r\nimport ClientOptions, { NormalisedClientOptions } from '../../types/ClientOptions';\r\nimport * as API from '../../../../ably';\r\n\r\nimport Platform from '../../platform';\r\nimport { Rest } from './rest';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { throwMissingPluginError } from '../util/utils';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { HTTPRequestImplementations } from 'platform/web/lib/http/http';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\ntype BatchPublishSpec = API.BatchPublishSpec;\r\ntype BatchPublishSuccessResult = API.BatchPublishSuccessResult;\r\ntype BatchPublishFailureResult = API.BatchPublishFailureResult;\r\ntype BatchPublishResult = BatchResult<BatchPublishSuccessResult | BatchPublishFailureResult>;\r\ntype BatchPresenceSuccessResult = API.BatchPresenceSuccessResult;\r\ntype BatchPresenceFailureResult = API.BatchPresenceFailureResult;\r\ntype BatchPresenceResult = BatchResult<BatchPresenceSuccessResult | BatchPresenceFailureResult>;\r\n\r\n/**\r\n `BaseClient` acts as the base class for all of the client classes exported by the SDK. It is an implementation detail and this class is not advertised publicly.\r\n */\r\nclass BaseClient {\r\n  options: NormalisedClientOptions;\r\n  _currentFallback: null | {\r\n    host: string;\r\n    validUntil: number;\r\n  };\r\n  serverTimeOffset: number | null;\r\n  http: Http;\r\n  auth: Auth;\r\n\r\n  private readonly _rest: Rest | null;\r\n  readonly _Crypto: IUntypedCryptoStatic | null;\r\n  readonly _MsgPack: MsgPack | null;\r\n  // Extra HTTP request implementations available to this client, in addition to those in web\u2019s Http.bundledRequestImplementations\r\n  readonly _additionalHTTPRequestImplementations: HTTPRequestImplementations | null;\r\n  private readonly __FilteredSubscriptions: typeof FilteredSubscriptions | null;\r\n  readonly logger: Logger;\r\n\r\n  constructor(options: ClientOptions) {\r\n    this._additionalHTTPRequestImplementations = options.plugins ?? null;\r\n\r\n    this.logger = new Logger();\r\n    this.logger.setLog(options.logLevel, options.logHandler);\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'BaseClient()',\r\n      'initialized with clientOptions ' + Platform.Config.inspect(options),\r\n    );\r\n\r\n    this._MsgPack = options.plugins?.MsgPack ?? null;\r\n    const normalOptions = (this.options = Defaults.normaliseOptions(options, this._MsgPack, this.logger));\r\n\r\n    /* process options */\r\n    if (normalOptions.key) {\r\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\r\n      if (!keyMatch) {\r\n        const msg = 'invalid key parameter';\r\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'BaseClient()', msg);\r\n        throw new ErrorInfo(msg, 40400, 404);\r\n      }\r\n      normalOptions.keyName = keyMatch[1];\r\n      normalOptions.keySecret = keyMatch[2];\r\n    }\r\n\r\n    if ('clientId' in normalOptions) {\r\n      if (!(typeof normalOptions.clientId === 'string' || normalOptions.clientId === null))\r\n        throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\r\n      else if (normalOptions.clientId === '*')\r\n        throw new ErrorInfo(\r\n          'Can\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\r\n          40012,\r\n          400,\r\n        );\r\n    }\r\n\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'BaseClient()', 'started; version = ' + Defaults.version);\r\n\r\n    this._currentFallback = null;\r\n\r\n    this.serverTimeOffset = null;\r\n    this.http = new Http(this);\r\n    this.auth = new Auth(this, normalOptions);\r\n\r\n    this._rest = options.plugins?.Rest ? new options.plugins.Rest(this) : null;\r\n    this._Crypto = options.plugins?.Crypto ?? null;\r\n    this.__FilteredSubscriptions = options.plugins?.MessageInteractions ?? null;\r\n  }\r\n\r\n  get rest(): Rest {\r\n    if (!this._rest) {\r\n      throwMissingPluginError('Rest');\r\n    }\r\n    return this._rest;\r\n  }\r\n\r\n  get _FilteredSubscriptions(): typeof FilteredSubscriptions {\r\n    if (!this.__FilteredSubscriptions) {\r\n      throwMissingPluginError('MessageInteractions');\r\n    }\r\n    return this.__FilteredSubscriptions;\r\n  }\r\n\r\n  get channels() {\r\n    return this.rest.channels;\r\n  }\r\n\r\n  get push() {\r\n    return this.rest.push;\r\n  }\r\n\r\n  baseUri(host: string) {\r\n    return Defaults.getHttpScheme(this.options) + host + ':' + Defaults.getPort(this.options, false);\r\n  }\r\n\r\n  async stats(params: RequestParams): Promise<PaginatedResult<Stats>> {\r\n    return this.rest.stats(params);\r\n  }\r\n\r\n  async time(params?: RequestParams): Promise<number> {\r\n    return this.rest.time(params);\r\n  }\r\n\r\n  async request(\r\n    method: string,\r\n    path: string,\r\n    version: number,\r\n    params: RequestParams,\r\n    body: unknown,\r\n    customHeaders: Record<string, string>,\r\n  ): Promise<HttpPaginatedResponse<unknown>> {\r\n    return this.rest.request(method, path, version, params, body, customHeaders);\r\n  }\r\n\r\n  batchPublish<T extends BatchPublishSpec | BatchPublishSpec[]>(\r\n    specOrSpecs: T,\r\n  ): Promise<T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[]> {\r\n    return this.rest.batchPublish(specOrSpecs);\r\n  }\r\n\r\n  batchPresence(channels: string[]): Promise<BatchPresenceResult> {\r\n    return this.rest.batchPresence(channels);\r\n  }\r\n\r\n  setLog(logOptions: LoggerOptions): void {\r\n    this.logger.setLog(logOptions.level, logOptions.handler);\r\n  }\r\n\r\n  static Platform = Platform;\r\n}\r\n\r\nexport default BaseClient;\r\n", "import { MsgPack } from 'common/types/msgpack';\r\nimport * as Utils from '../util/utils';\r\nimport ErrorInfo, { IConvertibleToErrorInfo } from './errorinfo';\r\n\r\nenum DeviceFormFactor {\r\n  Phone = 'phone',\r\n  Tablet = 'tablet',\r\n  Desktop = 'desktop',\r\n  TV = 'tv',\r\n  Watch = 'watch',\r\n  Car = 'car',\r\n  Embedded = 'embedded',\r\n  Other = 'other',\r\n}\r\n\r\nenum DevicePlatform {\r\n  Android = 'android',\r\n  IOS = 'ios',\r\n  Browser = 'browser',\r\n}\r\n\r\ntype DevicePushState = 'ACTIVE' | 'FAILING' | 'FAILED';\r\n\r\ntype DevicePushDetails = {\r\n  error?: ErrorInfo;\r\n  recipient?: string;\r\n  state?: DevicePushState;\r\n  metadata?: string;\r\n};\r\n\r\nclass DeviceDetails {\r\n  id?: string;\r\n  clientId?: string;\r\n  deviceSecret?: string;\r\n  formFactor?: DeviceFormFactor;\r\n  platform?: DevicePlatform;\r\n  push?: DevicePushDetails;\r\n  metadata?: string;\r\n  deviceIdentityToken?: string;\r\n\r\n  toJSON(): DeviceDetails {\r\n    return {\r\n      id: this.id,\r\n      deviceSecret: this.deviceSecret,\r\n      platform: this.platform,\r\n      formFactor: this.formFactor,\r\n      clientId: this.clientId,\r\n      metadata: this.metadata,\r\n      deviceIdentityToken: this.deviceIdentityToken,\r\n      push: {\r\n        recipient: this.push?.recipient,\r\n        state: this.push?.state,\r\n        error: this.push?.error,\r\n      },\r\n    } as DeviceDetails;\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[DeviceDetails';\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.platform) result += '; platform=' + this.platform;\r\n    if (this.formFactor) result += '; formFactor=' + this.formFactor;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.metadata) result += '; metadata=' + this.metadata;\r\n    if (this.deviceIdentityToken) result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);\r\n    if (this.push?.recipient) result += '; push.recipient=' + JSON.stringify(this.push.recipient);\r\n    if (this.push?.state) result += '; push.state=' + this.push.state;\r\n    if (this.push?.error) result += '; push.error=' + JSON.stringify(this.push.error);\r\n    if (this.push?.metadata) result += '; push.metadata=' + this.push.metadata;\r\n    result += ']';\r\n    return result;\r\n  }\r\n\r\n  static toRequestBody(body: unknown, MsgPack: MsgPack | null, format?: Utils.Format) {\r\n    return Utils.encodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  static fromResponseBody(\r\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\r\n    MsgPack: MsgPack | null,\r\n    format?: Utils.Format,\r\n  ): DeviceDetails | DeviceDetails[] {\r\n    if (format) {\r\n      body = Utils.decodeBody(body, MsgPack, format);\r\n    }\r\n\r\n    if (Array.isArray(body)) {\r\n      return DeviceDetails.fromValuesArray(body);\r\n    } else {\r\n      return DeviceDetails.fromValues(body);\r\n    }\r\n  }\r\n\r\n  static fromValues(values: Record<string, unknown>): DeviceDetails {\r\n    values.error = values.error && ErrorInfo.fromValues(values.error as IConvertibleToErrorInfo);\r\n    return Object.assign(new DeviceDetails(), values);\r\n  }\r\n\r\n  static fromValuesArray(values: Array<Record<string, unknown>>): DeviceDetails[] {\r\n    const count = values.length,\r\n      result = new Array(count);\r\n    for (let i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default DeviceDetails;\r\n", "import Platform from '../../platform';\r\nimport * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport Auth from './auth';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from '../types/errorinfo';\r\nimport BaseClient from './baseclient';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { RequestBody, ResponseHeaders, appendingParams as urlFromPathAndParams, paramString } from 'common/types/http';\r\nimport httpStatusCodes from '../../constants/HttpStatusCodes';\r\n\r\nasync function withAuthDetails<T>(\r\n  client: BaseClient,\r\n  headers: ResponseHeaders | undefined,\r\n  params: Record<string, any>,\r\n  opCallback: Function,\r\n): Promise<ResourceResult<T>> {\r\n  if (client.http.supportsAuthHeaders) {\r\n    const authHeaders = await client.auth.getAuthHeaders();\r\n    return opCallback(Utils.mixin(authHeaders!, headers), params);\r\n  } else {\r\n    const authParams = await client.auth.getAuthParams();\r\n    return opCallback(headers, Utils.mixin(authParams!, params));\r\n  }\r\n}\r\n\r\nfunction unenvelope<T>(\r\n  result: ResourceResult<T>,\r\n  MsgPack: MsgPack | null,\r\n  format: Utils.Format | null,\r\n): ResourceResult<T> {\r\n  if (result.err && !result.body) {\r\n    return { err: result.err };\r\n  }\r\n\r\n  if (result.statusCode === httpStatusCodes.NoContent) {\r\n    return { ...result, body: [] as any, unpacked: true };\r\n  }\r\n\r\n  let body = result.body;\r\n\r\n  if (!result.unpacked) {\r\n    try {\r\n      body = Utils.decodeBody(body, MsgPack, format);\r\n    } catch (e) {\r\n      if (Utils.isErrorInfoOrPartialErrorInfo(e)) {\r\n        return { err: e };\r\n      } else {\r\n        return { err: new PartialErrorInfo(Utils.inspectError(e), null) };\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!body) {\r\n    return { err: new PartialErrorInfo('unenvelope(): Response body is missing', null) };\r\n  }\r\n\r\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body as Record<string, any>;\r\n\r\n  if (wrappedStatusCode === undefined) {\r\n    /* Envelope already unwrapped by the transport */\r\n    return { ...result, body, unpacked: true };\r\n  }\r\n\r\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\r\n    /* handle wrapped errors */\r\n    let wrappedErr = (response && response.error) || result.err;\r\n    if (!wrappedErr) {\r\n      wrappedErr = new Error('Error in unenveloping ' + body);\r\n      wrappedErr.statusCode = wrappedStatusCode;\r\n    }\r\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\r\n  }\r\n\r\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\r\n}\r\n\r\nfunction logResult<T>(\r\n  result: ResourceResult<T>,\r\n  method: HttpMethods,\r\n  path: string,\r\n  params: Record<string, string>,\r\n  logger: Logger,\r\n) {\r\n  if (result.err) {\r\n    Logger.logAction(\r\n      logger,\r\n      Logger.LOG_MICRO,\r\n      'Resource.' + method + '()',\r\n      'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + Utils.inspectError(result.err),\r\n    );\r\n  } else {\r\n    Logger.logAction(\r\n      logger,\r\n      Logger.LOG_MICRO,\r\n      'Resource.' + method + '()',\r\n      'Received; ' +\r\n        urlFromPathAndParams(path, params) +\r\n        '; Headers: ' +\r\n        paramString(result.headers as Record<string, any>) +\r\n        '; StatusCode: ' +\r\n        result.statusCode +\r\n        '; Body: ' +\r\n        (Platform.BufferUtils.isBuffer(result.body)\r\n          ? ' (Base64): ' + Platform.BufferUtils.base64Encode(result.body)\r\n          : ': ' + Platform.Config.inspect(result.body)),\r\n    );\r\n  }\r\n}\r\n\r\nexport interface ResourceResponse<T> {\r\n  body?: T;\r\n  headers?: ResponseHeaders;\r\n  unpacked?: boolean;\r\n  statusCode?: number;\r\n}\r\n\r\nexport interface ResourceResult<T> extends ResourceResponse<T> {\r\n  /**\r\n   * Any error returned by the underlying HTTP client.\r\n   */\r\n  err: IPartialErrorInfo | null;\r\n}\r\n\r\nclass Resource {\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Get, client, path, null, headers, params, envelope, throwError ?? false);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Delete, client, path, null, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Post, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Patch, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Put, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  static async do<T>(\r\n    method: HttpMethods,\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    if (envelope) {\r\n      (params = params || {})['envelope'] = envelope;\r\n    }\r\n\r\n    const logger = client.logger;\r\n\r\n    async function doRequest(\r\n      this: any,\r\n      headers: Record<string, string>,\r\n      params: Record<string, any>,\r\n    ): Promise<ResourceResult<T>> {\r\n      if (logger.shouldLog(Logger.LOG_MICRO)) {\r\n        let decodedBody = body;\r\n        if (headers['content-type']?.indexOf('msgpack') > 0) {\r\n          try {\r\n            if (!client._MsgPack) {\r\n              Utils.throwMissingPluginError('MsgPack');\r\n            }\r\n            decodedBody = client._MsgPack.decode(body as Buffer);\r\n          } catch (decodeErr) {\r\n            Logger.logAction(\r\n              logger,\r\n              Logger.LOG_MICRO,\r\n              'Resource.' + method + '()',\r\n              'Sending MsgPack Decoding Error: ' + Utils.inspectError(decodeErr),\r\n            );\r\n          }\r\n        }\r\n        Logger.logAction(\r\n          logger,\r\n          Logger.LOG_MICRO,\r\n          'Resource.' + method + '()',\r\n          'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody,\r\n        );\r\n      }\r\n\r\n      const httpResult = await client.http.do(method, path, headers, body, params);\r\n\r\n      if (httpResult.error && Auth.isTokenErr(httpResult.error as ErrorInfo)) {\r\n        /* token has expired, so get a new one */\r\n        await client.auth.authorize(null, null);\r\n        /* retry ... */\r\n        return withAuthDetails(client, headers, params, doRequest);\r\n      }\r\n\r\n      return {\r\n        err: httpResult.error as ErrorInfo,\r\n        body: httpResult.body as T | undefined,\r\n        headers: httpResult.headers,\r\n        unpacked: httpResult.unpacked,\r\n        statusCode: httpResult.statusCode,\r\n      };\r\n    }\r\n\r\n    let result = await withAuthDetails<T>(client, headers, params, doRequest);\r\n\r\n    if (envelope) {\r\n      result = unenvelope(result, client._MsgPack, envelope);\r\n    }\r\n\r\n    if (logger.shouldLog(Logger.LOG_MICRO)) {\r\n      logResult(result, method, path, params, logger);\r\n    }\r\n\r\n    if (throwError) {\r\n      if (result.err) {\r\n        throw result.err;\r\n      } else {\r\n        const response: Omit<ResourceResult<T>, 'err'> & Pick<Partial<ResourceResult<T>>, 'err'> = { ...result };\r\n        delete response.err;\r\n        return response;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default Resource;\r\n", "import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport Resource, { ResourceResult } from './resource';\r\nimport { IPartialErrorInfo } from '../types/errorinfo';\r\nimport BaseClient from './baseclient';\r\nimport { RequestBody, ResponseHeaders } from 'common/types/http';\r\nimport HttpStatusCodes from '../../constants/HttpStatusCodes';\r\n\r\nexport type BodyHandler = (body: unknown, headers: ResponseHeaders, unpacked?: boolean) => Promise<any>;\r\n\r\nfunction getRelParams(linkUrl: string) {\r\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\r\n  return urlMatch && urlMatch[2] && Utils.parseQueryString(urlMatch[2]);\r\n}\r\n\r\nfunction parseRelLinks(linkHeader: string | Array<string>) {\r\n  if (typeof linkHeader == 'string') linkHeader = linkHeader.split(',');\r\n\r\n  const relParams: Record<string, Record<string, string>> = {};\r\n  for (let i = 0; i < linkHeader.length; i++) {\r\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\r\n    if (linkMatch) {\r\n      const params = getRelParams(linkMatch[1]);\r\n      if (params) relParams[linkMatch[2]] = params;\r\n    }\r\n  }\r\n  return relParams;\r\n}\r\n\r\nfunction returnErrOnly(err: IPartialErrorInfo, body: unknown, useHPR?: boolean) {\r\n  /* If using httpPaginatedResponse, errors from Ably are returned as part of\r\n   * the HPR, only throw `err` for network errors etc. which don't\r\n   * return a body and/or have no ably-originated error code (non-numeric\r\n   * error codes originate from node) */\r\n  return !(useHPR && (body || typeof err.code === 'number'));\r\n}\r\n\r\nclass PaginatedResource {\r\n  client: BaseClient;\r\n  path: string;\r\n  headers: Record<string, string>;\r\n  envelope: Utils.Format | null;\r\n  bodyHandler: BodyHandler;\r\n  useHttpPaginatedResponse: boolean;\r\n\r\n  constructor(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    envelope: Utils.Format | undefined,\r\n    bodyHandler: BodyHandler,\r\n    useHttpPaginatedResponse?: boolean,\r\n  ) {\r\n    this.client = client;\r\n    this.path = path;\r\n    this.headers = headers;\r\n    this.envelope = envelope ?? null;\r\n    this.bodyHandler = bodyHandler;\r\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.client.logger;\r\n  }\r\n\r\n  async get<T1, T2>(params: Record<string, T2>): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.get<T1>(this.client, this.path, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async delete<T1, T2>(params: Record<string, T2>): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.delete<T1>(this.client, this.path, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async post<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.post<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async put<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.put<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async patch<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.patch<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async handlePage<T>(result: ResourceResult<T>): Promise<PaginatedResult<T>> {\r\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'PaginatedResource.handlePage()',\r\n        'Unexpected error getting resource: err = ' + Utils.inspectError(result.err),\r\n      );\r\n      throw result.err;\r\n    }\r\n\r\n    let items, linkHeader, relParams;\r\n\r\n    try {\r\n      items =\r\n        result.statusCode == HttpStatusCodes.NoContent\r\n          ? []\r\n          : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\r\n    } catch (e) {\r\n      /* If we got an error, the failure to parse the body is almost certainly\r\n       * due to that, so throw that in preference over the parse error */\r\n      throw result.err || e;\r\n    }\r\n\r\n    if (result.headers && (linkHeader = result.headers['Link'] || result.headers['link'])) {\r\n      relParams = parseRelLinks(linkHeader);\r\n    }\r\n\r\n    if (this.useHttpPaginatedResponse) {\r\n      return new HttpPaginatedResponse(\r\n        this,\r\n        items,\r\n        result.headers || {},\r\n        result.statusCode as number,\r\n        relParams,\r\n        result.err,\r\n      );\r\n    } else {\r\n      return new PaginatedResult(this, items, relParams);\r\n    }\r\n  }\r\n}\r\n\r\nexport class PaginatedResult<T> {\r\n  resource: PaginatedResource;\r\n  items: T[];\r\n  first?: () => Promise<PaginatedResult<T>>;\r\n  next?: () => Promise<PaginatedResult<T> | null>;\r\n  current?: () => Promise<PaginatedResult<T>>;\r\n  hasNext?: () => boolean;\r\n  isLast?: () => boolean;\r\n\r\n  constructor(resource: PaginatedResource, items: T[], relParams?: Record<string, any>) {\r\n    this.resource = resource;\r\n    this.items = items;\r\n\r\n    const self = this;\r\n    if (relParams) {\r\n      if ('first' in relParams) {\r\n        this.first = async function () {\r\n          return self.get(relParams.first);\r\n        };\r\n      }\r\n      if ('current' in relParams) {\r\n        this.current = async function () {\r\n          return self.get(relParams.current);\r\n        };\r\n      }\r\n      this.next = async function () {\r\n        if ('next' in relParams) {\r\n          return self.get(relParams.next);\r\n        } else {\r\n          return null;\r\n        }\r\n      };\r\n\r\n      this.hasNext = function () {\r\n        return 'next' in relParams;\r\n      };\r\n      this.isLast = () => {\r\n        return !this.hasNext?.();\r\n      };\r\n    }\r\n  }\r\n\r\n  /* We assume that only the initial request can be a POST, and that accessing\r\n   * the rest of a multipage set of results can always be done with GET */\r\n  async get(params: any): Promise<PaginatedResult<T>> {\r\n    const res = this.resource;\r\n    const result = await Resource.get<T>(res.client, res.path, res.headers, params, res.envelope, false);\r\n    return res.handlePage(result);\r\n  }\r\n}\r\n\r\nexport class HttpPaginatedResponse<T> extends PaginatedResult<T> {\r\n  statusCode: number;\r\n  success: boolean;\r\n  headers: ResponseHeaders;\r\n  errorCode?: number | null;\r\n  errorMessage?: string | null;\r\n\r\n  constructor(\r\n    resource: PaginatedResource,\r\n    items: T[],\r\n    headers: ResponseHeaders,\r\n    statusCode: number,\r\n    relParams: any,\r\n    err: IPartialErrorInfo | null,\r\n  ) {\r\n    super(resource, items, relParams);\r\n    this.statusCode = statusCode;\r\n    this.success = statusCode < 300 && statusCode >= 200;\r\n    this.headers = headers;\r\n    this.errorCode = err && err.code;\r\n    this.errorMessage = err && err.message;\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      items: this.items,\r\n      statusCode: this.statusCode,\r\n      success: this.success,\r\n      headers: this.headers,\r\n      errorCode: this.errorCode,\r\n      errorMessage: this.errorMessage,\r\n    };\r\n  }\r\n}\r\n\r\nexport default PaginatedResource;\r\n", "import { MsgPack } from 'common/types/msgpack';\r\nimport * as Utils from '../util/utils';\r\n\r\ntype PushChannelSubscriptionObject = {\r\n  channel?: string;\r\n  deviceId?: string;\r\n  clientId?: string;\r\n};\r\n\r\nclass PushChannelSubscription {\r\n  channel?: string;\r\n  deviceId?: string;\r\n  clientId?: string;\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON(): PushChannelSubscriptionObject {\r\n    return {\r\n      channel: this.channel,\r\n      deviceId: this.deviceId,\r\n      clientId: this.clientId,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[PushChannelSubscription';\r\n    if (this.channel) result += '; channel=' + this.channel;\r\n    if (this.deviceId) result += '; deviceId=' + this.deviceId;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    result += ']';\r\n    return result;\r\n  }\r\n\r\n  static toRequestBody = Utils.encodeBody;\r\n\r\n  static fromResponseBody(\r\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\r\n    MsgPack: MsgPack | null,\r\n    format?: Utils.Format,\r\n  ): PushChannelSubscription | PushChannelSubscription[] {\r\n    if (format) {\r\n      body = Utils.decodeBody(body, MsgPack, format) as Record<string, unknown>;\r\n    }\r\n\r\n    if (Array.isArray(body)) {\r\n      return PushChannelSubscription.fromValuesArray(body);\r\n    } else {\r\n      return PushChannelSubscription.fromValues(body);\r\n    }\r\n  }\r\n\r\n  static fromValues(values: Record<string, unknown>): PushChannelSubscription {\r\n    return Object.assign(new PushChannelSubscription(), values);\r\n  }\r\n\r\n  static fromValuesArray(values: Array<Record<string, unknown>>): PushChannelSubscription[] {\r\n    const count = values.length,\r\n      result = new Array(count);\r\n    for (let i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PushChannelSubscription;\r\n", "import * as Utils from '../util/utils';\r\nimport DeviceDetails from '../types/devicedetails';\r\nimport Resource from './resource';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport PushChannelSubscription from '../types/pushchannelsubscription';\r\nimport BaseClient from './baseclient';\r\nimport Defaults from '../util/defaults';\r\n\r\nclass Push {\r\n  client: BaseClient;\r\n  admin: Admin;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.admin = new Admin(client);\r\n  }\r\n}\r\n\r\nclass Admin {\r\n  client: BaseClient;\r\n  deviceRegistrations: DeviceRegistrations;\r\n  channelSubscriptions: ChannelSubscriptions;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.deviceRegistrations = new DeviceRegistrations(client);\r\n    this.channelSubscriptions = new ChannelSubscriptions(client);\r\n  }\r\n\r\n  async publish(recipient: any, payload: any): Promise<void> {\r\n    const client = this.client;\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n    const body = Utils.mixin({ recipient: recipient }, payload);\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    await Resource.post(client, '/push/publish', requestBody, headers, params, null, true);\r\n  }\r\n}\r\n\r\nclass DeviceRegistrations {\r\n  client: BaseClient;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n  }\r\n\r\n  async save(device: any): Promise<DeviceDetails> {\r\n    const client = this.client;\r\n    const body = DeviceDetails.fromValues(device);\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    const response = await Resource.put(\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(device.id),\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return DeviceDetails.fromResponseBody(\r\n      response.body as Record<string, unknown>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as DeviceDetails;\r\n  }\r\n\r\n  async get(deviceIdOrDetails: any): Promise<DeviceDetails> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format }),\r\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\r\n\r\n    if (typeof deviceId !== 'string' || !deviceId.length) {\r\n      throw new ErrorInfo(\r\n        'First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails',\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const response = await Resource.get(\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\r\n      headers,\r\n      {},\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return DeviceDetails.fromResponseBody(\r\n      response.body as Record<string, unknown>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as DeviceDetails;\r\n  }\r\n\r\n  async list(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    return new PaginatedResource(client, '/push/deviceRegistrations', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return DeviceDetails.fromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n\r\n  async remove(deviceIdOrDetails: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format }),\r\n      params = {},\r\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\r\n\r\n    if (typeof deviceId !== 'string' || !deviceId.length) {\r\n      throw new ErrorInfo(\r\n        'First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails',\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n  }\r\n\r\n  async removeWhere(params: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](client, '/push/deviceRegistrations', headers, params, null, true);\r\n  }\r\n}\r\n\r\nclass ChannelSubscriptions {\r\n  client: BaseClient;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n  }\r\n\r\n  async save(subscription: Record<string, unknown>): Promise<PushChannelSubscription> {\r\n    const client = this.client;\r\n    const body = PushChannelSubscription.fromValues(subscription);\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    const response = await Resource.post(\r\n      client,\r\n      '/push/channelSubscriptions',\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return PushChannelSubscription.fromResponseBody(\r\n      response.body as Record<string, any>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as PushChannelSubscription;\r\n  }\r\n\r\n  async list(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    return new PaginatedResource(client, '/push/channelSubscriptions', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return PushChannelSubscription.fromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n\r\n  async removeWhere(params: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](client, '/push/channelSubscriptions', headers, params, null, true);\r\n  }\r\n\r\n  /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\r\n  remove = ChannelSubscriptions.prototype.removeWhere;\r\n\r\n  async listChannels(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    return new PaginatedResource(client, '/push/channels', headers, envelope, async function (body, headers, unpacked) {\r\n      const parsedBody = (\r\n        !unpacked && format ? Utils.decodeBody(body, client._MsgPack, format) : body\r\n      ) as Array<string>;\r\n\r\n      for (let i = 0; i < parsedBody.length; i++) {\r\n        parsedBody[i] = String(parsedBody[i]);\r\n      }\r\n      return parsedBody;\r\n    }).get(params);\r\n  }\r\n}\r\n\r\nexport default Push;\r\n", "import Platform from 'common/platform';\r\nimport Logger from '../util/logger';\r\nimport ErrorInfo from './errorinfo';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport PresenceMessage from './presencemessage';\r\nimport * as Utils from '../util/utils';\r\nimport { Bufferlike as BrowserBufferlike } from '../../../platform/web/lib/util/bufferutils';\r\nimport * as API from '../../../../ably';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { MsgPack } from 'common/types/msgpack';\r\n\r\nexport type CipherOptions = {\r\n  channelCipher: {\r\n    encrypt: Function;\r\n    algorithm: 'aes';\r\n  };\r\n  cipher?: {\r\n    channelCipher: {\r\n      encrypt: Function;\r\n      algorithm: 'aes';\r\n    };\r\n  };\r\n};\r\n\r\nexport type EncodingDecodingContext = {\r\n  channelOptions: ChannelOptions;\r\n  plugins: {\r\n    vcdiff?: {\r\n      decode: (delta: Uint8Array, source: Uint8Array) => Uint8Array;\r\n    };\r\n  };\r\n  baseEncodedPreviousPayload?: Buffer | BrowserBufferlike;\r\n};\r\n\r\nfunction normaliseContext(context: CipherOptions | EncodingDecodingContext | ChannelOptions): EncodingDecodingContext {\r\n  if (!context || !(context as EncodingDecodingContext).channelOptions) {\r\n    return {\r\n      channelOptions: context as ChannelOptions,\r\n      plugins: {},\r\n      baseEncodedPreviousPayload: undefined,\r\n    };\r\n  }\r\n  return context as EncodingDecodingContext;\r\n}\r\n\r\nfunction normalizeCipherOptions(\r\n  Crypto: IUntypedCryptoStatic | null,\r\n  logger: Logger,\r\n  options: API.ChannelOptions | null,\r\n): ChannelOptions {\r\n  if (options && options.cipher) {\r\n    if (!Crypto) Utils.throwMissingPluginError('Crypto');\r\n    const cipher = Crypto.getCipher(options.cipher, logger);\r\n    return {\r\n      cipher: cipher.cipherParams,\r\n      channelCipher: cipher.cipher,\r\n    };\r\n  }\r\n  return options ?? {};\r\n}\r\n\r\nfunction getMessageSize(msg: Message) {\r\n  let size = 0;\r\n  if (msg.name) {\r\n    size += msg.name.length;\r\n  }\r\n  if (msg.clientId) {\r\n    size += msg.clientId.length;\r\n  }\r\n  if (msg.extras) {\r\n    size += JSON.stringify(msg.extras).length;\r\n  }\r\n  if (msg.data) {\r\n    size += Utils.dataSizeBytes(msg.data);\r\n  }\r\n  return size;\r\n}\r\n\r\nexport async function fromEncoded(\r\n  logger: Logger,\r\n  Crypto: IUntypedCryptoStatic | null,\r\n  encoded: unknown,\r\n  inputOptions?: API.ChannelOptions,\r\n): Promise<Message> {\r\n  const msg = fromValues(encoded);\r\n  const options = normalizeCipherOptions(Crypto, logger, inputOptions ?? null);\r\n  /* if decoding fails at any point, catch and return the message decoded to\r\n   * the fullest extent possible */\r\n  try {\r\n    await decode(msg, options);\r\n  } catch (e) {\r\n    Logger.logAction(logger, Logger.LOG_ERROR, 'Message.fromEncoded()', (e as Error).toString());\r\n  }\r\n  return msg;\r\n}\r\n\r\nexport async function fromEncodedArray(\r\n  logger: Logger,\r\n  Crypto: IUntypedCryptoStatic | null,\r\n  encodedArray: Array<unknown>,\r\n  options?: API.ChannelOptions,\r\n): Promise<Message[]> {\r\n  return Promise.all(\r\n    encodedArray.map(function (encoded) {\r\n      return fromEncoded(logger, Crypto, encoded, options);\r\n    }),\r\n  );\r\n}\r\n\r\nasync function encrypt<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\r\n  let data = msg.data,\r\n    encoding = msg.encoding,\r\n    cipher = options.channelCipher;\r\n\r\n  encoding = encoding ? encoding + '/' : '';\r\n  if (!Platform.BufferUtils.isBuffer(data)) {\r\n    data = Platform.BufferUtils.utf8Encode(String(data));\r\n    encoding = encoding + 'utf-8/';\r\n  }\r\n  const ciphertext = await cipher.encrypt(data);\r\n  msg.data = ciphertext;\r\n  msg.encoding = encoding + 'cipher+' + cipher.algorithm;\r\n  return msg;\r\n}\r\n\r\nexport async function encode<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\r\n  const data = msg.data;\r\n  const nativeDataType =\r\n    typeof data == 'string' || Platform.BufferUtils.isBuffer(data) || data === null || data === undefined;\r\n\r\n  if (!nativeDataType) {\r\n    if (Utils.isObject(data) || Array.isArray(data)) {\r\n      msg.data = JSON.stringify(data);\r\n      msg.encoding = msg.encoding ? msg.encoding + '/json' : 'json';\r\n    } else {\r\n      throw new ErrorInfo('Data type is unsupported', 40013, 400);\r\n    }\r\n  }\r\n\r\n  if (options != null && options.cipher) {\r\n    return encrypt(msg, options);\r\n  } else {\r\n    return msg;\r\n  }\r\n}\r\n\r\nexport async function encodeArray(messages: Array<Message>, options: CipherOptions): Promise<Array<Message>> {\r\n  return Promise.all(messages.map((message) => encode(message, options)));\r\n}\r\n\r\nexport const serialize = Utils.encodeBody;\r\n\r\nexport async function decode(\r\n  message: Message | PresenceMessage,\r\n  inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\r\n): Promise<void> {\r\n  const context = normaliseContext(inputContext);\r\n\r\n  let lastPayload = message.data;\r\n  const encoding = message.encoding;\r\n  if (encoding) {\r\n    const xforms = encoding.split('/');\r\n    let lastProcessedEncodingIndex,\r\n      encodingsToProcess = xforms.length,\r\n      data = message.data;\r\n\r\n    let xform = '';\r\n    try {\r\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\r\n        // eslint-disable-next-line security/detect-unsafe-regex\r\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\r\n        if (!match) break;\r\n        xform = match[1];\r\n        switch (xform) {\r\n          case 'base64':\r\n            data = Platform.BufferUtils.base64Decode(String(data));\r\n            if (lastProcessedEncodingIndex == xforms.length) {\r\n              lastPayload = data;\r\n            }\r\n            continue;\r\n          case 'utf-8':\r\n            data = Platform.BufferUtils.utf8Decode(data);\r\n            continue;\r\n          case 'json':\r\n            data = JSON.parse(data);\r\n            continue;\r\n          case 'cipher':\r\n            if (\r\n              context.channelOptions != null &&\r\n              context.channelOptions.cipher &&\r\n              context.channelOptions.channelCipher\r\n            ) {\r\n              const xformAlgorithm = match[3],\r\n                cipher = context.channelOptions.channelCipher;\r\n              /* don't attempt to decrypt unless the cipher params are compatible */\r\n              if (xformAlgorithm != cipher.algorithm) {\r\n                throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');\r\n              }\r\n              data = await cipher.decrypt(data);\r\n              continue;\r\n            } else {\r\n              throw new Error('Unable to decrypt message; not an encrypted channel');\r\n            }\r\n          case 'vcdiff':\r\n            if (!context.plugins || !context.plugins.vcdiff) {\r\n              throw new ErrorInfo('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);\r\n            }\r\n            if (typeof Uint8Array === 'undefined') {\r\n              throw new ErrorInfo(\r\n                'Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)',\r\n                40020,\r\n                400,\r\n              );\r\n            }\r\n            try {\r\n              let deltaBase = context.baseEncodedPreviousPayload;\r\n              if (typeof deltaBase === 'string') {\r\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\r\n              }\r\n\r\n              // vcdiff expects Uint8Arrays, can't copy with ArrayBuffers.\r\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase as Buffer);\r\n              data = Platform.BufferUtils.toBuffer(data);\r\n\r\n              data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBaseBuffer));\r\n              lastPayload = data;\r\n            } catch (e) {\r\n              throw new ErrorInfo('Vcdiff delta decode failed with ' + e, 40018, 400);\r\n            }\r\n            continue;\r\n          default:\r\n            throw new Error('Unknown encoding');\r\n        }\r\n      }\r\n    } catch (e) {\r\n      const err = e as ErrorInfo;\r\n      throw new ErrorInfo(\r\n        'Error processing the ' + xform + ' encoding, decoder returned \u2018' + err.message + '\u2019',\r\n        err.code || 40013,\r\n        400,\r\n      );\r\n    } finally {\r\n      message.encoding =\r\n        (lastProcessedEncodingIndex as number) <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');\r\n      message.data = data;\r\n    }\r\n  }\r\n  context.baseEncodedPreviousPayload = lastPayload;\r\n}\r\n\r\nexport async function fromResponseBody(\r\n  body: Array<Message>,\r\n  options: ChannelOptions | EncodingDecodingContext,\r\n  logger: Logger,\r\n  MsgPack: MsgPack | null,\r\n  format?: Utils.Format,\r\n): Promise<Message[]> {\r\n  if (format) {\r\n    body = Utils.decodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  for (let i = 0; i < body.length; i++) {\r\n    const msg = (body[i] = fromValues(body[i]));\r\n    try {\r\n      await decode(msg, options);\r\n    } catch (e) {\r\n      Logger.logAction(logger, Logger.LOG_ERROR, 'Message.fromResponseBody()', (e as Error).toString());\r\n    }\r\n  }\r\n  return body;\r\n}\r\n\r\nexport function fromValues(values: unknown): Message {\r\n  return Object.assign(new Message(), values);\r\n}\r\n\r\nexport function fromValuesArray(values: unknown[]): Message[] {\r\n  const count = values.length,\r\n    result = new Array(count);\r\n  for (let i = 0; i < count; i++) result[i] = fromValues(values[i]);\r\n  return result;\r\n}\r\n\r\n/* This should be called on encode()d (and encrypt()d) Messages (as it\r\n * assumes the data is a string or buffer) */\r\nexport function getMessagesSize(messages: Message[]): number {\r\n  let msg,\r\n    total = 0;\r\n  for (let i = 0; i < messages.length; i++) {\r\n    msg = messages[i];\r\n    total += msg.size || (msg.size = getMessageSize(msg));\r\n  }\r\n  return total;\r\n}\r\n\r\nclass Message {\r\n  name?: string;\r\n  id?: string;\r\n  timestamp?: number;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n  connectionKey?: string;\r\n  data?: any;\r\n  encoding?: string | null;\r\n  extras?: any;\r\n  size?: number;\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON() {\r\n    /* encode data to base64 if present and we're returning real JSON;\r\n     * although msgpack calls toJSON(), we know it is a stringify()\r\n     * call if it has a non-empty arguments list */\r\n    let encoding = this.encoding;\r\n    let data = this.data;\r\n    if (data && Platform.BufferUtils.isBuffer(data)) {\r\n      if (arguments.length > 0) {\r\n        /* stringify call */\r\n        encoding = encoding ? encoding + '/base64' : 'base64';\r\n        data = Platform.BufferUtils.base64Encode(data);\r\n      } else {\r\n        /* Called by msgpack. toBuffer returns a datatype understandable by\r\n         * that platform's msgpack implementation (Buffer in node, Uint8Array\r\n         * in browsers) */\r\n        data = Platform.BufferUtils.toBuffer(data);\r\n      }\r\n    }\r\n    return {\r\n      name: this.name,\r\n      id: this.id,\r\n      clientId: this.clientId,\r\n      connectionId: this.connectionId,\r\n      connectionKey: this.connectionKey,\r\n      extras: this.extras,\r\n      encoding,\r\n      data,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[Message';\r\n    if (this.name) result += '; name=' + this.name;\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\r\n    if (this.encoding) result += '; encoding=' + this.encoding;\r\n    if (this.extras) result += '; extras =' + JSON.stringify(this.extras);\r\n    if (this.data) {\r\n      if (typeof this.data == 'string') result += '; data=' + this.data;\r\n      else if (Platform.BufferUtils.isBuffer(this.data))\r\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(this.data);\r\n      else result += '; data (json)=' + JSON.stringify(this.data);\r\n    }\r\n    if (this.extras) result += '; extras=' + JSON.stringify(this.extras);\r\n    result += ']';\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default Message;\r\n", "import Logger from '../util/logger';\r\nimport Platform from 'common/platform';\r\nimport { encode as encodeMessage, decode as decodeMessage, getMessagesSize, CipherOptions } from './message';\r\nimport * as Utils from '../util/utils';\r\nimport * as API from '../../../../ably';\r\nimport { MsgPack } from 'common/types/msgpack';\r\n\r\nconst actions = ['absent', 'present', 'enter', 'leave', 'update'];\r\n\r\nfunction toActionValue(actionString: string) {\r\n  return actions.indexOf(actionString);\r\n}\r\n\r\nexport async function fromEncoded(\r\n  logger: Logger,\r\n  encoded: unknown,\r\n  options?: API.ChannelOptions,\r\n): Promise<PresenceMessage> {\r\n  const msg = fromValues(encoded as PresenceMessage | Record<string, unknown>, true);\r\n  /* if decoding fails at any point, catch and return the message decoded to\r\n   * the fullest extent possible */\r\n  try {\r\n    await decode(msg, options ?? {});\r\n  } catch (e) {\r\n    Logger.logAction(logger, Logger.LOG_ERROR, 'PresenceMessage.fromEncoded()', (e as Error).toString());\r\n  }\r\n  return msg;\r\n}\r\n\r\nexport async function fromEncodedArray(\r\n  logger: Logger,\r\n  encodedArray: unknown[],\r\n  options?: API.ChannelOptions,\r\n): Promise<PresenceMessage[]> {\r\n  return Promise.all(\r\n    encodedArray.map(function (encoded) {\r\n      return fromEncoded(logger, encoded, options);\r\n    }),\r\n  );\r\n}\r\n\r\nexport function fromValues(\r\n  values: PresenceMessage | Record<string, unknown>,\r\n  stringifyAction?: boolean,\r\n): PresenceMessage {\r\n  if (stringifyAction) {\r\n    values.action = actions[values.action as number];\r\n  }\r\n  return Object.assign(new PresenceMessage(), values);\r\n}\r\n\r\nexport { encodeMessage as encode };\r\nexport const decode = decodeMessage;\r\n\r\nexport async function fromResponseBody(\r\n  body: Record<string, unknown>[],\r\n  options: CipherOptions,\r\n  logger: Logger,\r\n  MsgPack: MsgPack | null,\r\n  format?: Utils.Format,\r\n): Promise<PresenceMessage[]> {\r\n  const messages: PresenceMessage[] = [];\r\n  if (format) {\r\n    body = Utils.decodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  for (let i = 0; i < body.length; i++) {\r\n    const msg = (messages[i] = fromValues(body[i], true));\r\n    try {\r\n      await decode(msg, options);\r\n    } catch (e) {\r\n      Logger.logAction(logger, Logger.LOG_ERROR, 'PresenceMessage.fromResponseBody()', (e as Error).toString());\r\n    }\r\n  }\r\n  return messages;\r\n}\r\n\r\nexport function fromValuesArray(values: unknown[]): PresenceMessage[] {\r\n  const count = values.length,\r\n    result = new Array(count);\r\n  for (let i = 0; i < count; i++) result[i] = fromValues(values[i] as Record<string, unknown>);\r\n  return result;\r\n}\r\n\r\nexport function fromData(data: unknown): PresenceMessage {\r\n  if (data instanceof PresenceMessage) {\r\n    return data;\r\n  }\r\n  return fromValues({\r\n    data,\r\n  });\r\n}\r\n\r\nexport { getMessagesSize };\r\n\r\nclass PresenceMessage {\r\n  action?: string | number;\r\n  id?: string;\r\n  timestamp?: number;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n  data?: string | Buffer | Uint8Array;\r\n  encoding?: string;\r\n  extras?: any;\r\n  size?: number;\r\n\r\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\r\n   * sent by the connection (usually means a leave event sent 15s after a\r\n   * disconnection). This is useful because synthesized messages cannot be\r\n   * compared for newness by id lexicographically - RTP2b1\r\n   */\r\n  isSynthesized(): boolean {\r\n    if (!this.id || !this.connectionId) {\r\n      return true;\r\n    }\r\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\r\n  }\r\n\r\n  /* RTP2b2 */\r\n  parseId(): { connectionId: string; msgSerial: number; index: number } {\r\n    if (!this.id) throw new Error('parseId(): Presence message does not contain an id');\r\n    const parts = this.id.split(':');\r\n    return {\r\n      connectionId: parts[0],\r\n      msgSerial: parseInt(parts[1], 10),\r\n      index: parseInt(parts[2], 10),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON(): {\r\n    id?: string;\r\n    clientId?: string;\r\n    action: number;\r\n    data: string | Buffer | Uint8Array;\r\n    encoding?: string;\r\n    extras?: any;\r\n  } {\r\n    /* encode data to base64 if present and we're returning real JSON;\r\n     * although msgpack calls toJSON(), we know it is a stringify()\r\n     * call if it has a non-empty arguments list */\r\n    let data = this.data as string | Buffer | Uint8Array;\r\n    let encoding = this.encoding;\r\n    if (data && Platform.BufferUtils.isBuffer(data)) {\r\n      if (arguments.length > 0) {\r\n        /* stringify call */\r\n        encoding = encoding ? encoding + '/base64' : 'base64';\r\n        data = Platform.BufferUtils.base64Encode(data);\r\n      } else {\r\n        /* Called by msgpack. toBuffer returns a datatype understandable by\r\n         * that platform's msgpack implementation (Buffer in node, Uint8Array\r\n         * in browsers) */\r\n        data = Platform.BufferUtils.toBuffer(data);\r\n      }\r\n    }\r\n    return {\r\n      id: this.id,\r\n      clientId: this.clientId,\r\n      /* Convert presence action back to an int for sending to Ably */\r\n      action: toActionValue(this.action as string),\r\n      data: data,\r\n      encoding: encoding,\r\n      extras: this.extras,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[PresenceMessage';\r\n    result += '; action=' + this.action;\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\r\n    if (this.encoding) result += '; encoding=' + this.encoding;\r\n    if (this.data) {\r\n      if (typeof this.data == 'string') result += '; data=' + this.data;\r\n      else if (Platform.BufferUtils.isBuffer(this.data))\r\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(this.data);\r\n      else result += '; data (json)=' + JSON.stringify(this.data);\r\n    }\r\n    if (this.extras) {\r\n      result += '; extras=' + JSON.stringify(this.extras);\r\n    }\r\n    result += ']';\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PresenceMessage;\r\n", "import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport PresenceMessage, { fromResponseBody as presenceMessageFromResponseBody } from '../types/presencemessage';\r\nimport { CipherOptions } from '../types/message';\r\nimport RestChannel from './restchannel';\r\nimport Defaults from '../util/defaults';\r\n\r\nclass RestPresence {\r\n  channel: RestChannel;\r\n\r\n  constructor(channel: RestChannel) {\r\n    this.channel = channel;\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.channel.logger;\r\n  }\r\n\r\n  async get(params: any): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RestPresence.get()', 'channel = ' + this.channel.name);\r\n    const client = this.channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = this.channel.channelOptions;\r\n    return new PaginatedResource(\r\n      client,\r\n      this.channel.client.rest.presenceMixin.basePath(this),\r\n      headers,\r\n      envelope,\r\n      async (body, headers, unpacked) => {\r\n        return await presenceMessageFromResponseBody(\r\n          body as Record<string, unknown>[],\r\n          options as CipherOptions,\r\n          this.logger,\r\n          client._MsgPack,\r\n          unpacked ? undefined : format,\r\n        );\r\n      },\r\n    ).get(params);\r\n  }\r\n\r\n  async history(params: any): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RestPresence.history()', 'channel = ' + this.channel.name);\r\n    return this.channel.client.rest.presenceMixin.history(this, params);\r\n  }\r\n}\r\n\r\nexport default RestPresence;\r\n", "import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport RestPresence from './restpresence';\r\nimport Message, {\r\n  fromValues as messageFromValues,\r\n  fromValuesArray as messagesFromValuesArray,\r\n  encodeArray as encodeMessagesArray,\r\n  serialize as serializeMessage,\r\n  getMessagesSize,\r\n  CipherOptions,\r\n} from '../types/message';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport { PaginatedResult } from './paginatedresource';\r\nimport Resource from './resource';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport BaseRest from './baseclient';\r\nimport * as API from '../../../../ably';\r\nimport Defaults, { normaliseChannelOptions } from '../util/defaults';\r\nimport { RestHistoryParams } from './restchannelmixin';\r\nimport { RequestBody } from 'common/types/http';\r\n\r\nconst MSG_ID_ENTROPY_BYTES = 9;\r\n\r\nfunction allEmptyIds(messages: Array<Message>) {\r\n  return messages.every(function (message: Message) {\r\n    return !message.id;\r\n  });\r\n}\r\n\r\nclass RestChannel {\r\n  client: BaseRest;\r\n  name: string;\r\n  presence: RestPresence;\r\n  channelOptions: ChannelOptions;\r\n\r\n  constructor(client: BaseRest, name: string, channelOptions?: ChannelOptions) {\r\n    Logger.logAction(client.logger, Logger.LOG_MINOR, 'RestChannel()', 'started; name = ' + name);\r\n    this.name = name;\r\n    this.client = client;\r\n    this.presence = new RestPresence(this);\r\n    this.channelOptions = normaliseChannelOptions(client._Crypto ?? null, this.logger, channelOptions);\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.client.logger;\r\n  }\r\n\r\n  setOptions(options?: ChannelOptions): void {\r\n    this.channelOptions = normaliseChannelOptions(this.client._Crypto ?? null, this.logger, options);\r\n  }\r\n\r\n  async history(params: RestHistoryParams | null): Promise<PaginatedResult<Message>> {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RestChannel.history()', 'channel = ' + this.name);\r\n    return this.client.rest.channelMixin.history(this, params);\r\n  }\r\n\r\n  async publish(...args: any[]): Promise<void> {\r\n    const first = args[0],\r\n      second = args[1];\r\n    let messages: Array<Message>;\r\n    let params: any;\r\n\r\n    if (typeof first === 'string' || first === null) {\r\n      /* (name, data, ...) */\r\n      messages = [messageFromValues({ name: first, data: second })];\r\n      params = args[2];\r\n    } else if (Utils.isObject(first)) {\r\n      messages = [messageFromValues(first)];\r\n      params = args[1];\r\n    } else if (Array.isArray(first)) {\r\n      messages = messagesFromValuesArray(first);\r\n      params = args[1];\r\n    } else {\r\n      throw new ErrorInfo(\r\n        'The single-argument form of publish() expects a message object or an array of message objects',\r\n        40013,\r\n        400,\r\n      );\r\n    }\r\n\r\n    if (!params) {\r\n      /* No params supplied */\r\n      params = {};\r\n    }\r\n\r\n    const client = this.client,\r\n      options = client.options,\r\n      format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      idempotentRestPublishing = client.options.idempotentRestPublishing,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, options.headers);\r\n\r\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\r\n      const msgIdBase = await Utils.randomString(MSG_ID_ENTROPY_BYTES);\r\n      messages.forEach(function (message, index) {\r\n        message.id = msgIdBase + ':' + index.toString();\r\n      });\r\n    }\r\n\r\n    await encodeMessagesArray(messages, this.channelOptions as CipherOptions);\r\n\r\n    /* RSL1i */\r\n    const size = getMessagesSize(messages),\r\n      maxMessageSize = options.maxMessageSize;\r\n    if (size > maxMessageSize) {\r\n      throw new ErrorInfo(\r\n        'Maximum size of messages that can be published at once exceeded ( was ' +\r\n          size +\r\n          ' bytes; limit is ' +\r\n          maxMessageSize +\r\n          ' bytes)',\r\n        40009,\r\n        400,\r\n      );\r\n    }\r\n\r\n    await this._publish(serializeMessage(messages, client._MsgPack, format), headers, params);\r\n  }\r\n\r\n  async _publish(requestBody: RequestBody | null, headers: Record<string, string>, params: any): Promise<void> {\r\n    await Resource.post(\r\n      this.client,\r\n      this.client.rest.channelMixin.basePath(this) + '/messages',\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n  }\r\n\r\n  async status(): Promise<API.ChannelDetails> {\r\n    return this.client.rest.channelMixin.status(this);\r\n  }\r\n}\r\n\r\nexport default RestChannel;\r\n", "type StatsValues = {\r\n  entries?: Partial<Record<string, number>>;\r\n  schema?: string;\r\n  appId?: string;\r\n  inProgress?: never;\r\n  unit?: never;\r\n  intervalId?: never;\r\n};\r\n\r\nclass Stats {\r\n  entries?: Partial<Record<string, number>>;\r\n  schema?: string;\r\n  appId?: string;\r\n  inProgress?: never;\r\n  unit?: never;\r\n  intervalId?: never;\r\n\r\n  constructor(values?: StatsValues) {\r\n    this.entries = (values && values.entries) || undefined;\r\n    this.schema = (values && values.schema) || undefined;\r\n    this.appId = (values && values.appId) || undefined;\r\n    this.inProgress = (values && values.inProgress) || undefined;\r\n    this.unit = (values && values.unit) || undefined;\r\n    this.intervalId = (values && values.intervalId) || undefined;\r\n  }\r\n\r\n  static fromValues(values: StatsValues): Stats {\r\n    return new Stats(values);\r\n  }\r\n}\r\n\r\nexport default Stats;\r\n", "import * as API from '../../../../ably';\r\nimport RestChannel from './restchannel';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport * as Utils from '../util/utils';\r\nimport Message, { fromResponseBody as messageFromResponseBody } from '../types/message';\r\nimport Defaults from '../util/defaults';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport Resource from './resource';\r\n\r\nexport interface RestHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n}\r\n\r\nexport class RestChannelMixin {\r\n  static basePath(channel: RestChannel | RealtimeChannel) {\r\n    return '/channels/' + encodeURIComponent(channel.name);\r\n  }\r\n\r\n  static history(\r\n    channel: RestChannel | RealtimeChannel,\r\n    params: RestHistoryParams | null,\r\n  ): Promise<PaginatedResult<Message>> {\r\n    const client = channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = channel.channelOptions;\r\n    return new PaginatedResource(client, this.basePath(channel) + '/messages', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return await messageFromResponseBody(\r\n        body as Message[],\r\n        options,\r\n        channel.logger,\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params as Record<string, unknown>);\r\n  }\r\n\r\n  static async status(channel: RestChannel | RealtimeChannel): Promise<API.ChannelDetails> {\r\n    const format = channel.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\r\n    const headers = Defaults.defaultPostHeaders(channel.client.options, { format });\r\n\r\n    const response = await Resource.get<API.ChannelDetails>(\r\n      channel.client,\r\n      this.basePath(channel),\r\n      headers,\r\n      {},\r\n      format,\r\n      true,\r\n    );\r\n\r\n    return response.body!;\r\n  }\r\n}\r\n", "import RestPresence from './restpresence';\r\nimport RealtimePresence from './realtimepresence';\r\nimport * as Utils from '../util/utils';\r\nimport Defaults from '../util/defaults';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport PresenceMessage, { fromResponseBody as presenceMessageFromResponseBody } from '../types/presencemessage';\r\nimport { CipherOptions } from '../types/message';\r\nimport { RestChannelMixin } from './restchannelmixin';\r\n\r\nexport class RestPresenceMixin {\r\n  static basePath(presence: RestPresence | RealtimePresence) {\r\n    return RestChannelMixin.basePath(presence.channel) + '/presence';\r\n  }\r\n\r\n  static async history(\r\n    presence: RestPresence | RealtimePresence,\r\n    params: any,\r\n  ): Promise<PaginatedResult<PresenceMessage>> {\r\n    const client = presence.channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = presence.channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = presence.channel.channelOptions;\r\n    return new PaginatedResource(client, this.basePath(presence) + '/history', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return await presenceMessageFromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        options as CipherOptions,\r\n        presence.logger,\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n}\r\n", "import * as Utils from '../util/utils';\r\nimport Defaults from '../util/defaults';\r\nimport Push from './push';\r\nimport PaginatedResource, { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\r\nimport RestChannel from './restchannel';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Stats from '../types/stats';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport { RequestBody, RequestParams } from '../../types/http';\r\nimport * as API from '../../../../ably';\r\nimport Resource from './resource';\r\n\r\nimport Platform from '../../platform';\r\nimport BaseClient from './baseclient';\r\nimport { useTokenAuth } from './auth';\r\nimport { RestChannelMixin } from './restchannelmixin';\r\nimport { RestPresenceMixin } from './restpresencemixin';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\n\r\ntype BatchPublishSpec = API.BatchPublishSpec;\r\ntype BatchPublishSuccessResult = API.BatchPublishSuccessResult;\r\ntype BatchPublishFailureResult = API.BatchPublishFailureResult;\r\ntype BatchPublishResult = BatchResult<BatchPublishSuccessResult | BatchPublishFailureResult>;\r\ntype BatchPresenceSuccessResult = API.BatchPresenceSuccessResult;\r\ntype BatchPresenceFailureResult = API.BatchPresenceFailureResult;\r\ntype BatchPresenceResult = BatchResult<BatchPresenceSuccessResult | BatchPresenceFailureResult>;\r\n\r\ntype TokenRevocationTargetSpecifier = API.TokenRevocationTargetSpecifier;\r\ntype TokenRevocationOptions = API.TokenRevocationOptions;\r\ntype TokenRevocationSuccessResult = API.TokenRevocationSuccessResult;\r\ntype TokenRevocationFailureResult = API.TokenRevocationFailureResult;\r\ntype TokenRevocationResult = BatchResult<TokenRevocationSuccessResult | TokenRevocationFailureResult>;\r\n\r\nexport class Rest {\r\n  private readonly client: BaseClient;\r\n  readonly channels: Channels;\r\n  readonly push: Push;\r\n\r\n  readonly channelMixin = RestChannelMixin;\r\n  readonly presenceMixin = RestPresenceMixin;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.channels = new Channels(this.client);\r\n    this.push = new Push(this.client);\r\n  }\r\n\r\n  async stats(params: RequestParams): Promise<PaginatedResult<Stats>> {\r\n    const headers = Defaults.defaultGetHeaders(this.client.options),\r\n      format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format;\r\n\r\n    Utils.mixin(headers, this.client.options.headers);\r\n\r\n    return new PaginatedResource(this.client, '/stats', headers, envelope, function (body, headers, unpacked) {\r\n      const statsValues = unpacked ? body : JSON.parse(body as string);\r\n      for (let i = 0; i < statsValues.length; i++) statsValues[i] = Stats.fromValues(statsValues[i]);\r\n      return statsValues;\r\n    }).get(params as Record<string, string>);\r\n  }\r\n\r\n  async time(params?: RequestParams): Promise<number> {\r\n    const headers = Defaults.defaultGetHeaders(this.client.options);\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n    const timeUri = (host: string) => {\r\n      return this.client.baseUri(host) + '/time';\r\n    };\r\n\r\n    let { error, body, unpacked } = await this.client.http.do(\r\n      HttpMethods.Get,\r\n      timeUri,\r\n      headers,\r\n      null,\r\n      params as RequestParams,\r\n    );\r\n\r\n    if (error) {\r\n      throw error;\r\n    }\r\n    if (!unpacked) body = JSON.parse(body as string);\r\n    const time = (body as number[])[0];\r\n    if (!time) {\r\n      throw new ErrorInfo('Internal error (unexpected result type from GET /time)', 50000, 500);\r\n    }\r\n    /* calculate time offset only once for this device by adding to the prototype */\r\n    this.client.serverTimeOffset = time - Date.now();\r\n    return time;\r\n  }\r\n\r\n  async request(\r\n    method: string,\r\n    path: string,\r\n    version: number,\r\n    params: RequestParams,\r\n    body: unknown,\r\n    customHeaders: Record<string, string>,\r\n  ): Promise<HttpPaginatedResponse<unknown>> {\r\n    const [encoder, decoder, format] = (() => {\r\n      if (this.client.options.useBinaryProtocol) {\r\n        if (!this.client._MsgPack) {\r\n          Utils.throwMissingPluginError('MsgPack');\r\n        }\r\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, Utils.Format.msgpack];\r\n      } else {\r\n        return [JSON.stringify, JSON.parse, Utils.Format.json];\r\n      }\r\n    })();\r\n    const envelope = this.client.http.supportsLinkHeaders ? undefined : format;\r\n    params = params || {};\r\n    const _method = method.toLowerCase() as HttpMethods;\r\n    const headers =\r\n      _method == 'get'\r\n        ? Defaults.defaultGetHeaders(this.client.options, { format, protocolVersion: version })\r\n        : Defaults.defaultPostHeaders(this.client.options, { format, protocolVersion: version });\r\n\r\n    if (typeof body !== 'string') {\r\n      body = encoder(body) ?? null;\r\n    }\r\n    Utils.mixin(headers, this.client.options.headers);\r\n    if (customHeaders) {\r\n      Utils.mixin(headers, customHeaders);\r\n    }\r\n    const paginatedResource = new PaginatedResource(\r\n      this.client,\r\n      path,\r\n      headers,\r\n      envelope,\r\n      async function (resbody, headers, unpacked) {\r\n        return Utils.ensureArray(unpacked ? resbody : decoder(resbody as string & Buffer));\r\n      },\r\n      /* useHttpPaginatedResponse: */ true,\r\n    );\r\n\r\n    if (!Platform.Http.methods.includes(_method)) {\r\n      throw new ErrorInfo('Unsupported method ' + _method, 40500, 405);\r\n    }\r\n\r\n    if (Platform.Http.methodsWithBody.includes(_method)) {\r\n      return paginatedResource[_method as HttpMethods.Post](params, body as RequestBody) as Promise<\r\n        HttpPaginatedResponse<unknown>\r\n      >;\r\n    } else {\r\n      return paginatedResource[_method as HttpMethods.Get | HttpMethods.Delete](params) as Promise<\r\n        HttpPaginatedResponse<unknown>\r\n      >;\r\n    }\r\n  }\r\n\r\n  async batchPublish<T extends BatchPublishSpec | BatchPublishSpec[]>(\r\n    specOrSpecs: T,\r\n  ): Promise<T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[]> {\r\n    let requestBodyDTO: BatchPublishSpec[];\r\n    let singleSpecMode: boolean;\r\n    if (Array.isArray(specOrSpecs)) {\r\n      requestBodyDTO = specOrSpecs;\r\n      singleSpecMode = false;\r\n    } else {\r\n      requestBodyDTO = [specOrSpecs];\r\n      singleSpecMode = true;\r\n    }\r\n\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const requestBody = Utils.encodeBody(requestBodyDTO, this.client._MsgPack, format);\r\n\r\n    const response = await Resource.post(this.client, '/messages', requestBody, headers, {}, null, true);\r\n\r\n    const batchResults = (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as BatchPublishResult[];\r\n\r\n    // I don't love the below type assertions but not sure how to avoid them\r\n    if (singleSpecMode) {\r\n      return batchResults[0] as T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[];\r\n    } else {\r\n      return batchResults as T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[];\r\n    }\r\n  }\r\n\r\n  async batchPresence(channels: string[]): Promise<BatchPresenceResult> {\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const channelsParam = channels.join(',');\r\n\r\n    const response = await Resource.get(this.client, '/presence', headers, { channels: channelsParam }, null, true);\r\n\r\n    return (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as BatchPresenceResult;\r\n  }\r\n\r\n  async revokeTokens(\r\n    specifiers: TokenRevocationTargetSpecifier[],\r\n    options?: TokenRevocationOptions,\r\n  ): Promise<TokenRevocationResult> {\r\n    if (useTokenAuth(this.client.options)) {\r\n      throw new ErrorInfo('Cannot revoke tokens when using token auth', 40162, 401);\r\n    }\r\n\r\n    const keyName = this.client.options.keyName!;\r\n\r\n    let resolvedOptions = options ?? {};\r\n\r\n    const requestBodyDTO = {\r\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`),\r\n      ...resolvedOptions,\r\n    };\r\n\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const requestBody = Utils.encodeBody(requestBodyDTO, this.client._MsgPack, format);\r\n\r\n    const response = await Resource.post(\r\n      this.client,\r\n      `/keys/${keyName}/revokeTokens`,\r\n      requestBody,\r\n      headers,\r\n      {},\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as TokenRevocationResult;\r\n  }\r\n}\r\n\r\nclass Channels {\r\n  client: BaseClient;\r\n  all: Record<string, RestChannel>;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.all = Object.create(null);\r\n  }\r\n\r\n  get(name: string, channelOptions?: ChannelOptions) {\r\n    name = String(name);\r\n    let channel = this.all[name];\r\n    if (!channel) {\r\n      this.all[name] = channel = new RestChannel(this.client, name, channelOptions);\r\n    } else if (channelOptions) {\r\n      channel.setOptions(channelOptions);\r\n    }\r\n\r\n    return channel;\r\n  }\r\n\r\n  /* Included to support certain niche use-cases; most users should ignore this.\r\n   * Please do not use this unless you know what you're doing */\r\n  release(name: string) {\r\n    delete this.all[String(name)];\r\n  }\r\n}\r\n", "import BaseClient from './baseclient';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { Rest } from './rest';\r\nimport Defaults from '../util/defaults';\r\nimport Logger from '../util/logger';\r\n\r\n/**\r\n `BaseRest` is an export of the tree-shakable version of the SDK, and acts as the base class for the `DefaultRest` class exported by the non tree-shakable version.\r\n\r\n It always includes the `Rest` plugin.\r\n */\r\nexport class BaseRest extends BaseClient {\r\n  /*\r\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\r\n   *\r\n   * 1. passes a string (which is quite likely if they\u2019re e.g. migrating from the default variant to the modular variant)\r\n   * 2. passes no argument at all\r\n   *\r\n   * tell the compiler that these cases are possible so that it forces us to handle them.\r\n   */\r\n  constructor(options?: ClientOptions | string) {\r\n    super(Defaults.objectifyOptions(options, false, 'BaseRest', Logger.defaultLogger, { Rest }));\r\n  }\r\n}\r\n", "import { Rest } from './rest';\r\nimport { IUntypedCryptoStatic } from '../../types/ICryptoStatic';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport RealtimePresence from './realtimepresence';\r\nimport XHRRequest from 'platform/web/lib/http/request/xhrrequest';\r\nimport fetchRequest from 'platform/web/lib/http/request/fetchrequest';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\nimport {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from '../types/presencemessage';\r\nimport { TransportCtor } from '../transport/transport';\r\n\r\nexport interface PresenceMessagePlugin {\r\n  presenceMessageFromValues: typeof presenceMessageFromValues;\r\n  presenceMessagesFromValuesArray: typeof presenceMessagesFromValuesArray;\r\n}\r\n\r\nexport type RealtimePresencePlugin = PresenceMessagePlugin & {\r\n  RealtimePresence: typeof RealtimePresence;\r\n};\r\n\r\nexport interface ModularPlugins {\r\n  Rest?: typeof Rest;\r\n  Crypto?: IUntypedCryptoStatic;\r\n  MsgPack?: MsgPack;\r\n  RealtimePresence?: RealtimePresencePlugin;\r\n  WebSocketTransport?: TransportCtor;\r\n  XHRPolling?: TransportCtor;\r\n  XHRRequest?: typeof XHRRequest;\r\n  FetchRequest?: typeof fetchRequest;\r\n  MessageInteractions?: typeof FilteredSubscriptions;\r\n}\r\n\r\nexport const allCommonModularPlugins: ModularPlugins = { Rest };\r\n", "import Message, {\r\n  CipherOptions,\r\n  fromEncoded,\r\n  fromEncodedArray,\r\n  encode,\r\n  decode,\r\n  EncodingDecodingContext,\r\n} from './message';\r\nimport * as API from '../../../../ably';\r\nimport Platform from 'common/platform';\r\nimport PresenceMessage from './presencemessage';\r\nimport { ChannelOptions } from 'common/types/channel';\r\nimport Logger from '../util/logger';\r\n\r\n/**\r\n `DefaultMessage` is the class returned by `DefaultRest` and `DefaultRealtime`\u2019s `Message` static property. It introduces the static methods described in the `MessageStatic` interface of the public API of the non tree-shakable version of the library.\r\n */\r\nexport class DefaultMessage extends Message {\r\n  static async fromEncoded(encoded: unknown, inputOptions?: API.ChannelOptions): Promise<Message> {\r\n    return fromEncoded(Logger.defaultLogger, Platform.Crypto, encoded, inputOptions);\r\n  }\r\n\r\n  static async fromEncodedArray(encodedArray: Array<unknown>, options?: API.ChannelOptions): Promise<Message[]> {\r\n    return fromEncodedArray(Logger.defaultLogger, Platform.Crypto, encodedArray, options);\r\n  }\r\n\r\n  // Used by tests\r\n  static fromValues(values: unknown): Message {\r\n    return Object.assign(new Message(), values);\r\n  }\r\n\r\n  // Used by tests\r\n  static async encode<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\r\n    return encode(msg, options);\r\n  }\r\n\r\n  // Used by tests\r\n  static async decode(\r\n    message: Message | PresenceMessage,\r\n    inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\r\n  ): Promise<void> {\r\n    return decode(message, inputContext);\r\n  }\r\n}\r\n", "import * as API from '../../../../ably';\r\nimport Logger from '../util/logger';\r\nimport PresenceMessage, { fromEncoded, fromEncodedArray, fromValues } from './presencemessage';\r\n\r\n/**\r\n `DefaultPresenceMessage` is the class returned by `DefaultRest` and `DefaultRealtime`\u2019s `PresenceMessage` static property. It introduces the static methods described in the `PresenceMessageStatic` interface of the public API of the non tree-shakable version of the library.\r\n */\r\nexport class DefaultPresenceMessage extends PresenceMessage {\r\n  static async fromEncoded(encoded: unknown, inputOptions?: API.ChannelOptions): Promise<PresenceMessage> {\r\n    return fromEncoded(Logger.defaultLogger, encoded, inputOptions);\r\n  }\r\n\r\n  static async fromEncodedArray(\r\n    encodedArray: Array<unknown>,\r\n    options?: API.ChannelOptions,\r\n  ): Promise<PresenceMessage[]> {\r\n    return fromEncodedArray(Logger.defaultLogger, encodedArray, options);\r\n  }\r\n\r\n  static fromValues(values: PresenceMessage | Record<string, unknown>, stringifyAction?: boolean): PresenceMessage {\r\n    return fromValues(values, stringifyAction);\r\n  }\r\n}\r\n", "import { BaseRest } from './baserest';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { allCommonModularPlugins } from './modularplugins';\r\nimport Platform from 'common/platform';\r\nimport { DefaultMessage } from '../types/defaultmessage';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { DefaultPresenceMessage } from '../types/defaultpresencemessage';\r\nimport { Http } from 'common/types/http';\r\nimport Defaults from '../util/defaults';\r\nimport Logger from '../util/logger';\r\n\r\n/**\r\n `DefaultRest` is the class that the non tree-shakable version of the SDK exports as `Rest`. It ensures that this version of the SDK includes all of the functionality which is optionally available in the tree-shakable version.\r\n */\r\nexport class DefaultRest extends BaseRest {\r\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\r\n  constructor(options?: ClientOptions | string) {\r\n    const MsgPack = DefaultRest._MsgPack;\r\n    if (!MsgPack) {\r\n      throw new Error('Expected DefaultRest._MsgPack to have been set');\r\n    }\r\n\r\n    super(\r\n      Defaults.objectifyOptions(options, true, 'Rest', Logger.defaultLogger, {\r\n        ...allCommonModularPlugins,\r\n        Crypto: DefaultRest.Crypto ?? undefined,\r\n        MsgPack: DefaultRest._MsgPack ?? undefined,\r\n      }),\r\n    );\r\n  }\r\n\r\n  private static _Crypto: typeof Platform.Crypto = null;\r\n  static get Crypto() {\r\n    if (this._Crypto === null) {\r\n      throw new Error('Encryption not enabled; use ably.encryption.js instead');\r\n    }\r\n\r\n    return this._Crypto;\r\n  }\r\n  static set Crypto(newValue: typeof Platform.Crypto) {\r\n    this._Crypto = newValue;\r\n  }\r\n\r\n  static Message = DefaultMessage;\r\n  static PresenceMessage = DefaultPresenceMessage;\r\n\r\n  static _MsgPack: MsgPack | null = null;\r\n\r\n  // Used by tests\r\n  static _Http = Http;\r\n}\r\n", "import * as Utils from './utils';\r\nimport Logger from './logger';\r\nimport Platform from 'common/platform';\r\n\r\n/* Call the listener, catch any exceptions and log, but continue operation*/\r\nfunction callListener(logger: Logger, eventThis: { event: string }, listener: Function, args: unknown[]) {\r\n  try {\r\n    listener.apply(eventThis, args);\r\n  } catch (e) {\r\n    Logger.logAction(\r\n      logger,\r\n      Logger.LOG_ERROR,\r\n      'EventEmitter.emit()',\r\n      'Unexpected listener exception: ' + e + '; stack = ' + (e && (e as Error).stack),\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Remove listeners that match listener\r\n * @param targetListeners is an array of listener arrays or event objects with arrays of listeners\r\n * @param listener the listener callback to remove\r\n * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event\r\n */\r\nfunction removeListener(targetListeners: any, listener: Function, eventFilter?: string) {\r\n  let listeners: Record<string, unknown>;\r\n  let index;\r\n  let eventName;\r\n\r\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\r\n    listeners = targetListeners[targetListenersIndex];\r\n    if (eventFilter) {\r\n      listeners = listeners[eventFilter] as Record<string, unknown>;\r\n    }\r\n\r\n    if (Array.isArray(listeners)) {\r\n      while ((index = listeners.indexOf(listener)) !== -1) {\r\n        listeners.splice(index, 1);\r\n      }\r\n      /* If events object has an event name key with no listeners then\r\n\t\t\t\t\tremove the key to stop the list growing indefinitely */\r\n      if (eventFilter && listeners.length === 0) {\r\n        delete targetListeners[targetListenersIndex][eventFilter];\r\n      }\r\n    } else if (Utils.isObject(listeners)) {\r\n      /* events */\r\n      for (eventName in listeners) {\r\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\r\n          removeListener([listeners], listener, eventName);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass EventEmitter {\r\n  any: Array<Function>;\r\n  events: Record<string, Array<Function>>;\r\n  anyOnce: Array<Function>;\r\n  eventsOnce: Record<string, Array<Function>>;\r\n\r\n  constructor(readonly logger: Logger) {\r\n    this.any = [];\r\n    this.events = Object.create(null);\r\n    this.anyOnce = [];\r\n    this.eventsOnce = Object.create(null);\r\n  }\r\n\r\n  /**\r\n   * Add an event listener\r\n   * @param listener the listener to be called\r\n   */\r\n  on(listener: Function): void;\r\n\r\n  /**\r\n   * Add an event listener\r\n   * @param event (optional) the name of the event to listen to\r\n   * @param listener the listener to be called\r\n   */\r\n  on(event: null | string | string[], listener: Function): void;\r\n\r\n  on(...args: unknown[]) {\r\n    if (args.length === 1) {\r\n      const listener = args[0];\r\n      if (typeof listener === 'function') {\r\n        this.any.push(listener);\r\n      } else {\r\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n      }\r\n    }\r\n    if (args.length === 2) {\r\n      const [event, listener] = args;\r\n      if (typeof listener !== 'function') {\r\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n      }\r\n      if (Utils.isNil(event)) {\r\n        this.any.push(listener);\r\n      } else if (Array.isArray(event)) {\r\n        event.forEach((eventName) => {\r\n          this.on(eventName, listener);\r\n        });\r\n      } else {\r\n        if (typeof event !== 'string') {\r\n          throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n        }\r\n        const listeners = this.events[event] || (this.events[event] = []);\r\n        listeners.push(listener);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove one or more event listeners\r\n   * @param listener (optional) the listener to remove. If not\r\n   *        supplied, all listeners are removed.\r\n   */\r\n  off(listener?: Function): void;\r\n\r\n  /**\r\n   * Remove one or more event listeners\r\n   * @param event (optional) the name of the event whose listener\r\n   *        is to be removed. If not supplied, the listener is\r\n   *        treated as an 'any' listener\r\n   * @param listener (optional) the listener to remove. If not\r\n   *        supplied, all listeners are removed.\r\n   */\r\n  off(event: string | string[] | null, listener?: Function | null): void;\r\n\r\n  off(...args: unknown[]) {\r\n    if (args.length == 0 || (Utils.isNil(args[0]) && Utils.isNil(args[1]))) {\r\n      this.any = [];\r\n      this.events = Object.create(null);\r\n      this.anyOnce = [];\r\n      this.eventsOnce = Object.create(null);\r\n      return;\r\n    }\r\n    const [firstArg, secondArg] = args;\r\n    let listener: Function | null = null;\r\n    let event: unknown = null;\r\n    if (args.length === 1 || !secondArg) {\r\n      if (typeof firstArg === 'function') {\r\n        /* we take this to be the listener and treat the event as \"any\" .. */\r\n        listener = firstArg;\r\n      } else {\r\n        event = firstArg;\r\n      }\r\n      /* ... or we take event to be the actual event name and listener to be all */\r\n    } else {\r\n      if (typeof secondArg !== 'function') {\r\n        throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      [event, listener] = [firstArg, secondArg];\r\n    }\r\n\r\n    if (listener && Utils.isNil(event)) {\r\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\r\n      return;\r\n    }\r\n\r\n    if (Array.isArray(event)) {\r\n      event.forEach((eventName) => {\r\n        this.off(eventName, listener);\r\n      });\r\n      return;\r\n    }\r\n\r\n    /* \"normal\" case where event is an actual event */\r\n    if (typeof event !== 'string') {\r\n      throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\r\n    }\r\n    if (listener) {\r\n      removeListener([this.events, this.eventsOnce], listener, event);\r\n    } else {\r\n      delete this.events[event];\r\n      delete this.eventsOnce[event];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the array of listeners for a given event; excludes once events\r\n   * @param event (optional) the name of the event, or none for 'any'\r\n   * @return array of events, or null if none\r\n   */\r\n  listeners(event: string) {\r\n    if (event) {\r\n      const listeners = this.events[event] || [];\r\n      if (this.eventsOnce[event]) Array.prototype.push.apply(listeners, this.eventsOnce[event]);\r\n      return listeners.length ? listeners : null;\r\n    }\r\n    return this.any.length ? this.any : null;\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   * @param event the event name\r\n   * @param args the arguments to pass to the listener\r\n   */\r\n  emit(event: string, ...args: unknown[] /* , args... */) {\r\n    const eventThis = { event };\r\n    const listeners: Function[] = [];\r\n\r\n    if (this.anyOnce.length) {\r\n      Array.prototype.push.apply(listeners, this.anyOnce);\r\n      this.anyOnce = [];\r\n    }\r\n    if (this.any.length) {\r\n      Array.prototype.push.apply(listeners, this.any);\r\n    }\r\n    const eventsOnceListeners = this.eventsOnce[event];\r\n    if (eventsOnceListeners) {\r\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\r\n      delete this.eventsOnce[event];\r\n    }\r\n    const eventsListeners = this.events[event];\r\n    if (eventsListeners) {\r\n      Array.prototype.push.apply(listeners, eventsListeners);\r\n    }\r\n\r\n    listeners.forEach((listener) => {\r\n      callListener(this.logger, eventThis, listener, args);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Listen for a single occurrence of an event\r\n   * @param event the name of the event to listen to\r\n   */\r\n  once(event: string): Promise<void>;\r\n\r\n  /**\r\n   * Listen for a single occurrence of any event\r\n   * @param listener the listener to be called\r\n   */\r\n  once(listener: Function): void;\r\n\r\n  /**\r\n   * Listen for a single occurrence of an event\r\n   * @param event the name of the event to listen to\r\n   * @param listener the listener to be called\r\n   */\r\n  once(event?: string | string[] | null, listener?: Function): void;\r\n\r\n  once(...args: unknown[]): void | Promise<void> {\r\n    const argCount = args.length;\r\n    if (argCount === 0 || (argCount === 1 && typeof args[0] !== 'function')) {\r\n      const event = args[0];\r\n      return new Promise((resolve) => {\r\n        this.once(event as string | string[] | null, resolve);\r\n      });\r\n    }\r\n\r\n    const [firstArg, secondArg] = args;\r\n    if (args.length === 1 && typeof firstArg === 'function') {\r\n      this.anyOnce.push(firstArg);\r\n    } else if (Utils.isNil(firstArg)) {\r\n      if (typeof secondArg !== 'function') {\r\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      this.anyOnce.push(secondArg);\r\n    } else if (Array.isArray(firstArg)) {\r\n      const self = this;\r\n      const listenerWrapper = function (this: any) {\r\n        const innerArgs = Array.prototype.slice.call(arguments);\r\n        firstArg.forEach(function (eventName) {\r\n          self.off(eventName, listenerWrapper);\r\n        });\r\n        if (typeof secondArg !== 'function') {\r\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n        }\r\n        secondArg.apply(this, innerArgs);\r\n      };\r\n      firstArg.forEach(function (eventName) {\r\n        self.on(eventName, listenerWrapper);\r\n      });\r\n    } else {\r\n      if (typeof firstArg !== 'string') {\r\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\r\n      if (secondArg) {\r\n        if (typeof secondArg !== 'function') {\r\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n        }\r\n        listeners.push(secondArg);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\r\n   * @param targetState the name of the state event to listen to\r\n   * @param currentState the name of the current state of this object\r\n   */\r\n  async whenState(targetState: string, currentState: string) {\r\n    if (typeof targetState !== 'string' || typeof currentState !== 'string') {\r\n      throw new Error('whenState requires a valid state String argument');\r\n    }\r\n    if (targetState === currentState) {\r\n      return null;\r\n    } else {\r\n      return this.once(targetState);\r\n    }\r\n  }\r\n}\r\n\r\nexport default EventEmitter;\r\n", "import { MsgPack } from 'common/types/msgpack';\r\nimport * as API from '../../../../ably';\r\nimport { PresenceMessagePlugin } from '../client/modularplugins';\r\nimport * as Utils from '../util/utils';\r\nimport ErrorInfo from './errorinfo';\r\nimport Message, { fromValues as messageFromValues, fromValuesArray as messagesFromValuesArray } from './message';\r\nimport PresenceMessage, {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from './presencemessage';\r\n\r\nexport const actions = {\r\n  HEARTBEAT: 0,\r\n  ACK: 1,\r\n  NACK: 2,\r\n  CONNECT: 3,\r\n  CONNECTED: 4,\r\n  DISCONNECT: 5,\r\n  DISCONNECTED: 6,\r\n  CLOSE: 7,\r\n  CLOSED: 8,\r\n  ERROR: 9,\r\n  ATTACH: 10,\r\n  ATTACHED: 11,\r\n  DETACH: 12,\r\n  DETACHED: 13,\r\n  PRESENCE: 14,\r\n  MESSAGE: 15,\r\n  SYNC: 16,\r\n  AUTH: 17,\r\n  ACTIVATE: 18,\r\n};\r\n\r\nexport const ActionName: string[] = [];\r\nObject.keys(actions).forEach(function (name) {\r\n  ActionName[(actions as { [key: string]: number })[name]] = name;\r\n});\r\n\r\nconst flags: { [key: string]: number } = {\r\n  /* Channel attach state flags */\r\n  HAS_PRESENCE: 1 << 0,\r\n  HAS_BACKLOG: 1 << 1,\r\n  RESUMED: 1 << 2,\r\n  TRANSIENT: 1 << 4,\r\n  ATTACH_RESUME: 1 << 5,\r\n  /* Channel mode flags */\r\n  PRESENCE: 1 << 16,\r\n  PUBLISH: 1 << 17,\r\n  SUBSCRIBE: 1 << 18,\r\n  PRESENCE_SUBSCRIBE: 1 << 19,\r\n};\r\nconst flagNames = Object.keys(flags);\r\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;\r\n\r\nfunction toStringArray(array?: any[]): string {\r\n  const result = [];\r\n  if (array) {\r\n    for (let i = 0; i < array.length; i++) {\r\n      result.push(array[i].toString());\r\n    }\r\n  }\r\n  return '[ ' + result.join(', ') + ' ]';\r\n}\r\n\r\nexport const channelModes = ['PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE'];\r\n\r\nexport const serialize = Utils.encodeBody;\r\n\r\nexport function deserialize(\r\n  serialized: unknown,\r\n  MsgPack: MsgPack | null,\r\n  presenceMessagePlugin: PresenceMessagePlugin | null,\r\n  format?: Utils.Format,\r\n): ProtocolMessage {\r\n  const deserialized = Utils.decodeBody<Record<string, unknown>>(serialized, MsgPack, format);\r\n  return fromDeserialized(deserialized, presenceMessagePlugin);\r\n}\r\n\r\nexport function fromDeserialized(\r\n  deserialized: Record<string, unknown>,\r\n  presenceMessagePlugin: PresenceMessagePlugin | null,\r\n): ProtocolMessage {\r\n  const error = deserialized.error;\r\n  if (error) deserialized.error = ErrorInfo.fromValues(error as ErrorInfo);\r\n  const messages = deserialized.messages as Message[];\r\n  if (messages) for (let i = 0; i < messages.length; i++) messages[i] = messageFromValues(messages[i]);\r\n\r\n  const presence = presenceMessagePlugin ? (deserialized.presence as PresenceMessage[]) : undefined;\r\n  if (presenceMessagePlugin) {\r\n    if (presence && presenceMessagePlugin)\r\n      for (let i = 0; i < presence.length; i++)\r\n        presence[i] = presenceMessagePlugin.presenceMessageFromValues(presence[i], true);\r\n  }\r\n  return Object.assign(new ProtocolMessage(), { ...deserialized, presence });\r\n}\r\n\r\n/**\r\n * Used by the tests.\r\n */\r\nexport function fromDeserializedIncludingDependencies(deserialized: Record<string, unknown>): ProtocolMessage {\r\n  return fromDeserialized(deserialized, { presenceMessageFromValues, presenceMessagesFromValuesArray });\r\n}\r\n\r\nexport function fromValues(values: unknown): ProtocolMessage {\r\n  return Object.assign(new ProtocolMessage(), values);\r\n}\r\n\r\nexport function stringify(msg: any, presenceMessagePlugin: PresenceMessagePlugin | null): string {\r\n  let result = '[ProtocolMessage';\r\n  if (msg.action !== undefined) result += '; action=' + ActionName[msg.action] || msg.action;\r\n\r\n  const simpleAttributes = ['id', 'channel', 'channelSerial', 'connectionId', 'count', 'msgSerial', 'timestamp'];\r\n  let attribute;\r\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\r\n    attribute = simpleAttributes[attribIndex];\r\n    if (msg[attribute] !== undefined) result += '; ' + attribute + '=' + msg[attribute];\r\n  }\r\n\r\n  if (msg.messages) result += '; messages=' + toStringArray(messagesFromValuesArray(msg.messages));\r\n  if (msg.presence && presenceMessagePlugin)\r\n    result += '; presence=' + toStringArray(presenceMessagePlugin.presenceMessagesFromValuesArray(msg.presence));\r\n  if (msg.error) result += '; error=' + ErrorInfo.fromValues(msg.error).toString();\r\n  if (msg.auth && msg.auth.accessToken) result += '; token=' + msg.auth.accessToken;\r\n  if (msg.flags) result += '; flags=' + flagNames.filter(msg.hasFlag).join(',');\r\n  if (msg.params) {\r\n    let stringifiedParams = '';\r\n    Utils.forInOwnNonNullProperties(msg.params, function (prop: string) {\r\n      if (stringifiedParams.length > 0) {\r\n        stringifiedParams += '; ';\r\n      }\r\n      stringifiedParams += prop + '=' + msg.params[prop];\r\n    });\r\n    if (stringifiedParams.length > 0) {\r\n      result += '; params=[' + stringifiedParams + ']';\r\n    }\r\n  }\r\n  result += ']';\r\n  return result;\r\n}\r\n\r\nclass ProtocolMessage {\r\n  action?: number;\r\n  flags?: number;\r\n  id?: string;\r\n  timestamp?: number;\r\n  count?: number;\r\n  error?: ErrorInfo;\r\n  connectionId?: string;\r\n  channel?: string;\r\n  channelSerial?: string | null;\r\n  msgSerial?: number;\r\n  messages?: Message[];\r\n  // This will be undefined if we skipped decoding this property due to user not requesting presence functionality \u2014 see `fromDeserialized`\r\n  presence?: PresenceMessage[];\r\n  auth?: unknown;\r\n  connectionDetails?: Record<string, unknown>;\r\n\r\n  hasFlag = (flag: string): boolean => {\r\n    return ((this.flags as number) & flags[flag]) > 0;\r\n  };\r\n\r\n  setFlag(flag: API.ChannelMode): number {\r\n    return (this.flags = (this.flags as number) | flags[flag]);\r\n  }\r\n\r\n  getMode(): number | undefined {\r\n    return this.flags && this.flags & flags.MODE_ALL;\r\n  }\r\n\r\n  encodeModesToFlags(modes: API.ChannelMode[]): void {\r\n    modes.forEach((mode) => this.setFlag(mode));\r\n  }\r\n\r\n  decodeModesFromFlags(): string[] | undefined {\r\n    const modes: string[] = [];\r\n    channelModes.forEach((mode) => {\r\n      if (this.hasFlag(mode)) {\r\n        modes.push(mode);\r\n      }\r\n    });\r\n    return modes.length > 0 ? modes : undefined;\r\n  }\r\n}\r\n\r\nexport default ProtocolMessage;\r\n", "import ErrorInfo from '../types/errorinfo';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport { PendingMessage } from './protocol';\r\n\r\nclass MessageQueue extends EventEmitter {\r\n  messages: Array<PendingMessage>;\r\n\r\n  constructor(logger: Logger) {\r\n    super(logger);\r\n    this.messages = [];\r\n  }\r\n\r\n  count(): number {\r\n    return this.messages.length;\r\n  }\r\n\r\n  push(message: PendingMessage): void {\r\n    this.messages.push(message);\r\n  }\r\n\r\n  shift(): PendingMessage | undefined {\r\n    return this.messages.shift();\r\n  }\r\n\r\n  last(): PendingMessage {\r\n    return this.messages[this.messages.length - 1];\r\n  }\r\n\r\n  copyAll(): PendingMessage[] {\r\n    return this.messages.slice();\r\n  }\r\n\r\n  append(messages: Array<PendingMessage>): void {\r\n    this.messages.push.apply(this.messages, messages);\r\n  }\r\n\r\n  prepend(messages: Array<PendingMessage>): void {\r\n    this.messages.unshift.apply(this.messages, messages);\r\n  }\r\n\r\n  completeMessages(serial: number, count: number, err?: ErrorInfo | null): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'MessageQueue.completeMessages()',\r\n      'serial = ' + serial + '; count = ' + count,\r\n    );\r\n    err = err || null;\r\n    const messages = this.messages;\r\n    if (messages.length === 0) {\r\n      throw new Error('MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue');\r\n    }\r\n    const first = messages[0];\r\n    if (first) {\r\n      const startSerial = first.message.msgSerial as number;\r\n      const endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */\r\n      if (endSerial > startSerial) {\r\n        const completeMessages = messages.splice(0, endSerial - startSerial);\r\n        for (const message of completeMessages) {\r\n          (message.callback as Function)(err);\r\n        }\r\n      }\r\n      if (messages.length == 0) this.emit('idle');\r\n    }\r\n  }\r\n\r\n  completeAllMessages(err: ErrorInfo): void {\r\n    this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\r\n  }\r\n\r\n  resetSendAttempted(): void {\r\n    for (let msg of this.messages) {\r\n      msg.sendAttempted = false;\r\n    }\r\n  }\r\n\r\n  clear(): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'MessageQueue.clear()',\r\n      'clearing ' + this.messages.length + ' messages',\r\n    );\r\n    this.messages = [];\r\n    this.emit('idle');\r\n  }\r\n}\r\n\r\nexport default MessageQueue;\r\n", "import ProtocolMessage, { actions, stringify as stringifyProtocolMessage } from '../types/protocolmessage';\r\nimport * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport MessageQueue from './messagequeue';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Transport from './transport';\r\nimport { ErrCallback } from '../../types/utils';\r\n\r\nexport class PendingMessage {\r\n  message: ProtocolMessage;\r\n  callback?: ErrCallback;\r\n  merged: boolean;\r\n  sendAttempted: boolean;\r\n  ackRequired: boolean;\r\n\r\n  constructor(message: ProtocolMessage, callback?: ErrCallback) {\r\n    this.message = message;\r\n    this.callback = callback;\r\n    this.merged = false;\r\n    const action = message.action;\r\n    this.sendAttempted = false;\r\n    this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE;\r\n  }\r\n}\r\n\r\nclass Protocol extends EventEmitter {\r\n  transport: Transport;\r\n  messageQueue: MessageQueue;\r\n\r\n  constructor(transport: Transport) {\r\n    super(transport.logger);\r\n    this.transport = transport;\r\n    this.messageQueue = new MessageQueue(this.logger);\r\n    transport.on('ack', (serial: number, count: number) => {\r\n      this.onAck(serial, count);\r\n    });\r\n    transport.on('nack', (serial: number, count: number, err: ErrorInfo) => {\r\n      this.onNack(serial, count, err);\r\n    });\r\n  }\r\n\r\n  onAck(serial: number, count: number): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);\r\n    this.messageQueue.completeMessages(serial, count);\r\n  }\r\n\r\n  onNack(serial: number, count: number, err: ErrorInfo): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_ERROR,\r\n      'Protocol.onNack()',\r\n      'serial = ' + serial + '; count = ' + count + '; err = ' + Utils.inspectError(err),\r\n    );\r\n    if (!err) {\r\n      err = new ErrorInfo('Unable to send message; channel not responding', 50001, 500);\r\n    }\r\n    this.messageQueue.completeMessages(serial, count, err);\r\n  }\r\n\r\n  onceIdle(listener: ErrCallback): void {\r\n    const messageQueue = this.messageQueue;\r\n    if (messageQueue.count() === 0) {\r\n      listener();\r\n      return;\r\n    }\r\n    messageQueue.once('idle', listener);\r\n  }\r\n\r\n  send(pendingMessage: PendingMessage): void {\r\n    if (pendingMessage.ackRequired) {\r\n      this.messageQueue.push(pendingMessage);\r\n    }\r\n    if (this.logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logActionNoStrip(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'Protocol.send()',\r\n        'sending msg; ' +\r\n          stringifyProtocolMessage(pendingMessage.message, this.transport.connectionManager.realtime._RealtimePresence),\r\n      );\r\n    }\r\n    pendingMessage.sendAttempted = true;\r\n    this.transport.send(pendingMessage.message);\r\n  }\r\n\r\n  getTransport(): Transport {\r\n    return this.transport;\r\n  }\r\n\r\n  getPendingMessages(): PendingMessage[] {\r\n    return this.messageQueue.copyAll();\r\n  }\r\n\r\n  clearPendingMessages(): void {\r\n    return this.messageQueue.clear();\r\n  }\r\n\r\n  finish(): void {\r\n    const transport = this.transport;\r\n    this.onceIdle(function () {\r\n      transport.disconnect();\r\n    });\r\n  }\r\n}\r\n\r\nexport default Protocol;\r\n", "import { IPartialErrorInfo } from '../types/errorinfo';\r\n\r\nclass ConnectionStateChange {\r\n  previous?: string;\r\n  current?: string;\r\n  retryIn?: number;\r\n  reason?: IPartialErrorInfo;\r\n\r\n  constructor(previous?: string, current?: string, retryIn?: number | null, reason?: IPartialErrorInfo) {\r\n    this.previous = previous;\r\n    this.current = current;\r\n    if (retryIn) this.retryIn = retryIn;\r\n    if (reason) this.reason = reason;\r\n  }\r\n}\r\n\r\nexport default ConnectionStateChange;\r\n", "import ErrorInfo from '../types/errorinfo';\r\n\r\nconst ConnectionErrorCodes = {\r\n  DISCONNECTED: 80003,\r\n  SUSPENDED: 80002,\r\n  FAILED: 80000,\r\n  CLOSING: 80017,\r\n  CLOSED: 80017,\r\n  UNKNOWN_CONNECTION_ERR: 50002,\r\n  UNKNOWN_CHANNEL_ERR: 50001,\r\n};\r\n\r\nconst ConnectionErrors = {\r\n  disconnected: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 400,\r\n      code: ConnectionErrorCodes.DISCONNECTED,\r\n      message: 'Connection to server temporarily unavailable',\r\n    }),\r\n  suspended: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 400,\r\n      code: ConnectionErrorCodes.SUSPENDED,\r\n      message: 'Connection to server unavailable',\r\n    }),\r\n  failed: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 400,\r\n      code: ConnectionErrorCodes.FAILED,\r\n      message: 'Connection failed or disconnected by server',\r\n    }),\r\n  closing: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 400,\r\n      code: ConnectionErrorCodes.CLOSING,\r\n      message: 'Connection closing',\r\n    }),\r\n  closed: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 400,\r\n      code: ConnectionErrorCodes.CLOSED,\r\n      message: 'Connection closed',\r\n    }),\r\n  unknownConnectionErr: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 500,\r\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\r\n      message: 'Internal connection error',\r\n    }),\r\n  unknownChannelErr: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 500,\r\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\r\n      message: 'Internal channel error',\r\n    }),\r\n};\r\n\r\nexport function isRetriable(err: ErrorInfo) {\r\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\r\n    return true;\r\n  }\r\n  return Object.values(ConnectionErrorCodes).includes(err.code);\r\n}\r\n\r\nexport default ConnectionErrors;\r\n", "import ProtocolMessage, {\r\n  actions,\r\n  fromValues as protocolMessageFromValues,\r\n  stringify as stringifyProtocolMessage,\r\n} from '../types/protocolmessage';\r\nimport * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport ConnectionErrors from './connectionerrors';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Auth from '../client/auth';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport Platform from 'common/platform';\r\nimport TransportName from 'common/constants/TransportName';\r\n\r\nexport type TryConnectCallback = (\r\n  wrappedErr: { error: ErrorInfo; event: string } | null,\r\n  transport?: Transport,\r\n) => void;\r\n\r\nexport interface TransportCtor {\r\n  new (\r\n    connectionManager: ConnectionManager,\r\n    auth: Auth,\r\n    params: TransportParams,\r\n    forceJsonProtocol?: boolean,\r\n  ): Transport;\r\n\r\n  isAvailable(): boolean;\r\n}\r\n\r\nconst closeMessage = protocolMessageFromValues({ action: actions.CLOSE });\r\nconst disconnectMessage = protocolMessageFromValues({ action: actions.DISCONNECT });\r\n\r\n/*\r\n * Transport instances inherit from EventEmitter and emit the following events:\r\n *\r\n * event name       data\r\n * closed           error\r\n * failed           error\r\n * disposed\r\n * connected        null error, connectionSerial, connectionId, connectionDetails\r\n * event            channel message object\r\n */\r\n\r\nabstract class Transport extends EventEmitter {\r\n  connectionManager: ConnectionManager;\r\n  auth: Auth;\r\n  params: TransportParams;\r\n  timeouts: Record<string, number>;\r\n  format?: Utils.Format;\r\n  isConnected: boolean;\r\n  isFinished: boolean;\r\n  isDisposed: boolean;\r\n  maxIdleInterval: number | null;\r\n  idleTimer: NodeJS.Timeout | number | null;\r\n  lastActivity: number | null;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams, forceJsonProtocol?: boolean) {\r\n    super(connectionManager.logger);\r\n    if (forceJsonProtocol) {\r\n      params.format = undefined;\r\n      params.heartbeats = true;\r\n    }\r\n    this.connectionManager = connectionManager;\r\n    this.auth = auth;\r\n    this.params = params;\r\n    this.timeouts = params.options.timeouts;\r\n    this.format = params.format;\r\n    this.isConnected = false;\r\n    this.isFinished = false;\r\n    this.isDisposed = false;\r\n    this.maxIdleInterval = null;\r\n    this.idleTimer = null;\r\n    this.lastActivity = null;\r\n  }\r\n\r\n  abstract shortName: TransportName;\r\n  abstract send(message: ProtocolMessage): void;\r\n\r\n  connect(): void {}\r\n\r\n  close(): void {\r\n    if (this.isConnected) {\r\n      this.requestClose();\r\n    }\r\n    this.finish('closed', ConnectionErrors.closed());\r\n  }\r\n\r\n  disconnect(err?: Error | ErrorInfo): void {\r\n    /* Used for network/transport issues that need to result in the transport\r\n     * being disconnected, but should not transition the connection to 'failed' */\r\n    if (this.isConnected) {\r\n      this.requestDisconnect();\r\n    }\r\n    this.finish('disconnected', err || ConnectionErrors.disconnected());\r\n  }\r\n\r\n  fail(err: ErrorInfo): void {\r\n    /* Used for client-side-detected fatal connection issues */\r\n    if (this.isConnected) {\r\n      this.requestDisconnect();\r\n    }\r\n    this.finish('failed', err || ConnectionErrors.failed());\r\n  }\r\n\r\n  finish(event: string, err?: Error | ErrorInfo): void {\r\n    if (this.isFinished) {\r\n      return;\r\n    }\r\n\r\n    this.isFinished = true;\r\n    this.isConnected = false;\r\n    this.maxIdleInterval = null;\r\n    clearTimeout(this.idleTimer ?? undefined);\r\n    this.idleTimer = null;\r\n    this.emit(event, err);\r\n    this.dispose();\r\n  }\r\n\r\n  onProtocolMessage(message: ProtocolMessage): void {\r\n    if (this.logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logActionNoStrip(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'Transport.onProtocolMessage()',\r\n        'received on ' +\r\n          this.shortName +\r\n          ': ' +\r\n          stringifyProtocolMessage(message, this.connectionManager.realtime._RealtimePresence) +\r\n          '; connectionId = ' +\r\n          this.connectionManager.connectionId,\r\n      );\r\n    }\r\n    this.onActivity();\r\n\r\n    switch (message.action) {\r\n      case actions.HEARTBEAT:\r\n        Logger.logActionNoStrip(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          'Transport.onProtocolMessage()',\r\n          this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId,\r\n        );\r\n        this.emit('heartbeat', message.id);\r\n        break;\r\n      case actions.CONNECTED:\r\n        this.onConnect(message);\r\n        this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);\r\n        break;\r\n      case actions.CLOSED:\r\n        this.onClose(message);\r\n        break;\r\n      case actions.DISCONNECTED:\r\n        this.onDisconnect(message);\r\n        break;\r\n      case actions.ACK:\r\n        this.emit('ack', message.msgSerial, message.count);\r\n        break;\r\n      case actions.NACK:\r\n        this.emit('nack', message.msgSerial, message.count, message.error);\r\n        break;\r\n      case actions.SYNC:\r\n        this.connectionManager.onChannelMessage(message, this);\r\n        break;\r\n      case actions.ACTIVATE:\r\n        // Ignored.\r\n        break;\r\n      case actions.AUTH:\r\n        Utils.whenPromiseSettles(this.auth.authorize(), (err: ErrorInfo | null) => {\r\n          if (err) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_ERROR,\r\n              'Transport.onProtocolMessage()',\r\n              'Ably requested re-authentication, but unable to obtain a new token: ' + Utils.inspectError(err),\r\n            );\r\n          }\r\n        });\r\n        break;\r\n      case actions.ERROR:\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'Transport.onProtocolMessage()',\r\n          'received error action; connectionId = ' +\r\n            this.connectionManager.connectionId +\r\n            '; err = ' +\r\n            Platform.Config.inspect(message.error) +\r\n            (message.channel ? ', channel: ' + message.channel : ''),\r\n        );\r\n        if (message.channel === undefined) {\r\n          this.onFatalError(message);\r\n          break;\r\n        }\r\n        /* otherwise it's a channel-specific error, so handle it in the channel */\r\n        this.connectionManager.onChannelMessage(message, this);\r\n        break;\r\n      default:\r\n        /* all other actions are channel-specific */\r\n        this.connectionManager.onChannelMessage(message, this);\r\n    }\r\n  }\r\n\r\n  onConnect(message: ProtocolMessage): void {\r\n    this.isConnected = true;\r\n    if (!message.connectionDetails) {\r\n      throw new Error('Transport.onConnect(): Connect message recieved without connectionDetails');\r\n    }\r\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval as number;\r\n    if (maxPromisedIdle) {\r\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\r\n      this.onActivity();\r\n    }\r\n    /* else Realtime declines to guarantee any maximum idle interval - CD2h */\r\n  }\r\n\r\n  onDisconnect(message: ProtocolMessage): void {\r\n    /* Used for when the server has disconnected the client (usually with a\r\n     * DISCONNECTED action) */\r\n    const err = message && message.error;\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('disconnected', err);\r\n  }\r\n\r\n  onFatalError(message: ProtocolMessage): void {\r\n    /* On receipt of a fatal connection error, we can assume that the server\r\n     * will close the connection and the transport, and do not need to request\r\n     * a disconnection - RTN15i */\r\n    const err = message && message.error;\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.onFatalError()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('failed', err);\r\n  }\r\n\r\n  onClose(message: ProtocolMessage): void {\r\n    const err = message && message.error;\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.onClose()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('closed', err);\r\n  }\r\n\r\n  requestClose(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.requestClose()', '');\r\n    this.send(closeMessage);\r\n  }\r\n\r\n  requestDisconnect(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.requestDisconnect()', '');\r\n    this.send(disconnectMessage);\r\n  }\r\n\r\n  ping(id: string): void {\r\n    const msg: Record<string, number | string> = { action: actions.HEARTBEAT };\r\n    if (id) msg.id = id;\r\n    this.send(protocolMessageFromValues(msg));\r\n  }\r\n\r\n  dispose(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.dispose()', '');\r\n    this.isDisposed = true;\r\n    this.off();\r\n  }\r\n\r\n  onActivity(): void {\r\n    if (!this.maxIdleInterval) {\r\n      return;\r\n    }\r\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\r\n    this.setIdleTimer(this.maxIdleInterval + 100);\r\n  }\r\n\r\n  setIdleTimer(timeout: number): void {\r\n    if (!this.idleTimer) {\r\n      this.idleTimer = setTimeout(() => {\r\n        this.onIdleTimerExpire();\r\n      }, timeout);\r\n    }\r\n  }\r\n\r\n  onIdleTimerExpire(): void {\r\n    if (!this.lastActivity || !this.maxIdleInterval) {\r\n      throw new Error('Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set');\r\n    }\r\n    this.idleTimer = null;\r\n    const sinceLast = Date.now() - this.lastActivity;\r\n    const timeRemaining = this.maxIdleInterval - sinceLast;\r\n    if (timeRemaining <= 0) {\r\n      const msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);\r\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\r\n    } else {\r\n      this.setIdleTimer(timeRemaining + 100);\r\n    }\r\n  }\r\n\r\n  static tryConnect(\r\n    transportCtor: TransportCtor,\r\n    connectionManager: ConnectionManager,\r\n    auth: Auth,\r\n    transportParams: TransportParams,\r\n    callback: TryConnectCallback,\r\n  ): Transport {\r\n    const transport = new transportCtor(connectionManager, auth, transportParams);\r\n\r\n    let transportAttemptTimer: NodeJS.Timeout | number;\r\n\r\n    const errorCb = function (this: { event: string }, err: ErrorInfo) {\r\n      clearTimeout(transportAttemptTimer);\r\n      callback({ event: this.event, error: err });\r\n    };\r\n\r\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\r\n    transportAttemptTimer = setTimeout(() => {\r\n      transport.off(['preconnect', 'disconnected', 'failed']);\r\n      transport.dispose();\r\n      errorCb.call(\r\n        { event: 'disconnected' },\r\n        new ErrorInfo('Timeout waiting for transport to indicate itself viable', 50000, 500),\r\n      );\r\n    }, realtimeRequestTimeout);\r\n\r\n    transport.on(['failed', 'disconnected'], errorCb);\r\n    transport.on('preconnect', function () {\r\n      Logger.logAction(\r\n        connectionManager.logger,\r\n        Logger.LOG_MINOR,\r\n        'Transport.tryConnect()',\r\n        'viable transport ' + transport,\r\n      );\r\n      clearTimeout(transportAttemptTimer);\r\n      transport.off(['failed', 'disconnected'], errorCb);\r\n      callback(null, transport);\r\n    });\r\n    transport.connect();\r\n    return transport;\r\n  }\r\n\r\n  onAuthUpdated?: (tokenDetails: API.TokenDetails) => void;\r\n\r\n  static isAvailable(): boolean {\r\n    throw new ErrorInfo('isAvailable not implemented for transport', 50000, 500);\r\n  }\r\n}\r\n\r\nexport default Transport;\r\n", "export namespace TransportNames {\r\n  export const WebSocket = 'web_socket' as const;\r\n  export const Comet = 'comet' as const;\r\n  export const XhrPolling = 'xhr_polling' as const;\r\n}\r\n\r\ntype TransportName = typeof TransportNames.WebSocket | typeof TransportNames.Comet | typeof TransportNames.XhrPolling;\r\n\r\nexport default TransportName;\r\n", "import ProtocolMessage, {\r\n  actions,\r\n  stringify as stringifyProtocolMessage,\r\n  fromValues as protocolMessageFromValues,\r\n} from 'common/lib/types/protocolmessage';\r\nimport * as Utils from 'common/lib/util/utils';\r\nimport Protocol, { PendingMessage } from './protocol';\r\nimport Defaults, { getAgentString } from 'common/lib/util/defaults';\r\nimport Platform, { TransportImplementations } from 'common/platform';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport MessageQueue from './messagequeue';\r\nimport Logger from '../util/logger';\r\nimport ConnectionStateChange from 'common/lib/client/connectionstatechange';\r\nimport ConnectionErrors, { isRetriable } from './connectionerrors';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport Auth from 'common/lib/client/auth';\r\nimport Message, { getMessagesSize } from 'common/lib/types/message';\r\nimport Multicaster, { MulticasterInstance } from 'common/lib/util/multicaster';\r\nimport Transport, { TransportCtor } from './transport';\r\nimport * as API from '../../../../ably';\r\nimport { ErrCallback } from 'common/types/utils';\r\nimport HttpStatusCodes from 'common/constants/HttpStatusCodes';\r\nimport BaseRealtime from '../client/baserealtime';\r\nimport { NormalisedClientOptions } from 'common/types/ClientOptions';\r\nimport TransportName, { TransportNames } from 'common/constants/TransportName';\r\n\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nconst haveWebStorage = () => typeof Platform.WebStorage !== 'undefined' && Platform.WebStorage?.localSupported;\r\nconst haveSessionStorage = () => typeof Platform.WebStorage !== 'undefined' && Platform.WebStorage?.sessionSupported;\r\nconst noop = function () {};\r\nconst transportPreferenceName = 'ably-transport-preference';\r\n\r\nfunction bundleWith(dest: ProtocolMessage, src: ProtocolMessage, maxSize: number) {\r\n  let action;\r\n  if (dest.channel !== src.channel) {\r\n    /* RTL6d3 */\r\n    return false;\r\n  }\r\n  if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {\r\n    /* RTL6d - can only bundle messages or presence */\r\n    return false;\r\n  }\r\n  if (action !== src.action) {\r\n    /* RTL6d4 */\r\n    return false;\r\n  }\r\n  const kind = action === actions.PRESENCE ? 'presence' : 'messages',\r\n    proposed = (dest as Record<string, any>)[kind].concat((src as Record<string, any>)[kind]),\r\n    size = getMessagesSize(proposed);\r\n  if (size > maxSize) {\r\n    /* RTL6d1 */\r\n    return false;\r\n  }\r\n  if (!Utils.allSame(proposed, 'clientId')) {\r\n    /* RTL6d2 */\r\n    return false;\r\n  }\r\n  if (\r\n    !proposed.every(function (msg: Message) {\r\n      return !msg.id;\r\n    })\r\n  ) {\r\n    /* RTL6d7 */\r\n    return false;\r\n  }\r\n  /* we're good to go! */\r\n  (dest as Record<string, any>)[kind] = proposed;\r\n  return true;\r\n}\r\n\r\ntype RecoveryContext = {\r\n  connectionKey: string;\r\n  msgSerial: number;\r\n  channelSerials: { [name: string]: string };\r\n};\r\n\r\nfunction decodeRecoveryKey(recoveryKey: NormalisedClientOptions['recover']): RecoveryContext | null {\r\n  try {\r\n    return JSON.parse(recoveryKey as string);\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport class TransportParams {\r\n  options: NormalisedClientOptions;\r\n  host: string | null;\r\n  mode: string;\r\n  format?: Utils.Format;\r\n  connectionKey?: string;\r\n  stream?: any;\r\n  heartbeats?: boolean;\r\n\r\n  constructor(options: NormalisedClientOptions, host: string | null, mode: string, connectionKey?: string) {\r\n    this.options = options;\r\n    this.host = host;\r\n    this.mode = mode;\r\n    this.connectionKey = connectionKey;\r\n    this.format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\r\n  }\r\n\r\n  getConnectParams(authParams: Record<string, unknown>): Record<string, string> {\r\n    const params = authParams ? Utils.copy(authParams) : {};\r\n    const options = this.options;\r\n    switch (this.mode) {\r\n      case 'resume':\r\n        params.resume = this.connectionKey as string;\r\n        break;\r\n      case 'recover': {\r\n        const recoveryContext = decodeRecoveryKey(options.recover);\r\n        if (recoveryContext) {\r\n          params.recover = recoveryContext.connectionKey;\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n    }\r\n    if (options.clientId !== undefined) {\r\n      params.clientId = options.clientId;\r\n    }\r\n    if (options.echoMessages === false) {\r\n      params.echo = 'false';\r\n    }\r\n    if (this.format !== undefined) {\r\n      params.format = this.format;\r\n    }\r\n    if (this.stream !== undefined) {\r\n      params.stream = this.stream;\r\n    }\r\n    if (this.heartbeats !== undefined) {\r\n      params.heartbeats = this.heartbeats;\r\n    }\r\n    params.v = Defaults.protocolVersion;\r\n    params.agent = getAgentString(this.options);\r\n    if (options.transportParams !== undefined) {\r\n      Utils.mixin(params, options.transportParams);\r\n    }\r\n    return params as Record<string, string>;\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[mode=' + this.mode;\r\n    if (this.host) {\r\n      result += ',host=' + this.host;\r\n    }\r\n    if (this.connectionKey) {\r\n      result += ',connectionKey=' + this.connectionKey;\r\n    }\r\n    if (this.format) {\r\n      result += ',format=' + this.format;\r\n    }\r\n    result += ']';\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\ntype ConnectionState = {\r\n  state: string;\r\n  terminal?: boolean;\r\n  queueEvents?: boolean;\r\n  sendEvents?: boolean;\r\n  failState?: string;\r\n  retryDelay?: number;\r\n  retryImmediately?: boolean;\r\n  error?: IPartialErrorInfo;\r\n};\r\n\r\nclass ConnectionManager extends EventEmitter {\r\n  supportedTransports: Partial<Record<TransportName, TransportCtor>> = {};\r\n  realtime: BaseRealtime;\r\n  options: NormalisedClientOptions;\r\n  states: Record<string, ConnectionState>;\r\n  state: ConnectionState;\r\n  errorReason: IPartialErrorInfo | null;\r\n  queuedMessages: MessageQueue;\r\n  msgSerial: number;\r\n  connectionDetails?: Record<string, any>;\r\n  connectionId?: string;\r\n  connectionKey?: string;\r\n  connectionStateTtl: number;\r\n  maxIdleInterval: number | null;\r\n  transports: TransportName[];\r\n  baseTransport?: TransportName;\r\n  webSocketTransportAvailable?: true;\r\n  transportPreference: string | null;\r\n  httpHosts: string[];\r\n  wsHosts: string[];\r\n  activeProtocol: null | Protocol;\r\n  pendingTransport?: Transport;\r\n  proposedTransport?: Transport;\r\n  host: string | null;\r\n  lastAutoReconnectAttempt: number | null;\r\n  lastActivity: number | null;\r\n  forceFallbackHost: boolean;\r\n  transitionTimer?: number | NodeJS.Timeout | null;\r\n  suspendTimer?: number | NodeJS.Timeout | null;\r\n  retryTimer?: number | NodeJS.Timeout | null;\r\n  disconnectedRetryCount: number = 0;\r\n  pendingChannelMessagesState: {\r\n    // Whether a message is currently being processed\r\n    isProcessing: boolean;\r\n    // The messages remaining to be processed (excluding any message currently being processed)\r\n    queue: { message: ProtocolMessage; transport: Transport }[];\r\n  } = { isProcessing: false, queue: [] };\r\n  webSocketSlowTimer: NodeJS.Timeout | null;\r\n  wsCheckResult: boolean | null;\r\n  webSocketGiveUpTimer: NodeJS.Timeout | null;\r\n  abandonedWebSocket: boolean;\r\n  connectCounter: number;\r\n\r\n  constructor(realtime: BaseRealtime, options: NormalisedClientOptions) {\r\n    super(realtime.logger);\r\n    this.realtime = realtime;\r\n    this.initTransports();\r\n    this.options = options;\r\n    const timeouts = options.timeouts;\r\n    /* connectingTimeout: leave webSocketConnectTimeout (~6s) to try the\r\n     * websocket transport, then realtimeRequestTimeout (~10s) to establish\r\n     * the base transport in case that fails */\r\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\r\n    this.states = {\r\n      initialized: {\r\n        state: 'initialized',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        failState: 'disconnected',\r\n      },\r\n      connecting: {\r\n        state: 'connecting',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        retryDelay: connectingTimeout,\r\n        failState: 'disconnected',\r\n      },\r\n      connected: {\r\n        state: 'connected',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: true,\r\n        failState: 'disconnected',\r\n      },\r\n      disconnected: {\r\n        state: 'disconnected',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.disconnectedRetryTimeout,\r\n        failState: 'disconnected',\r\n      },\r\n      suspended: {\r\n        state: 'suspended',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.suspendedRetryTimeout,\r\n        failState: 'suspended',\r\n      },\r\n      closing: {\r\n        state: 'closing',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.realtimeRequestTimeout,\r\n        failState: 'closed',\r\n      },\r\n      closed: { state: 'closed', terminal: true, queueEvents: false, sendEvents: false, failState: 'closed' },\r\n      failed: { state: 'failed', terminal: true, queueEvents: false, sendEvents: false, failState: 'failed' },\r\n    };\r\n    this.state = this.states.initialized;\r\n    this.errorReason = null;\r\n\r\n    this.queuedMessages = new MessageQueue(this.logger);\r\n    this.msgSerial = 0;\r\n    this.connectionDetails = undefined;\r\n    this.connectionId = undefined;\r\n    this.connectionKey = undefined;\r\n    this.connectionStateTtl = timeouts.connectionStateTtl;\r\n    this.maxIdleInterval = null;\r\n\r\n    this.transports = Utils.intersect(options.transports || Defaults.defaultTransports, this.supportedTransports);\r\n    this.transportPreference = null;\r\n\r\n    if (this.transports.includes(TransportNames.WebSocket)) {\r\n      this.webSocketTransportAvailable = true;\r\n    }\r\n    if (this.transports.includes(TransportNames.XhrPolling)) {\r\n      this.baseTransport = TransportNames.XhrPolling;\r\n    } else if (this.transports.includes(TransportNames.Comet)) {\r\n      this.baseTransport = TransportNames.Comet;\r\n    }\r\n\r\n    this.httpHosts = Defaults.getHosts(options);\r\n    this.wsHosts = Defaults.getHosts(options, true);\r\n    this.activeProtocol = null;\r\n    this.host = null;\r\n    this.lastAutoReconnectAttempt = null;\r\n    this.lastActivity = null;\r\n    this.forceFallbackHost = false;\r\n    this.connectCounter = 0;\r\n    this.wsCheckResult = null;\r\n    this.webSocketSlowTimer = null;\r\n    this.webSocketGiveUpTimer = null;\r\n    this.abandonedWebSocket = false;\r\n\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime.ConnectionManager()', 'started');\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'Realtime.ConnectionManager()',\r\n      'requested transports = [' + (options.transports || Defaults.defaultTransports) + ']',\r\n    );\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'Realtime.ConnectionManager()',\r\n      'available transports = [' + this.transports + ']',\r\n    );\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'Realtime.ConnectionManager()',\r\n      'http hosts = [' + this.httpHosts + ']',\r\n    );\r\n\r\n    if (!this.transports.length) {\r\n      const msg = 'no requested transports available';\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'realtime.ConnectionManager()', msg);\r\n      throw new Error(msg);\r\n    }\r\n\r\n    const addEventListener = Platform.Config.addEventListener;\r\n    if (addEventListener) {\r\n      /* intercept close event in browser to persist connection id if requested */\r\n      if (haveSessionStorage() && typeof options.recover === 'function') {\r\n        addEventListener('beforeunload', this.persistConnection.bind(this));\r\n      }\r\n\r\n      if (options.closeOnUnload === true) {\r\n        addEventListener('beforeunload', () => {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MAJOR,\r\n            'Realtime.ConnectionManager()',\r\n            'beforeunload event has triggered the connection to close as closeOnUnload is true',\r\n          );\r\n          this.requestState({ state: 'closing' });\r\n        });\r\n      }\r\n\r\n      /* Listen for online and offline events */\r\n      addEventListener('online', () => {\r\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager caught browser \u2018online\u2019 event',\r\n            'reattempting connection',\r\n          );\r\n          this.requestState({ state: 'connecting' });\r\n        } else if (this.state == this.states.connecting) {\r\n          // RTN20c: if 'online' event recieved while CONNECTING, abandon connection attempt and retry\r\n          this.pendingTransport?.off();\r\n          this.disconnectAllTransports();\r\n\r\n          this.startConnect();\r\n        }\r\n      });\r\n\r\n      addEventListener('offline', () => {\r\n        if (this.state == this.states.connected) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager caught browser \u2018offline\u2019 event',\r\n            'disconnecting active transport',\r\n          );\r\n          // Not sufficient to just go to the 'disconnected' state, want to\r\n          // force all transports to reattempt the connection. Will immediately\r\n          // retry.\r\n          this.disconnectAllTransports();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /*********************\r\n   * transport management\r\n   *********************/\r\n\r\n  // Used by tests\r\n  static supportedTransports(additionalImplementations: TransportImplementations) {\r\n    const storage: TransportStorage = { supportedTransports: {} };\r\n    this.initTransports(additionalImplementations, storage);\r\n    return storage.supportedTransports;\r\n  }\r\n\r\n  private static initTransports(additionalImplementations: TransportImplementations, storage: TransportStorage) {\r\n    const implementations = { ...Platform.Transports.bundledImplementations, ...additionalImplementations };\r\n\r\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\r\n      const transport = implementations[transportName];\r\n      if (transport && transport.isAvailable()) {\r\n        storage.supportedTransports[transportName] = transport;\r\n      }\r\n    });\r\n  }\r\n\r\n  initTransports() {\r\n    ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\r\n  }\r\n\r\n  createTransportParams(host: string | null, mode: string): TransportParams {\r\n    return new TransportParams(this.options, host, mode, this.connectionKey);\r\n  }\r\n\r\n  getTransportParams(callback: Function): void {\r\n    const decideMode = (modeCb: Function) => {\r\n      if (this.connectionKey) {\r\n        modeCb('resume');\r\n        return;\r\n      }\r\n\r\n      if (typeof this.options.recover === 'string') {\r\n        modeCb('recover');\r\n        return;\r\n      }\r\n\r\n      const recoverFn = this.options.recover,\r\n        lastSessionData = this.getSessionRecoverData(),\r\n        sessionRecoveryName = this.sessionRecoveryName();\r\n      if (lastSessionData && typeof recoverFn === 'function') {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Calling clientOptions-provided recover function with last session data (recovery scope: ' +\r\n            sessionRecoveryName +\r\n            ')',\r\n        );\r\n        recoverFn(lastSessionData, (shouldRecover?: boolean) => {\r\n          if (shouldRecover) {\r\n            this.options.recover = lastSessionData.recoveryKey;\r\n            modeCb('recover');\r\n          } else {\r\n            modeCb('clean');\r\n          }\r\n        });\r\n        return;\r\n      }\r\n      modeCb('clean');\r\n    };\r\n\r\n    decideMode((mode: string) => {\r\n      const transportParams = this.createTransportParams(null, mode);\r\n      if (mode === 'recover') {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Transport recovery mode = recover; recoveryKey = ' + this.options.recover,\r\n        );\r\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\r\n        if (recoveryContext) {\r\n          this.msgSerial = recoveryContext.msgSerial;\r\n        }\r\n      } else {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Transport params = ' + transportParams.toString(),\r\n        );\r\n      }\r\n      callback(transportParams);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Attempt to connect using a given transport\r\n   * @param transportParams\r\n   * @param candidate, the transport to try\r\n   * @param callback\r\n   */\r\n  tryATransport(transportParams: TransportParams, candidate: TransportName, callback: Function): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);\r\n\r\n    this.proposedTransport = Transport.tryConnect(\r\n      this.supportedTransports[candidate]!,\r\n      this,\r\n      this.realtime.auth,\r\n      transportParams,\r\n      (wrappedErr: { error: ErrorInfo; event: string } | null, transport?: Transport) => {\r\n        const state = this.state;\r\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\r\n          if (transport) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager.tryATransport()',\r\n              'connection ' + state.state + ' while we were attempting the transport; closing ' + transport,\r\n            );\r\n            transport.close();\r\n          }\r\n          callback(true);\r\n          return;\r\n        }\r\n\r\n        if (wrappedErr) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager.tryATransport()',\r\n            'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString(),\r\n          );\r\n\r\n          /* Comet transport onconnect token errors can be dealt with here.\r\n           * Websocket ones only happen after the transport claims to be viable,\r\n           * so are dealt with as non-onconnect token errors */\r\n          if (\r\n            Auth.isTokenErr(wrappedErr.error) &&\r\n            !(this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo))\r\n          ) {\r\n            this.errorReason = wrappedErr.error;\r\n            /* re-get a token and try again */\r\n            Utils.whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err: ErrorInfo | null) => {\r\n              if (err) {\r\n                this.actOnErrorFromAuthorize(err);\r\n                return;\r\n              }\r\n              this.tryATransport(transportParams, candidate, callback);\r\n            });\r\n          } else if (wrappedErr.event === 'failed') {\r\n            /* Error that's fatal to the connection */\r\n            this.notifyState({ state: 'failed', error: wrappedErr.error });\r\n            callback(true);\r\n          } else if (wrappedErr.event === 'disconnected') {\r\n            if (!isRetriable(wrappedErr.error)) {\r\n              /* Error received from the server that does not call for trying a fallback host, eg a rate limit */\r\n              this.notifyState({ state: this.states.connecting.failState as string, error: wrappedErr.error });\r\n              callback(true);\r\n            } else {\r\n              /* Error with that transport only; continue trying other fallback hosts */\r\n              callback(false);\r\n            }\r\n          }\r\n          return;\r\n        }\r\n\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.tryATransport()',\r\n          'viable transport ' + candidate + '; setting pending',\r\n        );\r\n        this.setTransportPending(transport as Transport, transportParams);\r\n        callback(null, transport);\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is indicated to be viable, and the ConnectionManager\r\n   * expects to activate this transport as soon as it is connected.\r\n   * @param transport\r\n   * @param transportParams\r\n   */\r\n  setTransportPending(transport: Transport, transportParams: TransportParams): void {\r\n    const mode = transportParams.mode;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.setTransportPending()',\r\n      'transport = ' + transport + '; mode = ' + mode,\r\n    );\r\n\r\n    this.pendingTransport = transport;\r\n\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n\r\n    transport.once('connected', (error: ErrorInfo, connectionId: string, connectionDetails: Record<string, any>) => {\r\n      this.activateTransport(error, transport, connectionId, connectionDetails);\r\n\r\n      if (mode === 'recover' && this.options.recover) {\r\n        /* After a successful recovery, we unpersist, as a recovery key cannot\r\n         * be used more than once */\r\n        delete this.options.recover;\r\n        this.unpersistConnection();\r\n      }\r\n    });\r\n\r\n    const self = this;\r\n    transport.on(['disconnected', 'closed', 'failed'], function (this: { event: string }, error: ErrorInfo) {\r\n      self.deactivateTransport(transport, this.event, error);\r\n    });\r\n\r\n    this.emit('transport.pending', transport);\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is connected, and the connectionmanager decides that\r\n   * it will now be the active transport. Returns whether or not it activated\r\n   * the transport (if the connection is closing/closed it will choose not to).\r\n   * @param transport the transport instance\r\n   * @param connectionId the id of the new active connection\r\n   * @param connectionDetails the details of the new active connection\r\n   */\r\n  activateTransport(\r\n    error: ErrorInfo,\r\n    transport: Transport,\r\n    connectionId: string,\r\n    connectionDetails: Record<string, any>,\r\n  ): boolean {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.activateTransport()',\r\n      'transport = ' + transport,\r\n    );\r\n    if (error) {\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);\r\n    }\r\n    if (connectionId) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.activateTransport()',\r\n        'connectionId =  ' + connectionId,\r\n      );\r\n    }\r\n    if (connectionDetails) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.activateTransport()',\r\n        'connectionDetails =  ' + JSON.stringify(connectionDetails),\r\n      );\r\n    }\r\n\r\n    this.persistTransportPreference(transport);\r\n\r\n    /* if the connectionmanager moved to the closing/closed state before this\r\n     * connection event, then we won't activate this transport */\r\n    const existingState = this.state,\r\n      connectedState = this.states.connected.state;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.activateTransport()',\r\n      'current state = ' + existingState.state,\r\n    );\r\n    if (\r\n      existingState.state == this.states.closing.state ||\r\n      existingState.state == this.states.closed.state ||\r\n      existingState.state == this.states.failed.state\r\n    ) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.activateTransport()',\r\n        'Disconnecting transport and abandoning',\r\n      );\r\n      transport.disconnect();\r\n      return false;\r\n    }\r\n\r\n    delete this.pendingTransport;\r\n\r\n    /* if the transport is not connected then don't activate it */\r\n    if (!transport.isConnected) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.activateTransport()',\r\n        'Declining to activate transport ' + transport + ' since it appears to no longer be connected',\r\n      );\r\n      return false;\r\n    }\r\n\r\n    /* the given transport is connected; this will immediately\r\n     * take over as the active transport */\r\n    const existingActiveProtocol = this.activeProtocol;\r\n    this.activeProtocol = new Protocol(transport);\r\n    this.host = transport.params.host;\r\n\r\n    const connectionKey = connectionDetails.connectionKey;\r\n    if (connectionKey && this.connectionKey != connectionKey) {\r\n      this.setConnection(connectionId, connectionDetails, !!error);\r\n    }\r\n\r\n    /* Rebroadcast any new connectionDetails from the active transport, which\r\n     * can come at any time (eg following a reauth), and emit an RTN24 UPDATE\r\n     * event. (Listener added on nextTick because we're in a transport.on('connected')\r\n     * callback at the moment; if we add it now we'll be adding it to the end\r\n     * of the listeners array and it'll be called immediately) */\r\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\r\n    Platform.Config.nextTick(() => {\r\n      transport.on(\r\n        'connected',\r\n        (connectedErr: ErrorInfo, _connectionId: string, connectionDetails: Record<string, any>) => {\r\n          this.onConnectionDetailsUpdate(connectionDetails, transport);\r\n          this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, connectedErr));\r\n        },\r\n      );\r\n    });\r\n\r\n    /* If previously not connected, notify the state change (including any\r\n     * error). */\r\n    if (existingState.state === this.states.connected.state) {\r\n      if (error) {\r\n        this.errorReason = this.realtime.connection.errorReason = error;\r\n        this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, error));\r\n      }\r\n    } else {\r\n      this.notifyState({ state: 'connected', error: error });\r\n      this.errorReason = this.realtime.connection.errorReason = error || null;\r\n    }\r\n\r\n    /* Send after the connection state update, as Channels hooks into this to\r\n     * resend attaches on a new transport if necessary */\r\n    this.emit('transport.active', transport);\r\n\r\n    /* Gracefully terminate existing protocol */\r\n    if (existingActiveProtocol) {\r\n      if (existingActiveProtocol.messageQueue.count() > 0) {\r\n        /* We could just requeue pending messages on the new transport, but\r\n         * actually this should never happen: transports should only take over\r\n         * from other active transports when upgrading, and upgrading waits for\r\n         * the old transport to be idle. So log an error. */\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_ERROR,\r\n          'ConnectionManager.activateTransport()',\r\n          'Previous active protocol (for transport ' +\r\n            existingActiveProtocol.transport.shortName +\r\n            ', new one is ' +\r\n            transport.shortName +\r\n            ') finishing with ' +\r\n            existingActiveProtocol.messageQueue.count() +\r\n            ' messages still pending',\r\n        );\r\n      }\r\n      if (existingActiveProtocol.transport === transport) {\r\n        const msg =\r\n          'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' +\r\n          transport.shortName +\r\n          '; stack = ' +\r\n          new Error().stack;\r\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);\r\n      } else {\r\n        existingActiveProtocol.finish();\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is no longer the active transport. This can occur\r\n   * in any transport connection state.\r\n   * @param transport\r\n   */\r\n  deactivateTransport(transport: Transport, state: string, error: ErrorInfo): void {\r\n    const currentProtocol = this.activeProtocol,\r\n      wasActive = currentProtocol && currentProtocol.getTransport() === transport,\r\n      wasPending = transport === this.pendingTransport,\r\n      noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\r\n\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.deactivateTransport()',\r\n      'transport = ' + transport,\r\n    );\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.deactivateTransport()',\r\n      'state = ' +\r\n        state +\r\n        (wasActive ? '; was active' : wasPending ? '; was pending' : '') +\r\n        (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'),\r\n    );\r\n    if (error && error.message)\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.deactivateTransport()',\r\n        'reason =  ' + error.message,\r\n      );\r\n\r\n    if (wasActive) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.deactivateTransport()',\r\n        'Getting, clearing, and requeuing ' +\r\n          (this.activeProtocol as Protocol).messageQueue.count() +\r\n          ' pending messages',\r\n      );\r\n      this.queuePendingMessages((currentProtocol as Protocol).getPendingMessages());\r\n      /* Clear any messages we requeue to allow the protocol to become idle.*/\r\n      (currentProtocol as Protocol).clearPendingMessages();\r\n      this.activeProtocol = this.host = null;\r\n    }\r\n\r\n    this.emit('transport.inactive', transport);\r\n\r\n    /* this transport state change is a state change for the connectionmanager if\r\n     * - the transport was the active transport and there are no transports\r\n     *   which are connected and scheduled for activation, just waiting for the\r\n     *   active transport to finish what its doing; or\r\n     * - the transport was the active transport and the error was fatal (so\r\n     *   unhealable by another transport); or\r\n     * - there is no active transport, and this is the last remaining\r\n     *   pending transport (so we were in the connecting state)\r\n     */\r\n    if (\r\n      (wasActive && noTransportsScheduledForActivation) ||\r\n      (wasActive && state === 'failed') ||\r\n      state === 'closed' ||\r\n      (currentProtocol === null && wasPending)\r\n    ) {\r\n      /* If we're disconnected with a 5xx we need to try fallback hosts\r\n       * (RTN14d), but (a) due to how the upgrade sequence works, the\r\n       * host/transport selection sequence only cares about getting to\r\n       * `preconnect` (eg establishing a websocket) getting a `disconnected`\r\n       * protocol message afterwards is too late; and (b) host retry only\r\n       * applies to connectBase unless the stored preference transport doesn't\r\n       * work. We solve this by unpersisting the transport preference and\r\n       * setting an instance variable to force fallback hosts to be used (if\r\n       * any) here. Bit of a kludge, but no real better alternatives without\r\n       * rewriting the entire thing */\r\n      if (state === 'disconnected' && error && (error.statusCode as number) > 500 && this.httpHosts.length > 1) {\r\n        this.unpersistTransportPreference();\r\n        this.forceFallbackHost = true;\r\n        /* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */\r\n        this.notifyState({ state: state, error: error, retryImmediately: true });\r\n        return;\r\n      }\r\n\r\n      /* TODO remove below line once realtime sends token errors as DISCONNECTEDs */\r\n      const newConnectionState = state === 'failed' && Auth.isTokenErr(error) ? 'disconnected' : state;\r\n      this.notifyState({ state: newConnectionState, error: error });\r\n      return;\r\n    }\r\n  }\r\n\r\n  /* Helper that returns true if there are no transports which are pending,\r\n   * have been connected, and are just waiting for onceNoPending to fire before\r\n   * being activated */\r\n  noTransportsScheduledForActivation(): boolean {\r\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\r\n  }\r\n\r\n  setConnection(connectionId: string, connectionDetails: Record<string, any>, hasConnectionError?: boolean): void {\r\n    /* if connectionKey changes but connectionId stays the same, then just a\r\n     * transport change on the same connection. If connectionId changes, we're\r\n     * on a new connection, with implications for msgSerial and channel state */\r\n    /* If no previous connectionId, don't reset the msgSerial as it may have\r\n     * been set by recover data (unless the recover failed) */\r\n    const prevConnId = this.connectionId,\r\n      connIdChanged = prevConnId && prevConnId !== connectionId,\r\n      recoverFailure = !prevConnId && hasConnectionError;\r\n    if (connIdChanged || recoverFailure) {\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');\r\n      this.msgSerial = 0;\r\n      // RTN19a2: In the event of a new connectionId, previous msgSerials are\r\n      // meaningless.\r\n      this.queuedMessages.resetSendAttempted();\r\n    }\r\n    if (this.connectionId !== connectionId) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.setConnection()',\r\n        'New connectionId; reattaching any attached channels',\r\n      );\r\n    }\r\n    this.realtime.connection.id = this.connectionId = connectionId;\r\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\r\n  }\r\n\r\n  clearConnection(): void {\r\n    this.realtime.connection.id = this.connectionId = undefined;\r\n    this.realtime.connection.key = this.connectionKey = undefined;\r\n    this.msgSerial = 0;\r\n    this.unpersistConnection();\r\n  }\r\n\r\n  createRecoveryKey(): string | null {\r\n    // RTN16g2.\r\n    if (!this.connectionKey) {\r\n      return null;\r\n    }\r\n\r\n    return JSON.stringify({\r\n      connectionKey: this.connectionKey,\r\n      msgSerial: this.msgSerial,\r\n      channelSerials: this.realtime.channels.channelSerials(),\r\n    });\r\n  }\r\n\r\n  checkConnectionStateFreshness(): void {\r\n    if (!this.lastActivity || !this.connectionId) {\r\n      return;\r\n    }\r\n\r\n    const sinceLast = Date.now() - this.lastActivity;\r\n    if (sinceLast > this.connectionStateTtl + (this.maxIdleInterval as number)) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.checkConnectionStateFreshness()',\r\n        'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state',\r\n      );\r\n      this.clearConnection();\r\n      this.states.connecting.failState = 'suspended';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the connectionmanager wants to persist transport\r\n   * state for later recovery. Only applicable in the browser context.\r\n   */\r\n  persistConnection(): void {\r\n    if (haveSessionStorage()) {\r\n      const recoveryKey = this.createRecoveryKey();\r\n      if (recoveryKey) {\r\n        this.setSessionRecoverData({\r\n          recoveryKey: recoveryKey,\r\n          disconnectedAt: Date.now(),\r\n          location: globalObject.location,\r\n          clientId: this.realtime.auth.clientId,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the connectionmanager wants to persist transport\r\n   * state for later recovery. Only applicable in the browser context.\r\n   */\r\n  unpersistConnection(): void {\r\n    this.clearSessionRecoverData();\r\n  }\r\n\r\n  /*********************\r\n   * state management\r\n   *********************/\r\n\r\n  getError(): IPartialErrorInfo | string {\r\n    if (this.errorReason) {\r\n      // create new PartialErrorInfo so it has the correct stack trace\r\n      // which points to the place which caused us to return this error.\r\n      const newError = PartialErrorInfo.fromValues(this.errorReason);\r\n      newError.cause = this.errorReason;\r\n      return newError;\r\n    }\r\n\r\n    return this.getStateError();\r\n  }\r\n\r\n  getStateError(): ErrorInfo {\r\n    return (ConnectionErrors as Record<string, () => ErrorInfo>)[this.state.state]?.();\r\n  }\r\n\r\n  activeState(): boolean | void {\r\n    return this.state.queueEvents || this.state.sendEvents;\r\n  }\r\n\r\n  enactStateChange(stateChange: ConnectionStateChange): void {\r\n    const action = 'Connection state';\r\n    const message = stateChange.current + (stateChange.reason ? '; reason: ' + stateChange.reason : '');\r\n    if (stateChange.current === 'failed') {\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, action, message);\r\n    } else {\r\n      Logger.logAction(this.logger, Logger.LOG_MAJOR, action, message);\r\n    }\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.enactStateChange',\r\n      'setting new state: ' +\r\n        stateChange.current +\r\n        '; reason = ' +\r\n        (stateChange.reason && (stateChange.reason as ErrorInfo).message),\r\n    );\r\n    const newState = (this.state = this.states[stateChange.current as string]);\r\n    if (stateChange.reason) {\r\n      this.errorReason = stateChange.reason;\r\n      // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405\r\n      this.realtime.connection.errorReason = stateChange.reason as ErrorInfo;\r\n    }\r\n    if (newState.terminal || newState.state === 'suspended') {\r\n      /* suspended is nonterminal, but once in the suspended state, realtime\r\n       * will have discarded our connection state, so futher connection\r\n       * attempts should start from scratch */\r\n      this.clearConnection();\r\n    }\r\n    this.emit('connectionstate', stateChange);\r\n  }\r\n\r\n  /****************************************\r\n   * ConnectionManager connection lifecycle\r\n   ****************************************/\r\n\r\n  startTransitionTimer(transitionState: ConnectionState): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.startTransitionTimer()',\r\n      'transitionState: ' + transitionState.state,\r\n    );\r\n\r\n    if (this.transitionTimer) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.startTransitionTimer()',\r\n        'clearing already-running timer',\r\n      );\r\n      clearTimeout(this.transitionTimer as number);\r\n    }\r\n\r\n    this.transitionTimer = setTimeout(() => {\r\n      if (this.transitionTimer) {\r\n        this.transitionTimer = null;\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager ' + transitionState.state + ' timer expired',\r\n          'requesting new state: ' + transitionState.failState,\r\n        );\r\n        this.notifyState({ state: transitionState.failState as string });\r\n      }\r\n    }, transitionState.retryDelay);\r\n  }\r\n\r\n  cancelTransitionTimer(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');\r\n    if (this.transitionTimer) {\r\n      clearTimeout(this.transitionTimer as number);\r\n      this.transitionTimer = null;\r\n    }\r\n  }\r\n\r\n  startSuspendTimer(): void {\r\n    if (this.suspendTimer) return;\r\n    this.suspendTimer = setTimeout(() => {\r\n      if (this.suspendTimer) {\r\n        this.suspendTimer = null;\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager suspend timer expired',\r\n          'requesting new state: suspended',\r\n        );\r\n        this.states.connecting.failState = 'suspended';\r\n        this.notifyState({ state: 'suspended' });\r\n      }\r\n    }, this.connectionStateTtl);\r\n  }\r\n\r\n  checkSuspendTimer(state: string): void {\r\n    if (state !== 'disconnected' && state !== 'suspended' && state !== 'connecting') this.cancelSuspendTimer();\r\n  }\r\n\r\n  cancelSuspendTimer(): void {\r\n    this.states.connecting.failState = 'disconnected';\r\n    if (this.suspendTimer) {\r\n      clearTimeout(this.suspendTimer as number);\r\n      this.suspendTimer = null;\r\n    }\r\n  }\r\n\r\n  startRetryTimer(interval: number): void {\r\n    this.retryTimer = setTimeout(() => {\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');\r\n      this.retryTimer = null;\r\n      this.requestState({ state: 'connecting' });\r\n    }, interval);\r\n  }\r\n\r\n  cancelRetryTimer(): void {\r\n    if (this.retryTimer) {\r\n      clearTimeout(this.retryTimer as NodeJS.Timeout);\r\n      this.retryTimer = null;\r\n    }\r\n  }\r\n\r\n  startWebSocketSlowTimer() {\r\n    this.webSocketSlowTimer = setTimeout(() => {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager WebSocket slow timer',\r\n        'checking connectivity',\r\n      );\r\n      if (this.wsCheckResult === null) {\r\n        this.checkWsConnectivity()\r\n          .then(() => {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'ws connectivity check succeeded',\r\n            );\r\n            this.wsCheckResult = true;\r\n          })\r\n          .catch(() => {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MAJOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'ws connectivity check failed',\r\n            );\r\n            this.wsCheckResult = false;\r\n          });\r\n      }\r\n      if (this.realtime.http.checkConnectivity) {\r\n        Utils.whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\r\n          if (err || !connectivity) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MAJOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'http connectivity check failed',\r\n            );\r\n            this.cancelWebSocketGiveUpTimer();\r\n            this.notifyState({\r\n              state: 'disconnected',\r\n              error: new ErrorInfo('Unable to connect (network unreachable)', 80003, 404),\r\n            });\r\n          } else {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'http connectivity check succeeded',\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }, this.options.timeouts.webSocketSlowTimeout);\r\n  }\r\n\r\n  cancelWebSocketSlowTimer() {\r\n    if (this.webSocketSlowTimer) {\r\n      clearTimeout(this.webSocketSlowTimer);\r\n      this.webSocketSlowTimer = null;\r\n    }\r\n  }\r\n\r\n  startWebSocketGiveUpTimer(transportParams: TransportParams) {\r\n    this.webSocketGiveUpTimer = setTimeout(() => {\r\n      if (!this.wsCheckResult) {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager WebSocket give up timer',\r\n          'websocket connection took more than 10s; ' + (this.baseTransport ? 'trying base transport' : ''),\r\n        );\r\n        if (this.baseTransport) {\r\n          this.abandonedWebSocket = true;\r\n          this.proposedTransport?.dispose();\r\n          this.pendingTransport?.dispose();\r\n          this.connectBase(transportParams, ++this.connectCounter);\r\n        } else {\r\n          // if we don't have a base transport to fallback to, just let the websocket connection attempt time out\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MAJOR,\r\n            'ConnectionManager WebSocket give up timer',\r\n            'websocket connectivity appears to be unavailable but no other transports to try',\r\n          );\r\n        }\r\n      }\r\n    }, this.options.timeouts.webSocketConnectTimeout);\r\n  }\r\n\r\n  cancelWebSocketGiveUpTimer() {\r\n    if (this.webSocketGiveUpTimer) {\r\n      clearTimeout(this.webSocketGiveUpTimer);\r\n      this.webSocketGiveUpTimer = null;\r\n    }\r\n  }\r\n\r\n  notifyState(indicated: ConnectionState): void {\r\n    const state = indicated.state;\r\n\r\n    /* We retry immediately if:\r\n     * - something disconnects us while we're connected, or\r\n     * - a viable (but not yet active) transport fails due to a token error (so\r\n     *   this.errorReason will be set, and startConnect will do a forced\r\n     *   authorize). If this.errorReason is already set (to a token error),\r\n     *   then there has been at least one previous attempt to connect that also\r\n     *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait\r\n     *   before trying again */\r\n    const retryImmediately =\r\n      state === 'disconnected' &&\r\n      (this.state === this.states.connected ||\r\n        indicated.retryImmediately ||\r\n        (this.state === this.states.connecting &&\r\n          indicated.error &&\r\n          Auth.isTokenErr(indicated.error) &&\r\n          !(this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo))));\r\n\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.notifyState()',\r\n      'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''),\r\n    );\r\n    /* do nothing if we're already in the indicated state */\r\n    if (state == this.state.state) return;\r\n\r\n    /* kill timers (possibly excepting suspend timer depending on the notified\r\n     * state), as these are superseded by this notification */\r\n    this.cancelTransitionTimer();\r\n    this.cancelRetryTimer();\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n    this.checkSuspendTimer(indicated.state);\r\n\r\n    if (state === 'suspended' || state === 'connected') {\r\n      this.disconnectedRetryCount = 0;\r\n    }\r\n\r\n    /* do nothing if we're unable to move from the current state */\r\n    if (this.state.terminal) return;\r\n\r\n    /* process new state */\r\n    const newState = this.states[indicated.state];\r\n\r\n    let retryDelay = newState.retryDelay;\r\n    if (newState.state === 'disconnected') {\r\n      this.disconnectedRetryCount++;\r\n      retryDelay = Utils.getRetryTime(newState.retryDelay as number, this.disconnectedRetryCount);\r\n    }\r\n\r\n    const change = new ConnectionStateChange(\r\n      this.state.state,\r\n      newState.state,\r\n      retryDelay,\r\n      indicated.error || (ConnectionErrors as Partial<Record<string, () => ErrorInfo>>)[newState.state]?.(),\r\n    );\r\n\r\n    if (retryImmediately) {\r\n      const autoReconnect = () => {\r\n        if (this.state === this.states.disconnected) {\r\n          this.lastAutoReconnectAttempt = Date.now();\r\n          this.requestState({ state: 'connecting' });\r\n        }\r\n      };\r\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\r\n      if (sinceLast && sinceLast < 1000) {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.notifyState()',\r\n          'Last reconnect attempt was only ' +\r\n            sinceLast +\r\n            'ms ago, waiting another ' +\r\n            (1000 - sinceLast) +\r\n            'ms before trying again',\r\n        );\r\n        setTimeout(autoReconnect, 1000 - sinceLast);\r\n      } else {\r\n        Platform.Config.nextTick(autoReconnect);\r\n      }\r\n    } else if (state === 'disconnected' || state === 'suspended') {\r\n      this.startRetryTimer(retryDelay as number);\r\n    }\r\n\r\n    /* If going into disconnect/suspended (and not retrying immediately), or a\r\n     * terminal state, ensure there are no orphaned transports hanging around. */\r\n    if ((state === 'disconnected' && !retryImmediately) || state === 'suspended' || newState.terminal) {\r\n      /* Wait till the next tick so the connection state change is enacted,\r\n       * so aborting transports doesn't trigger redundant state changes */\r\n      Platform.Config.nextTick(() => {\r\n        this.disconnectAllTransports();\r\n      });\r\n    }\r\n\r\n    if (state == 'connected' && !this.activeProtocol) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.notifyState()',\r\n        'Broken invariant: attempted to go into connected state, but there is no active protocol',\r\n      );\r\n    }\r\n\r\n    /* implement the change and notify */\r\n    this.enactStateChange(change);\r\n    if (this.state.sendEvents) {\r\n      this.sendQueuedMessages();\r\n    } else if (!this.state.queueEvents) {\r\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\r\n      this.failQueuedMessages(change.reason as ErrorInfo); // RTN7c\r\n    }\r\n  }\r\n\r\n  requestState(request: any): void {\r\n    const state = request.state;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.requestState()',\r\n      'requested state: ' + state + '; current state: ' + this.state.state,\r\n    );\r\n    if (state == this.state.state) return; /* silently do nothing */\r\n\r\n    /* kill running timers, as this request supersedes them */\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n    this.cancelTransitionTimer();\r\n    this.cancelRetryTimer();\r\n    /* for suspend timer check rather than cancel -- eg requesting a connecting\r\n     * state should not reset the suspend timer */\r\n    this.checkSuspendTimer(state);\r\n\r\n    if (state == 'connecting' && this.state.state == 'connected') return;\r\n    if (state == 'closing' && this.state.state == 'closed') return;\r\n\r\n    const newState = this.states[state],\r\n      change = new ConnectionStateChange(\r\n        this.state.state,\r\n        newState.state,\r\n        null,\r\n        request.error || (ConnectionErrors as Partial<Record<string, () => ErrorInfo>>)[newState.state]?.(),\r\n      );\r\n\r\n    this.enactStateChange(change);\r\n\r\n    if (state == 'connecting') {\r\n      Platform.Config.nextTick(() => {\r\n        this.startConnect();\r\n      });\r\n    }\r\n    if (state == 'closing') {\r\n      this.closeImpl();\r\n    }\r\n  }\r\n\r\n  startConnect(): void {\r\n    if (this.state !== this.states.connecting) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.startConnect()',\r\n        'Must be in connecting state to connect, but was ' + this.state.state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    const auth = this.realtime.auth;\r\n\r\n    /* The point of the connectCounter mechanism is to ensure that the\r\n     * connection procedure can be cancelled. We want disconnectAllTransports\r\n     * to be able to stop any in-progress connection, even before it gets to\r\n     * the stage of having a pending (or even a proposed) transport that it can\r\n     * dispose() of. So we check that it's still current after any async stage,\r\n     * up until the stage that is synchronous with instantiating a transport */\r\n    const connectCount = ++this.connectCounter;\r\n\r\n    const connect = () => {\r\n      this.checkConnectionStateFreshness();\r\n      this.getTransportParams((transportParams: TransportParams) => {\r\n        if (transportParams.mode === 'recover' && transportParams.options.recover) {\r\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\r\n          if (recoveryContext) {\r\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\r\n          }\r\n        }\r\n\r\n        if (connectCount !== this.connectCounter) {\r\n          return;\r\n        }\r\n        this.connectImpl(transportParams, connectCount);\r\n      });\r\n    };\r\n\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');\r\n    this.startSuspendTimer();\r\n    this.startTransitionTimer(this.states.connecting);\r\n\r\n    if (auth.method === 'basic') {\r\n      connect();\r\n    } else {\r\n      const authCb = (err: ErrorInfo | null) => {\r\n        if (connectCount !== this.connectCounter) {\r\n          return;\r\n        }\r\n        if (err) {\r\n          this.actOnErrorFromAuthorize(err);\r\n        } else {\r\n          connect();\r\n        }\r\n      };\r\n      if (this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo)) {\r\n        /* Force a refetch of a new token */\r\n        Utils.whenPromiseSettles(auth._forceNewToken(null, null), authCb);\r\n      } else {\r\n        Utils.whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n   * there are, at most, two transports available with which a connection may\r\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\r\n   * comet in nodejs). web_socket is always preferred, and the base transport is\r\n   * only used in case web_socket connectivity appears to be unavailable.\r\n   *\r\n   * connectImpl begins the transport selection process by checking which transports\r\n   * are available, and if there is a cached preference. It then defers to the\r\n   * transport-specific connect methods: connectWs and connectBase.\r\n   *\r\n   * It is also responsible for invalidating the cache in the case that a base\r\n   * transport preference is stored but web socket connectivity is now available.\r\n   *\r\n   * handling of the case where we need to failover from web_socket to the base\r\n   * transport is implemented in the connectWs method.\r\n   */\r\n  connectImpl(transportParams: TransportParams, connectCount: number): void {\r\n    const state = this.state.state;\r\n    if (state !== this.states.connecting.state) {\r\n      /* Only keep trying as long as in the 'connecting' state (or 'connected'\r\n       * for upgrading). Any operation can put us into 'disconnected' to cancel\r\n       * connection attempts and wait before retrying, or 'failed' to fail. */\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.connectImpl()',\r\n        'Must be in connecting state to connect, but was ' + state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    const transportPreference = this.getTransportPreference();\r\n\r\n    // If transport preference is for a non-ws transport but websocket is now available, unpersist the preference for next time\r\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\r\n      this.checkWsConnectivity()\r\n        .then(() => {\r\n          this.wsCheckResult = true;\r\n          this.abandonedWebSocket = false;\r\n          this.unpersistTransportPreference();\r\n          if (this.state === this.states.connecting) {\r\n            Logger.logAction(\r\n              this.logger,\r\n\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager.connectImpl():',\r\n              'web socket connectivity available, cancelling connection attempt with ' + this.baseTransport,\r\n            );\r\n            this.disconnectAllTransports();\r\n            this.connectWs(transportParams, ++this.connectCounter);\r\n          }\r\n        })\r\n        .catch(noop);\r\n    }\r\n\r\n    if (\r\n      (transportPreference && transportPreference === this.baseTransport) ||\r\n      (this.baseTransport && !this.webSocketTransportAvailable)\r\n    ) {\r\n      this.connectBase(transportParams, connectCount);\r\n    } else {\r\n      this.connectWs(transportParams, connectCount);\r\n    }\r\n  }\r\n\r\n  /*\r\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\r\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\r\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\r\n   *   connectivity check fails, we give up the connection sequence entirely and\r\n   *   transition to disconnected. if the websocket connectivity check fails then\r\n   *   we assume no ws connectivity and failover to base transport. in the case that\r\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\r\n   *   and, if unsuccessful, ultimately transition to disconnected.\r\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\r\n   *   connectivity check is still pending then we assume that there is an issue\r\n   *   with the transport and fallback to base transport.\r\n   */\r\n  connectWs(transportParams: TransportParams, connectCount: number) {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.connectWs()');\r\n    this.startWebSocketSlowTimer();\r\n    this.startWebSocketGiveUpTimer(transportParams);\r\n\r\n    this.tryTransportWithFallbacks('web_socket', transportParams, true, connectCount, () => {\r\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\r\n    });\r\n  }\r\n\r\n  connectBase(transportParams: TransportParams, connectCount: number) {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.connectBase()');\r\n    if (this.baseTransport) {\r\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\r\n    } else {\r\n      this.notifyState({\r\n        state: 'disconnected',\r\n        error: new ErrorInfo('No transports left to try', 80000, 404),\r\n      });\r\n    }\r\n  }\r\n\r\n  tryTransportWithFallbacks(\r\n    transportName: TransportName,\r\n    transportParams: TransportParams,\r\n    ws: boolean,\r\n    connectCount: number,\r\n    shouldContinue: () => boolean,\r\n  ): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n\r\n      Logger.LOG_MICRO,\r\n      'ConnectionManager.tryTransportWithFallbacks()',\r\n      transportName,\r\n    );\r\n    const giveUp = (err: IPartialErrorInfo) => {\r\n      this.notifyState({ state: this.states.connecting.failState as string, error: err });\r\n    };\r\n\r\n    const candidateHosts = ws ? this.wsHosts.slice() : this.httpHosts.slice();\r\n\r\n    const hostAttemptCb = (fatal: boolean, transport: Transport) => {\r\n      if (connectCount !== this.connectCounter) {\r\n        return;\r\n      }\r\n      if (!shouldContinue()) {\r\n        if (transport) {\r\n          transport.dispose();\r\n        }\r\n        return;\r\n      }\r\n      if (!transport && !fatal) {\r\n        tryFallbackHosts();\r\n      }\r\n    };\r\n\r\n    /* first try to establish a connection with the priority host with http transport */\r\n    const host = candidateHosts.shift();\r\n    if (!host) {\r\n      giveUp(new ErrorInfo('Unable to connect (no available host)', 80003, 404));\r\n      return;\r\n    }\r\n    transportParams.host = host;\r\n\r\n    /* this is what we'll be doing if the attempt for the main host fails */\r\n    const tryFallbackHosts = () => {\r\n      /* if there aren't any fallback hosts, fail */\r\n      if (!candidateHosts.length) {\r\n        giveUp(new ErrorInfo('Unable to connect (and no more fallback hosts to try)', 80003, 404));\r\n        return;\r\n      }\r\n      /* before trying any fallback (or any remaining fallback) we decide if\r\n       * there is a problem with the ably host, or there is a general connectivity\r\n       * problem */\r\n      if (!this.realtime.http.checkConnectivity) {\r\n        giveUp(new PartialErrorInfo('Internal error: Http.checkConnectivity not set', null, 500));\r\n        return;\r\n      }\r\n      Utils.whenPromiseSettles(\r\n        this.realtime.http.checkConnectivity(),\r\n        (err?: ErrorInfo | null, connectivity?: boolean) => {\r\n          if (connectCount !== this.connectCounter) {\r\n            return;\r\n          }\r\n          if (!shouldContinue()) {\r\n            return;\r\n          }\r\n          /* we know err won't happen but handle it here anyway */\r\n          if (err) {\r\n            giveUp(err);\r\n            return;\r\n          }\r\n          if (!connectivity) {\r\n            /* the internet isn't reachable, so don't try the fallback hosts */\r\n            giveUp(new ErrorInfo('Unable to connect (network unreachable)', 80003, 404));\r\n            return;\r\n          }\r\n          /* the network is there, so there's a problem with the main host, or\r\n           * its dns. Try the fallback hosts. We could try them simultaneously but\r\n           * that would potentially cause a huge spike in load on the load balancer */\r\n          transportParams.host = Utils.arrPopRandomElement(candidateHosts);\r\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\r\n        },\r\n      );\r\n    };\r\n\r\n    if (this.forceFallbackHost && candidateHosts.length) {\r\n      this.forceFallbackHost = false;\r\n      tryFallbackHosts();\r\n      return;\r\n    }\r\n\r\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\r\n  }\r\n\r\n  closeImpl(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');\r\n    this.cancelSuspendTimer();\r\n    this.startTransitionTimer(this.states.closing);\r\n\r\n    if (this.pendingTransport) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.closeImpl()',\r\n        'Closing pending transport: ' + this.pendingTransport,\r\n      );\r\n      this.pendingTransport.close();\r\n    }\r\n\r\n    if (this.activeProtocol) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.closeImpl()',\r\n        'Closing active transport: ' + this.activeProtocol.getTransport(),\r\n      );\r\n      this.activeProtocol.getTransport().close();\r\n    }\r\n\r\n    /* If there was an active transport, this will probably be\r\n     * preempted by the notifyState call in deactivateTransport */\r\n    this.notifyState({ state: 'closed' });\r\n  }\r\n\r\n  onAuthUpdated(tokenDetails: API.TokenDetails, callback: Function): void {\r\n    switch (this.state.state) {\r\n      case 'connected': {\r\n        Logger.logAction(\r\n          this.logger,\r\n\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Sending AUTH message on active transport',\r\n        );\r\n\r\n        /* Do any transport-specific new-token action */\r\n        const activeTransport = this.activeProtocol?.getTransport();\r\n        if (activeTransport && activeTransport.onAuthUpdated) {\r\n          activeTransport.onAuthUpdated(tokenDetails);\r\n        }\r\n\r\n        const authMsg = protocolMessageFromValues({\r\n          action: actions.AUTH,\r\n          auth: {\r\n            accessToken: tokenDetails.token,\r\n          },\r\n        });\r\n        this.send(authMsg);\r\n\r\n        /* The answer will come back as either a connectiondetails event\r\n         * (realtime sends a CONNECTED to acknowledge the reauth) or a\r\n         * statechange to failed */\r\n        const successListener = () => {\r\n          this.off(failureListener);\r\n          callback(null, tokenDetails);\r\n        };\r\n        const failureListener = (stateChange: ConnectionStateChange) => {\r\n          if (stateChange.current === 'failed') {\r\n            this.off(successListener);\r\n            this.off(failureListener);\r\n            callback(stateChange.reason || this.getStateError());\r\n          }\r\n        };\r\n        this.once('connectiondetails', successListener);\r\n        this.on('connectionstate', failureListener);\r\n        break;\r\n      }\r\n\r\n      case 'connecting':\r\n        Logger.logAction(\r\n          this.logger,\r\n\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Aborting current connection attempts in order to start again with the new auth details',\r\n        );\r\n        this.disconnectAllTransports();\r\n      /* fallthrough to add statechange listener */\r\n\r\n      default: {\r\n        Logger.logAction(\r\n          this.logger,\r\n\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Connection state is ' + this.state.state + '; waiting until either connected or failed',\r\n        );\r\n        const listener = (stateChange: ConnectionStateChange) => {\r\n          switch (stateChange.current) {\r\n            case 'connected':\r\n              this.off(listener);\r\n              callback(null, tokenDetails);\r\n              break;\r\n            case 'failed':\r\n            case 'closed':\r\n            case 'suspended':\r\n              this.off(listener);\r\n              callback(stateChange.reason || this.getStateError());\r\n              break;\r\n            default:\r\n              /* ignore till we get either connected or failed */\r\n              break;\r\n          }\r\n        };\r\n        this.on('connectionstate', listener);\r\n        if (this.state.state === 'connecting') {\r\n          /* can happen if in the connecting state but no transport was pending\r\n           * yet, so disconnectAllTransports did not trigger a disconnected state */\r\n          this.startConnect();\r\n        } else {\r\n          this.requestState({ state: 'connecting' });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  disconnectAllTransports(): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.disconnectAllTransports()',\r\n      'Disconnecting all transports',\r\n    );\r\n\r\n    /* This will prevent any connection procedure in an async part of one of its early stages from continuing */\r\n    this.connectCounter++;\r\n\r\n    if (this.pendingTransport) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting pending transport: ' + this.pendingTransport,\r\n      );\r\n      this.pendingTransport.disconnect();\r\n    }\r\n    delete this.pendingTransport;\r\n\r\n    if (this.proposedTransport) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting proposed transport: ' + this.pendingTransport,\r\n      );\r\n      this.proposedTransport.disconnect();\r\n    }\r\n    delete this.pendingTransport;\r\n\r\n    if (this.activeProtocol) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting active transport: ' + this.activeProtocol.getTransport(),\r\n      );\r\n      this.activeProtocol.getTransport().disconnect();\r\n    }\r\n    /* No need to notify state disconnected; disconnecting the active transport\r\n     * will have that effect */\r\n  }\r\n\r\n  /******************\r\n   * event queueing\r\n   ******************/\r\n\r\n  send(msg: ProtocolMessage, queueEvent?: boolean, callback?: ErrCallback): void {\r\n    callback = callback || noop;\r\n    const state = this.state;\r\n\r\n    if (state.sendEvents) {\r\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.send()', 'sending event');\r\n      this.sendImpl(new PendingMessage(msg, callback));\r\n      return;\r\n    }\r\n    const shouldQueue = queueEvent && state.queueEvents;\r\n    if (!shouldQueue) {\r\n      const err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;\r\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.send()', err);\r\n      callback(this.errorReason || new ErrorInfo(err, 90000, 400));\r\n      return;\r\n    }\r\n    if (this.logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.send()',\r\n        'queueing msg; ' + stringifyProtocolMessage(msg, this.realtime._RealtimePresence),\r\n      );\r\n    }\r\n    this.queue(msg, callback);\r\n  }\r\n\r\n  sendImpl(pendingMessage: PendingMessage): void {\r\n    const msg = pendingMessage.message;\r\n    /* If have already attempted to send this, resend with the same msgSerial,\r\n     * so Ably can dedup if the previous send succeeded */\r\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\r\n      msg.msgSerial = this.msgSerial++;\r\n    }\r\n    try {\r\n      (this.activeProtocol as Protocol).send(pendingMessage);\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.sendImpl()',\r\n        'Unexpected exception in transport.send(): ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  queue(msg: ProtocolMessage, callback: ErrCallback): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');\r\n    const lastQueued = this.queuedMessages.last();\r\n    const maxSize = this.options.maxMessageSize;\r\n    /* If have already attempted to send a message, don't merge more messages\r\n     * into it, as if the previous send actually succeeded and realtime ignores\r\n     * the dup, they'll be lost */\r\n    if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\r\n      if (!lastQueued.merged) {\r\n        lastQueued.callback = Multicaster.create(this.logger, [lastQueued.callback]);\r\n        lastQueued.merged = true;\r\n      }\r\n      (lastQueued.callback as MulticasterInstance<void>).push(callback);\r\n    } else {\r\n      this.queuedMessages.push(new PendingMessage(msg, callback));\r\n    }\r\n  }\r\n\r\n  sendQueuedMessages(): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n\r\n      Logger.LOG_MICRO,\r\n      'ConnectionManager.sendQueuedMessages()',\r\n      'sending ' + this.queuedMessages.count() + ' queued messages',\r\n    );\r\n    let pendingMessage;\r\n    while ((pendingMessage = this.queuedMessages.shift())) this.sendImpl(pendingMessage);\r\n  }\r\n\r\n  queuePendingMessages(pendingMessages: Array<PendingMessage>): void {\r\n    if (pendingMessages && pendingMessages.length) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.queuePendingMessages()',\r\n        'queueing ' + pendingMessages.length + ' pending messages',\r\n      );\r\n      this.queuedMessages.prepend(pendingMessages);\r\n    }\r\n  }\r\n\r\n  failQueuedMessages(err: ErrorInfo): void {\r\n    const numQueued = this.queuedMessages.count();\r\n    if (numQueued > 0) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.failQueuedMessages()',\r\n        'failing ' + numQueued + ' queued messages, err = ' + Utils.inspectError(err),\r\n      );\r\n      this.queuedMessages.completeAllMessages(err);\r\n    }\r\n  }\r\n\r\n  onChannelMessage(message: ProtocolMessage, transport: Transport): void {\r\n    this.pendingChannelMessagesState.queue.push({ message, transport });\r\n\r\n    if (!this.pendingChannelMessagesState.isProcessing) {\r\n      this.processNextPendingChannelMessage();\r\n    }\r\n  }\r\n\r\n  private processNextPendingChannelMessage() {\r\n    if (this.pendingChannelMessagesState.queue.length > 0) {\r\n      this.pendingChannelMessagesState.isProcessing = true;\r\n\r\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift()!;\r\n      this.processChannelMessage(pendingChannelMessage.message)\r\n        .catch((err) => {\r\n          Logger.logAction(\r\n            this.logger,\r\n\r\n            Logger.LOG_ERROR,\r\n            'ConnectionManager.processNextPendingChannelMessage() received error ',\r\n            err,\r\n          );\r\n        })\r\n        .finally(() => {\r\n          this.pendingChannelMessagesState.isProcessing = false;\r\n          this.processNextPendingChannelMessage();\r\n        });\r\n    }\r\n  }\r\n\r\n  private async processChannelMessage(message: ProtocolMessage) {\r\n    await this.realtime.channels.processChannelMessage(message);\r\n  }\r\n\r\n  async ping(): Promise<number> {\r\n    if (this.state.state !== 'connected') {\r\n      throw new ErrorInfo('Unable to ping service; not connected', 40000, 400);\r\n    }\r\n\r\n    const transport = this.activeProtocol?.getTransport();\r\n    if (!transport) {\r\n      throw this.getStateError();\r\n    }\r\n\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);\r\n\r\n    const pingStart = Date.now();\r\n    const id = Utils.cheapRandStr();\r\n\r\n    return Utils.withTimeoutAsync<number>(\r\n      new Promise((resolve) => {\r\n        const onHeartbeat = (responseId: string) => {\r\n          if (responseId === id) {\r\n            transport.off('heartbeat', onHeartbeat);\r\n            resolve(Date.now() - pingStart);\r\n          }\r\n        };\r\n        transport.on('heartbeat', onHeartbeat);\r\n        transport.ping(id);\r\n      }),\r\n      this.options.timeouts.realtimeRequestTimeout,\r\n      'Timeout waiting for heartbeat response',\r\n    );\r\n  }\r\n\r\n  abort(error: ErrorInfo): void {\r\n    (this.activeProtocol as Protocol).getTransport().fail(error);\r\n  }\r\n\r\n  getTransportPreference(): TransportName {\r\n    return this.transportPreference || (haveWebStorage() && Platform.WebStorage?.get?.(transportPreferenceName));\r\n  }\r\n\r\n  persistTransportPreference(transport: Transport): void {\r\n    this.transportPreference = transport.shortName;\r\n    if (haveWebStorage()) {\r\n      Platform.WebStorage?.set?.(transportPreferenceName, transport.shortName);\r\n    }\r\n  }\r\n\r\n  unpersistTransportPreference(): void {\r\n    this.transportPreference = null;\r\n    if (haveWebStorage()) {\r\n      Platform.WebStorage?.remove?.(transportPreferenceName);\r\n    }\r\n  }\r\n\r\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\r\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\r\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\r\n   * server returns 403. */\r\n  actOnErrorFromAuthorize(err: ErrorInfo): void {\r\n    if (err.code === 40171) {\r\n      /* No way to reauth */\r\n      this.notifyState({ state: 'failed', error: err });\r\n    } else if (err.code === 40102) {\r\n      this.notifyState({ state: 'failed', error: err });\r\n    } else if (err.statusCode === HttpStatusCodes.Forbidden) {\r\n      const msg = 'Client configured authentication provider returned 403; failing the connection';\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);\r\n      this.notifyState({ state: 'failed', error: new ErrorInfo(msg, 80019, 403, err) });\r\n    } else {\r\n      const msg = 'Client configured authentication provider request failed';\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);\r\n      this.notifyState({ state: this.state.failState as string, error: new ErrorInfo(msg, 80019, 401, err) });\r\n    }\r\n  }\r\n\r\n  onConnectionDetailsUpdate(connectionDetails: Record<string, any>, transport: Transport): void {\r\n    if (!connectionDetails) {\r\n      return;\r\n    }\r\n    this.connectionDetails = connectionDetails;\r\n    if (connectionDetails.maxMessageSize) {\r\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\r\n    }\r\n    const clientId = connectionDetails.clientId;\r\n    if (clientId) {\r\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\r\n      if (err) {\r\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);\r\n        /* Errors setting the clientId are fatal to the connection */\r\n        transport.fail(err);\r\n        return;\r\n      }\r\n    }\r\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\r\n    if (connectionStateTtl) {\r\n      this.connectionStateTtl = connectionStateTtl;\r\n    }\r\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\r\n    this.emit('connectiondetails', connectionDetails);\r\n  }\r\n\r\n  checkWsConnectivity() {\r\n    const ws = new Platform.Config.WebSocket(Defaults.wsConnectivityUrl);\r\n    return new Promise<void>((resolve, reject) => {\r\n      let finished = false;\r\n      ws.onopen = () => {\r\n        if (!finished) {\r\n          finished = true;\r\n          resolve();\r\n          ws.close();\r\n        }\r\n      };\r\n\r\n      ws.onclose = ws.onerror = () => {\r\n        if (!finished) {\r\n          finished = true;\r\n          reject();\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  sessionRecoveryName() {\r\n    return this.options.recoveryKeyStorageName || 'ably-connection-recovery';\r\n  }\r\n\r\n  getSessionRecoverData() {\r\n    return haveSessionStorage() && Platform.WebStorage?.getSession?.(this.sessionRecoveryName());\r\n  }\r\n  setSessionRecoverData(value: any) {\r\n    return haveSessionStorage() && Platform.WebStorage?.setSession?.(this.sessionRecoveryName(), value);\r\n  }\r\n  clearSessionRecoverData() {\r\n    return haveSessionStorage() && Platform.WebStorage?.removeSession?.(this.sessionRecoveryName());\r\n  }\r\n}\r\n\r\nexport default ConnectionManager;\r\n\r\nexport interface TransportStorage {\r\n  supportedTransports: Partial<Record<TransportName, TransportCtor>>;\r\n}\r\n", "import EventEmitter from '../util/eventemitter';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport Logger from '../util/logger';\r\nimport ConnectionStateChange from './connectionstatechange';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport { NormalisedClientOptions } from '../../types/ClientOptions';\r\nimport BaseRealtime from './baserealtime';\r\nimport Platform from 'common/platform';\r\n\r\nclass Connection extends EventEmitter {\r\n  ably: BaseRealtime;\r\n  connectionManager: ConnectionManager;\r\n  state: string;\r\n  key?: string;\r\n  id?: string;\r\n  errorReason: ErrorInfo | null;\r\n\r\n  constructor(ably: BaseRealtime, options: NormalisedClientOptions) {\r\n    super(ably.logger);\r\n    this.ably = ably;\r\n    this.connectionManager = new ConnectionManager(ably, options);\r\n    this.state = this.connectionManager.state.state;\r\n    this.key = undefined;\r\n    this.id = undefined;\r\n    this.errorReason = null;\r\n\r\n    this.connectionManager.on('connectionstate', (stateChange: ConnectionStateChange) => {\r\n      const state = (this.state = stateChange.current as string);\r\n      Platform.Config.nextTick(() => {\r\n        this.emit(state, stateChange);\r\n      });\r\n    });\r\n    this.connectionManager.on('update', (stateChange: ConnectionStateChange) => {\r\n      Platform.Config.nextTick(() => {\r\n        this.emit('update', stateChange);\r\n      });\r\n    });\r\n  }\r\n\r\n  whenState = ((state: string) => {\r\n    return EventEmitter.prototype.whenState.call(this, state, this.state);\r\n  }) as any;\r\n\r\n  connect(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Connection.connect()', '');\r\n    this.connectionManager.requestState({ state: 'connecting' });\r\n  }\r\n\r\n  async ping(): Promise<number> {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Connection.ping()', '');\r\n    return this.connectionManager.ping();\r\n  }\r\n\r\n  close(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);\r\n    this.connectionManager.requestState({ state: 'closing' });\r\n  }\r\n\r\n  get recoveryKey(): string | null {\r\n    this.logger.deprecationWarning(\r\n      'The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.',\r\n    );\r\n    return this.createRecoveryKey();\r\n  }\r\n\r\n  createRecoveryKey(): string | null {\r\n    return this.connectionManager.createRecoveryKey();\r\n  }\r\n}\r\n\r\nexport default Connection;\r\n", "import ErrorInfo from '../types/errorinfo';\r\n\r\nclass ChannelStateChange {\r\n  previous: string;\r\n  current: string;\r\n  resumed?: boolean;\r\n  reason?: string | Error | ErrorInfo;\r\n  hasBacklog?: boolean;\r\n\r\n  constructor(\r\n    previous: string,\r\n    current: string,\r\n    resumed?: boolean,\r\n    hasBacklog?: boolean,\r\n    reason?: string | Error | ErrorInfo | null,\r\n  ) {\r\n    this.previous = previous;\r\n    this.current = current;\r\n    if (current === 'attached') {\r\n      this.resumed = resumed;\r\n      this.hasBacklog = hasBacklog;\r\n    }\r\n    if (reason) this.reason = reason;\r\n  }\r\n}\r\n\r\nexport default ChannelStateChange;\r\n", "import ProtocolMessage, {\r\n  actions,\r\n  channelModes,\r\n  fromValues as protocolMessageFromValues,\r\n} from '../types/protocolmessage';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport RealtimePresence from './realtimepresence';\r\nimport Message, {\r\n  fromValues as messageFromValues,\r\n  fromValuesArray as messagesFromValuesArray,\r\n  encodeArray as encodeMessagesArray,\r\n  decode as decodeMessage,\r\n  getMessagesSize,\r\n  CipherOptions,\r\n  EncodingDecodingContext,\r\n} from '../types/message';\r\nimport ChannelStateChange from './channelstatechange';\r\nimport ErrorInfo, { PartialErrorInfo } from '../types/errorinfo';\r\nimport PresenceMessage, { decode as decodePresenceMessage } from '../types/presencemessage';\r\nimport ConnectionErrors from '../transport/connectionerrors';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport ConnectionStateChange from './connectionstatechange';\r\nimport { ErrCallback, StandardCallback } from '../../types/utils';\r\nimport BaseRealtime from './baserealtime';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport { normaliseChannelOptions } from '../util/defaults';\r\nimport { PaginatedResult } from './paginatedresource';\r\n\r\ninterface RealtimeHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n  untilAttach?: boolean;\r\n  from_serial?: string;\r\n}\r\n\r\nconst noop = function () {};\r\n\r\nfunction validateChannelOptions(options?: API.ChannelOptions) {\r\n  if (options && 'params' in options && !Utils.isObject(options.params)) {\r\n    return new ErrorInfo('options.params must be an object', 40000, 400);\r\n  }\r\n  if (options && 'modes' in options) {\r\n    if (!Array.isArray(options.modes)) {\r\n      return new ErrorInfo('options.modes must be an array', 40000, 400);\r\n    }\r\n    for (let i = 0; i < options.modes.length; i++) {\r\n      const currentMode = options.modes[i];\r\n      if (\r\n        !currentMode ||\r\n        typeof currentMode !== 'string' ||\r\n        !channelModes.includes(String.prototype.toUpperCase.call(currentMode))\r\n      ) {\r\n        return new ErrorInfo('Invalid channel mode: ' + currentMode, 40000, 400);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass RealtimeChannel extends EventEmitter {\r\n  name: string;\r\n  channelOptions: ChannelOptions;\r\n  client: BaseRealtime;\r\n  private _presence: RealtimePresence | null;\r\n  get presence(): RealtimePresence {\r\n    if (!this._presence) {\r\n      Utils.throwMissingPluginError('RealtimePresence');\r\n    }\r\n    return this._presence;\r\n  }\r\n  connectionManager: ConnectionManager;\r\n  state: API.ChannelState;\r\n  subscriptions: EventEmitter;\r\n  filteredSubscriptions?: Map<API.messageCallback<Message>, Map<API.MessageFilter, API.messageCallback<Message>[]>>;\r\n  syncChannelSerial?: string | null;\r\n  properties: {\r\n    attachSerial: string | null | undefined;\r\n    channelSerial: string | null | undefined;\r\n  };\r\n  errorReason: ErrorInfo | string | null;\r\n  _requestedFlags: Array<API.ChannelMode> | null;\r\n  _mode?: null | number;\r\n  _attachResume: boolean;\r\n  _decodingContext: EncodingDecodingContext;\r\n  _lastPayload: {\r\n    messageId?: string | null;\r\n    protocolMessageChannelSerial?: string | null;\r\n    decodeFailureRecoveryInProgress: null | boolean;\r\n  };\r\n  _allChannelChanges: EventEmitter;\r\n  params?: Record<string, any>;\r\n  modes: string[] | undefined;\r\n  stateTimer?: number | NodeJS.Timeout | null;\r\n  retryTimer?: number | NodeJS.Timeout | null;\r\n  retryCount: number = 0;\r\n\r\n  constructor(client: BaseRealtime, name: string, options?: API.ChannelOptions) {\r\n    super(client.logger);\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);\r\n    this.name = name;\r\n    this.channelOptions = normaliseChannelOptions(client._Crypto ?? null, this.logger, options);\r\n    this.client = client;\r\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\r\n    this.connectionManager = client.connection.connectionManager;\r\n    this.state = 'initialized';\r\n    this.subscriptions = new EventEmitter(this.logger);\r\n    this.syncChannelSerial = undefined;\r\n    this.properties = {\r\n      attachSerial: undefined,\r\n      channelSerial: undefined,\r\n    };\r\n    this.setOptions(options);\r\n    this.errorReason = null;\r\n    this._requestedFlags = null;\r\n    this._mode = null;\r\n    this._attachResume = false;\r\n    this._decodingContext = {\r\n      channelOptions: this.channelOptions,\r\n      plugins: client.options.plugins || {},\r\n      baseEncodedPreviousPayload: undefined,\r\n    };\r\n    this._lastPayload = {\r\n      messageId: null,\r\n      protocolMessageChannelSerial: null,\r\n      decodeFailureRecoveryInProgress: null,\r\n    };\r\n    /* Only differences between this and the public event emitter is that this emits an\r\n     * update event for all ATTACHEDs, whether resumed or not */\r\n    this._allChannelChanges = new EventEmitter(this.logger);\r\n  }\r\n\r\n  invalidStateError(): ErrorInfo {\r\n    return new ErrorInfo(\r\n      'Channel operation failed as channel state is ' + this.state,\r\n      90001,\r\n      400,\r\n      this.errorReason || undefined,\r\n    );\r\n  }\r\n\r\n  static processListenerArgs(args: unknown[]): any[] {\r\n    /* [event], listener */\r\n    args = Array.prototype.slice.call(args);\r\n    if (typeof args[0] === 'function') {\r\n      args.unshift(null);\r\n    }\r\n    return args;\r\n  }\r\n\r\n  async setOptions(options?: API.ChannelOptions): Promise<void> {\r\n    const previousChannelOptions = this.channelOptions;\r\n    const err = validateChannelOptions(options);\r\n    if (err) {\r\n      throw err;\r\n    }\r\n    this.channelOptions = normaliseChannelOptions(this.client._Crypto ?? null, this.logger, options);\r\n    if (this._decodingContext) this._decodingContext.channelOptions = this.channelOptions;\r\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\r\n      /* This does not just do _attach(true, null, callback) because that would put us\r\n       * into the 'attaching' state until we receive the new attached, which is\r\n       * conceptually incorrect: we are still attached, we just have a pending request to\r\n       * change some channel params. Per RTL17 going into the attaching state would mean\r\n       * rejecting messages until we have confirmation that the options have changed,\r\n       * which would unnecessarily lose message continuity. */\r\n      this.attachImpl();\r\n      return new Promise((resolve, reject) => {\r\n        // Ignore 'attaching' -- could be just due to to a resume & reattach, should not\r\n        // call back setOptions until we're definitely attached with the new options (or\r\n        // else in a terminal state)\r\n        this._allChannelChanges.once(\r\n          ['attached', 'update', 'detached', 'failed'],\r\n          function (this: { event: string }, stateChange: ConnectionStateChange) {\r\n            switch (this.event) {\r\n              case 'update':\r\n              case 'attached':\r\n                resolve();\r\n                break;\r\n              default:\r\n                reject(stateChange.reason);\r\n            }\r\n          },\r\n        );\r\n      });\r\n    }\r\n  }\r\n\r\n  _shouldReattachToSetOptions(options: API.ChannelOptions | undefined, prevOptions: API.ChannelOptions) {\r\n    if (!(this.state === 'attached' || this.state === 'attaching')) {\r\n      return false;\r\n    }\r\n    if (options?.params) {\r\n      // Don't check against the `agent` param - it isn't returned in the ATTACHED message\r\n      const requestedParams = omitAgent(options.params);\r\n      const existingParams = omitAgent(prevOptions.params);\r\n\r\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\r\n        return true;\r\n      }\r\n\r\n      if (!Utils.shallowEquals(existingParams, requestedParams)) {\r\n        return true;\r\n      }\r\n    }\r\n    if (options?.modes) {\r\n      if (!prevOptions.modes || !Utils.arrEquals(options.modes, prevOptions.modes)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async publish(...args: any[]): Promise<void> {\r\n    let messages = args[0];\r\n    let argCount = args.length;\r\n\r\n    if (!this.connectionManager.activeState()) {\r\n      throw this.connectionManager.getError();\r\n    }\r\n    if (argCount == 1) {\r\n      if (Utils.isObject(messages)) messages = [messageFromValues(messages)];\r\n      else if (Array.isArray(messages)) messages = messagesFromValuesArray(messages);\r\n      else\r\n        throw new ErrorInfo(\r\n          'The single-argument form of publish() expects a message object or an array of message objects',\r\n          40013,\r\n          400,\r\n        );\r\n    } else {\r\n      messages = [messageFromValues({ name: args[0], data: args[1] })];\r\n    }\r\n    const maxMessageSize = this.client.options.maxMessageSize;\r\n    await encodeMessagesArray(messages, this.channelOptions as CipherOptions);\r\n    /* RSL1i */\r\n    const size = getMessagesSize(messages);\r\n    if (size > maxMessageSize) {\r\n      throw new ErrorInfo(\r\n        'Maximum size of messages that can be published at once exceeded ( was ' +\r\n          size +\r\n          ' bytes; limit is ' +\r\n          maxMessageSize +\r\n          ' bytes)',\r\n        40009,\r\n        400,\r\n      );\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      this._publish(messages, (err) => (err ? reject(err) : resolve()));\r\n    });\r\n  }\r\n\r\n  _publish(messages: Array<Message>, callback: ErrCallback) {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);\r\n    const state = this.state;\r\n    switch (state) {\r\n      case 'failed':\r\n      case 'suspended':\r\n        callback(ErrorInfo.fromValues(this.invalidStateError()));\r\n        break;\r\n      default: {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          'RealtimeChannel.publish()',\r\n          'sending message; channel state is ' + state,\r\n        );\r\n        const msg = new ProtocolMessage();\r\n        msg.action = actions.MESSAGE;\r\n        msg.channel = this.name;\r\n        msg.messages = messages;\r\n        this.sendMessage(msg, callback);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  onEvent(messages: Array<any>): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');\r\n    const subscriptions = this.subscriptions;\r\n    for (let i = 0; i < messages.length; i++) {\r\n      const message = messages[i];\r\n      subscriptions.emit(message.name, message);\r\n    }\r\n  }\r\n\r\n  async attach(): Promise<ChannelStateChange | null> {\r\n    if (this.state === 'attached') {\r\n      return null;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      this._attach(false, null, (err, result) => (err ? reject(err) : resolve(result!)));\r\n    });\r\n  }\r\n\r\n  _attach(\r\n    forceReattach: boolean,\r\n    attachReason: ErrorInfo | null,\r\n    callback?: StandardCallback<ChannelStateChange>,\r\n  ): void {\r\n    if (!callback) {\r\n      callback = (err?: ErrorInfo | null) => {\r\n        if (err) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_ERROR,\r\n            'RealtimeChannel._attach()',\r\n            'Channel attach failed: ' + err.toString(),\r\n          );\r\n        }\r\n      };\r\n    }\r\n\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      callback(connectionManager.getError());\r\n      return;\r\n    }\r\n\r\n    if (this.state !== 'attaching' || forceReattach) {\r\n      this.requestState('attaching', attachReason);\r\n    }\r\n\r\n    this.once(function (this: { event: string }, stateChange: ChannelStateChange) {\r\n      switch (this.event) {\r\n        case 'attached':\r\n          callback?.(null, stateChange);\r\n          break;\r\n        case 'detached':\r\n        case 'suspended':\r\n        case 'failed':\r\n          callback?.(\r\n            stateChange.reason ||\r\n              connectionManager.getError() ||\r\n              new ErrorInfo('Unable to attach; reason unknown; state = ' + this.event, 90000, 500),\r\n          );\r\n          break;\r\n        case 'detaching':\r\n          callback?.(new ErrorInfo('Attach request superseded by a subsequent detach request', 90000, 409));\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  attachImpl(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');\r\n    const attachMsg = protocolMessageFromValues({\r\n      action: actions.ATTACH,\r\n      channel: this.name,\r\n      params: this.channelOptions.params,\r\n      // RTL4c1: Includes the channel serial to resume from a previous message\r\n      // or attachment.\r\n      channelSerial: this.properties.channelSerial,\r\n    });\r\n    if (this._requestedFlags) {\r\n      attachMsg.encodeModesToFlags(this._requestedFlags);\r\n    } else if (this.channelOptions.modes) {\r\n      attachMsg.encodeModesToFlags(Utils.allToUpperCase(this.channelOptions.modes) as API.ChannelMode[]);\r\n    }\r\n    if (this._attachResume) {\r\n      attachMsg.setFlag('ATTACH_RESUME');\r\n    }\r\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\r\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\r\n    }\r\n    this.sendMessage(attachMsg, noop);\r\n  }\r\n\r\n  async detach(): Promise<void> {\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      throw connectionManager.getError();\r\n    }\r\n    switch (this.state) {\r\n      case 'suspended':\r\n        this.notifyState('detached');\r\n        return;\r\n      case 'detached':\r\n        return;\r\n      case 'failed':\r\n        throw new ErrorInfo('Unable to detach; channel state = failed', 90001, 400);\r\n      default:\r\n        this.requestState('detaching');\r\n      // eslint-disable-next-line no-fallthrough\r\n      case 'detaching':\r\n        return new Promise((resolve, reject) => {\r\n          this.once(function (this: { event: string }, stateChange: ChannelStateChange) {\r\n            switch (this.event) {\r\n              case 'detached':\r\n                resolve();\r\n                break;\r\n              case 'attached':\r\n              case 'suspended':\r\n              case 'failed':\r\n                reject(\r\n                  stateChange.reason ||\r\n                    connectionManager.getError() ||\r\n                    new ErrorInfo('Unable to detach; reason unknown; state = ' + this.event, 90000, 500),\r\n                );\r\n                break;\r\n              case 'attaching':\r\n                reject(new ErrorInfo('Detach request superseded by a subsequent attach request', 90000, 409));\r\n                break;\r\n            }\r\n          });\r\n        });\r\n    }\r\n  }\r\n\r\n  detachImpl(callback?: ErrCallback): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');\r\n    const msg = protocolMessageFromValues({ action: actions.DETACH, channel: this.name });\r\n    this.sendMessage(msg, callback || noop);\r\n  }\r\n\r\n  async subscribe(...args: unknown[] /* [event], listener */): Promise<ChannelStateChange | null> {\r\n    const [event, listener] = RealtimeChannel.processListenerArgs(args);\r\n\r\n    if (this.state === 'failed') {\r\n      throw ErrorInfo.fromValues(this.invalidStateError());\r\n    }\r\n\r\n    // Filtered\r\n    if (event && typeof event === 'object' && !Array.isArray(event)) {\r\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\r\n    } else {\r\n      this.subscriptions.on(event, listener);\r\n    }\r\n\r\n    return this.attach();\r\n  }\r\n\r\n  unsubscribe(...args: unknown[] /* [event], listener */): void {\r\n    const [event, listener] = RealtimeChannel.processListenerArgs(args);\r\n\r\n    // If we either have a filtered listener, a filter or both we need to do additional processing to find the original function(s)\r\n    if ((typeof event === 'object' && !listener) || this.filteredSubscriptions?.has(listener)) {\r\n      this.client._FilteredSubscriptions\r\n        .getAndDeleteFilteredSubscriptions(this, event, listener)\r\n        .forEach((l) => this.subscriptions.off(l));\r\n      return;\r\n    }\r\n\r\n    this.subscriptions.off(event, listener);\r\n  }\r\n\r\n  sync(): void {\r\n    /* check preconditions */\r\n    switch (this.state) {\r\n      case 'initialized':\r\n      case 'detaching':\r\n      case 'detached':\r\n        throw new PartialErrorInfo('Unable to sync to channel; not attached', 40000);\r\n      default:\r\n    }\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      throw connectionManager.getError();\r\n    }\r\n\r\n    /* send sync request */\r\n    const syncMessage = protocolMessageFromValues({ action: actions.SYNC, channel: this.name });\r\n    if (this.syncChannelSerial) {\r\n      syncMessage.channelSerial = this.syncChannelSerial;\r\n    }\r\n    connectionManager.send(syncMessage);\r\n  }\r\n\r\n  sendMessage(msg: ProtocolMessage, callback?: ErrCallback): void {\r\n    this.connectionManager.send(msg, this.client.options.queueMessages, callback);\r\n  }\r\n\r\n  sendPresence(presence: PresenceMessage | PresenceMessage[], callback?: ErrCallback): void {\r\n    const msg = protocolMessageFromValues({\r\n      action: actions.PRESENCE,\r\n      channel: this.name,\r\n      presence: Array.isArray(presence)\r\n        ? this.client._RealtimePresence!.presenceMessagesFromValuesArray(presence)\r\n        : [this.client._RealtimePresence!.presenceMessageFromValues(presence)],\r\n    });\r\n    this.sendMessage(msg, callback);\r\n  }\r\n\r\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\r\n  async processMessage(message: ProtocolMessage): Promise<void> {\r\n    if (\r\n      message.action === actions.ATTACHED ||\r\n      message.action === actions.MESSAGE ||\r\n      message.action === actions.PRESENCE\r\n    ) {\r\n      // RTL15b\r\n      this.setChannelSerial(message.channelSerial);\r\n    }\r\n\r\n    let syncChannelSerial,\r\n      isSync = false;\r\n    switch (message.action) {\r\n      case actions.ATTACHED: {\r\n        this.properties.attachSerial = message.channelSerial;\r\n        this._mode = message.getMode();\r\n        this.params = (message as any).params || {};\r\n        const modesFromFlags = message.decodeModesFromFlags();\r\n        this.modes = (modesFromFlags && Utils.allToLowerCase(modesFromFlags)) || undefined;\r\n        const resumed = message.hasFlag('RESUMED');\r\n        const hasPresence = message.hasFlag('HAS_PRESENCE');\r\n        const hasBacklog = message.hasFlag('HAS_BACKLOG');\r\n        if (this.state === 'attached') {\r\n          if (!resumed) {\r\n            /* On a loss of continuity, the presence set needs to be re-synced */\r\n            if (this._presence) {\r\n              this._presence.onAttached(hasPresence);\r\n            }\r\n          }\r\n          const change = new ChannelStateChange(this.state, this.state, resumed, hasBacklog, message.error);\r\n          this._allChannelChanges.emit('update', change);\r\n          if (!resumed || this.channelOptions.updateOnAttached) {\r\n            this.emit('update', change);\r\n          }\r\n        } else if (this.state === 'detaching') {\r\n          /* RTL5i: re-send DETACH and remain in the 'detaching' state */\r\n          this.checkPendingState();\r\n        } else {\r\n          this.notifyState('attached', message.error, resumed, hasPresence, hasBacklog);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case actions.DETACHED: {\r\n        const detachErr = message.error\r\n          ? ErrorInfo.fromValues(message.error)\r\n          : new ErrorInfo('Channel detached', 90001, 404);\r\n        if (this.state === 'detaching') {\r\n          this.notifyState('detached', detachErr);\r\n        } else if (this.state === 'attaching') {\r\n          /* Only retry immediately if we were previously attached. If we were\r\n           * attaching, go into suspended, fail messages, and wait a few seconds\r\n           * before retrying */\r\n          this.notifyState('suspended', detachErr);\r\n        } else {\r\n          this.requestState('attaching', detachErr);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case actions.SYNC:\r\n        /* syncs can have channelSerials, but might not if the sync is one page long */\r\n        isSync = true;\r\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\r\n        /* syncs can happen on channels with no presence data as part of connection\r\n         * resuming, in which case protocol message has no presence property */\r\n        if (!message.presence) break;\r\n      // eslint-disable-next-line no-fallthrough\r\n      case actions.PRESENCE: {\r\n        const presence = message.presence;\r\n\r\n        if (!presence) {\r\n          break;\r\n        }\r\n\r\n        const { id, connectionId, timestamp } = message;\r\n\r\n        const options = this.channelOptions;\r\n        let presenceMsg: PresenceMessage;\r\n        for (let i = 0; i < presence.length; i++) {\r\n          try {\r\n            presenceMsg = presence[i];\r\n            await decodePresenceMessage(presenceMsg, options);\r\n            if (!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;\r\n            if (!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;\r\n            if (!presenceMsg.id) presenceMsg.id = id + ':' + i;\r\n          } catch (e) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_ERROR,\r\n              'RealtimeChannel.processMessage()',\r\n              (e as Error).toString(),\r\n            );\r\n          }\r\n        }\r\n        if (this._presence) {\r\n          this._presence.setPresence(presence, isSync, syncChannelSerial as any);\r\n        }\r\n        break;\r\n      }\r\n      case actions.MESSAGE: {\r\n        //RTL17\r\n        if (this.state !== 'attached') {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MAJOR,\r\n            'RealtimeChannel.processMessage()',\r\n            'Message \"' +\r\n              message.id +\r\n              '\" skipped as this channel \"' +\r\n              this.name +\r\n              '\" state is not \"attached\" (state is \"' +\r\n              this.state +\r\n              '\").',\r\n          );\r\n          return;\r\n        }\r\n\r\n        const messages = message.messages as Array<Message>,\r\n          firstMessage = messages[0],\r\n          lastMessage = messages[messages.length - 1],\r\n          id = message.id,\r\n          connectionId = message.connectionId,\r\n          timestamp = message.timestamp;\r\n\r\n        if (\r\n          firstMessage.extras &&\r\n          firstMessage.extras.delta &&\r\n          firstMessage.extras.delta.from !== this._lastPayload.messageId\r\n        ) {\r\n          const msg =\r\n            'Delta message decode failure - previous message not available for message \"' +\r\n            message.id +\r\n            '\" on this channel \"' +\r\n            this.name +\r\n            '\".';\r\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'RealtimeChannel.processMessage()', msg);\r\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\r\n          break;\r\n        }\r\n\r\n        for (let i = 0; i < messages.length; i++) {\r\n          const msg = messages[i];\r\n          try {\r\n            await decodeMessage(msg, this._decodingContext);\r\n          } catch (e) {\r\n            /* decrypt failed .. the most likely cause is that we have the wrong key */\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_ERROR,\r\n              'RealtimeChannel.processMessage()',\r\n              (e as Error).toString(),\r\n            );\r\n            switch ((e as ErrorInfo).code) {\r\n              case 40018:\r\n                /* decode failure */\r\n                this._startDecodeFailureRecovery(e as ErrorInfo);\r\n                return;\r\n              case 40019:\r\n              /* No vcdiff plugin passed in - no point recovering, give up */\r\n              // eslint-disable-next-line no-fallthrough\r\n              case 40021:\r\n                /* Browser does not support deltas, similarly no point recovering */\r\n                this.notifyState('failed', e as ErrorInfo);\r\n                return;\r\n            }\r\n          }\r\n          if (!msg.connectionId) msg.connectionId = connectionId;\r\n          if (!msg.timestamp) msg.timestamp = timestamp;\r\n          if (!msg.id) msg.id = id + ':' + i;\r\n        }\r\n        this._lastPayload.messageId = lastMessage.id;\r\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\r\n        this.onEvent(messages);\r\n        break;\r\n      }\r\n\r\n      case actions.ERROR: {\r\n        /* there was a channel-specific error */\r\n        const err = message.error as ErrorInfo;\r\n        if (err && err.code == 80016) {\r\n          /* attach/detach operation attempted on superseded transport handle */\r\n          this.checkPendingState();\r\n        } else {\r\n          this.notifyState('failed', ErrorInfo.fromValues(err));\r\n        }\r\n        break;\r\n      }\r\n\r\n      default:\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_ERROR,\r\n          'RealtimeChannel.processMessage()',\r\n          'Fatal protocol error: unrecognised action (' + message.action + ')',\r\n        );\r\n        this.connectionManager.abort(ConnectionErrors.unknownChannelErr());\r\n    }\r\n  }\r\n\r\n  _startDecodeFailureRecovery(reason: ErrorInfo): void {\r\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MAJOR,\r\n        'RealtimeChannel.processMessage()',\r\n        'Starting decode failure recovery process.',\r\n      );\r\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\r\n      this._attach(true, reason, () => {\r\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\r\n      });\r\n    }\r\n  }\r\n\r\n  onAttached(): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'RealtimeChannel.onAttached',\r\n      'activating channel; name = ' + this.name,\r\n    );\r\n  }\r\n\r\n  notifyState(\r\n    state: API.ChannelState,\r\n    reason?: ErrorInfo | null,\r\n    resumed?: boolean,\r\n    hasPresence?: boolean,\r\n    hasBacklog?: boolean,\r\n  ): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'RealtimeChannel.notifyState',\r\n      'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state,\r\n    );\r\n    this.clearStateTimer();\r\n\r\n    // RTP5a1\r\n    if (['detached', 'suspended', 'failed'].includes(state)) {\r\n      this.properties.channelSerial = null;\r\n    }\r\n\r\n    if (state === this.state) {\r\n      return;\r\n    }\r\n    if (this._presence) {\r\n      this._presence.actOnChannelState(state, hasPresence, reason);\r\n    }\r\n    if (state === 'suspended' && this.connectionManager.state.sendEvents) {\r\n      this.startRetryTimer();\r\n    } else {\r\n      this.cancelRetryTimer();\r\n    }\r\n    if (reason) {\r\n      this.errorReason = reason;\r\n    }\r\n    const change = new ChannelStateChange(this.state, state, resumed, hasBacklog, reason);\r\n    const action = 'Channel state for channel \"' + this.name + '\"';\r\n    const message = state + (reason ? '; reason: ' + reason : '');\r\n    if (state === 'failed') {\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, action, message);\r\n    } else {\r\n      Logger.logAction(this.logger, Logger.LOG_MAJOR, action, message);\r\n    }\r\n\r\n    if (state !== 'attaching' && state !== 'suspended') {\r\n      this.retryCount = 0;\r\n    }\r\n\r\n    /* Note: we don't set inProgress for pending states until the request is actually in progress */\r\n    if (state === 'attached') {\r\n      this.onAttached();\r\n    }\r\n\r\n    if (state === 'attached') {\r\n      this._attachResume = true;\r\n    } else if (state === 'detaching' || state === 'failed') {\r\n      this._attachResume = false;\r\n    }\r\n\r\n    this.state = state;\r\n    this._allChannelChanges.emit(state, change);\r\n    this.emit(state, change);\r\n  }\r\n\r\n  requestState(state: API.ChannelState, reason?: ErrorInfo | null): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'RealtimeChannel.requestState',\r\n      'name = ' + this.name + ', state = ' + state,\r\n    );\r\n    this.notifyState(state, reason);\r\n    /* send the event and await response */\r\n    this.checkPendingState();\r\n  }\r\n\r\n  checkPendingState(): void {\r\n    /* if can't send events, do nothing */\r\n    const cmState = this.connectionManager.state;\r\n    if (!cmState.sendEvents) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'RealtimeChannel.checkPendingState',\r\n        'sendEvents is false; state is ' + this.connectionManager.state.state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'RealtimeChannel.checkPendingState',\r\n      'name = ' + this.name + ', state = ' + this.state,\r\n    );\r\n    /* Only start the state timer running when actually sending the event */\r\n    switch (this.state) {\r\n      case 'attaching':\r\n        this.startStateTimerIfNotRunning();\r\n        this.attachImpl();\r\n        break;\r\n      case 'detaching':\r\n        this.startStateTimerIfNotRunning();\r\n        this.detachImpl();\r\n        break;\r\n      case 'attached':\r\n        /* resume any sync operation that was in progress */\r\n        this.sync();\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  timeoutPendingState(): void {\r\n    switch (this.state) {\r\n      case 'attaching': {\r\n        const err = new ErrorInfo('Channel attach timed out', 90007, 408);\r\n        this.notifyState('suspended', err);\r\n        break;\r\n      }\r\n      case 'detaching': {\r\n        const err = new ErrorInfo('Channel detach timed out', 90007, 408);\r\n        this.notifyState('attached', err);\r\n        break;\r\n      }\r\n      default:\r\n        this.checkPendingState();\r\n        break;\r\n    }\r\n  }\r\n\r\n  startStateTimerIfNotRunning(): void {\r\n    if (!this.stateTimer) {\r\n      this.stateTimer = setTimeout(() => {\r\n        Logger.logAction(this.logger, Logger.LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');\r\n        this.stateTimer = null;\r\n        this.timeoutPendingState();\r\n      }, this.client.options.timeouts.realtimeRequestTimeout);\r\n    }\r\n  }\r\n\r\n  clearStateTimer(): void {\r\n    const stateTimer = this.stateTimer;\r\n    if (stateTimer) {\r\n      clearTimeout(stateTimer);\r\n      this.stateTimer = null;\r\n    }\r\n  }\r\n\r\n  startRetryTimer(): void {\r\n    if (this.retryTimer) return;\r\n\r\n    this.retryCount++;\r\n    const retryDelay = Utils.getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\r\n\r\n    this.retryTimer = setTimeout(() => {\r\n      /* If connection is not connected, just leave in suspended, a reattach\r\n       * will be triggered once it connects again */\r\n      if (this.state === 'suspended' && this.connectionManager.state.sendEvents) {\r\n        this.retryTimer = null;\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'RealtimeChannel retry timer expired',\r\n          'attempting a new attach',\r\n        );\r\n        this.requestState('attaching');\r\n      }\r\n    }, retryDelay);\r\n  }\r\n\r\n  cancelRetryTimer(): void {\r\n    if (this.retryTimer) {\r\n      clearTimeout(this.retryTimer as NodeJS.Timeout);\r\n      this.retryTimer = null;\r\n    }\r\n  }\r\n\r\n  history = async function (\r\n    this: RealtimeChannel,\r\n    params: RealtimeHistoryParams | null,\r\n  ): Promise<PaginatedResult<Message>> {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);\r\n\r\n    // We fetch this first so that any plugin-not-provided error takes priority over other errors\r\n    const restMixin = this.client.rest.channelMixin;\r\n\r\n    if (params && params.untilAttach) {\r\n      if (this.state !== 'attached') {\r\n        throw new ErrorInfo('option untilAttach requires the channel to be attached', 40000, 400);\r\n      }\r\n      if (!this.properties.attachSerial) {\r\n        throw new ErrorInfo(\r\n          'untilAttach was specified and channel is attached, but attachSerial is not defined',\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n      delete params.untilAttach;\r\n      params.from_serial = this.properties.attachSerial;\r\n    }\r\n\r\n    return restMixin.history(this, params);\r\n  } as any;\r\n\r\n  whenState = ((state: string) => {\r\n    return EventEmitter.prototype.whenState.call(this, state, this.state);\r\n  }) as any;\r\n\r\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\r\n  getReleaseErr(): ErrorInfo | null {\r\n    const s = this.state;\r\n    if (s === 'initialized' || s === 'detached' || s === 'failed') {\r\n      return null;\r\n    }\r\n    return new ErrorInfo(\r\n      'Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' +\r\n        s,\r\n      90001,\r\n      400,\r\n    );\r\n  }\r\n\r\n  setChannelSerial(channelSerial?: string | null): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'RealtimeChannel.setChannelSerial()',\r\n      'Updating channel serial; serial = ' + channelSerial + '; previous = ' + this.properties.channelSerial,\r\n    );\r\n\r\n    // RTP17h: Only update the channel serial if its present (it won't always\r\n    // be set).\r\n    if (channelSerial) {\r\n      this.properties.channelSerial = channelSerial;\r\n    }\r\n  }\r\n\r\n  async status(): Promise<API.ChannelDetails> {\r\n    return this.client.rest.channelMixin.status(this);\r\n  }\r\n}\r\n\r\nfunction omitAgent(channelParams?: API.ChannelParams) {\r\n  const { agent: _, ...paramsWithoutAgent } = channelParams || {};\r\n  return paramsWithoutAgent;\r\n}\r\n\r\nexport default RealtimeChannel;\r\n", "import * as Utils from '../util/utils';\r\nimport BaseClient from './baseclient';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport Connection from './connection';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport ProtocolMessage from '../types/protocolmessage';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport * as API from '../../../../ably';\r\nimport { ModularPlugins, RealtimePresencePlugin } from './modularplugins';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\nimport { TransportImplementations } from 'common/platform';\r\nimport Defaults from '../util/defaults';\r\n\r\n/**\r\n `BaseRealtime` is an export of the tree-shakable version of the SDK, and acts as the base class for the `DefaultRealtime` class exported by the non tree-shakable version.\r\n */\r\nclass BaseRealtime extends BaseClient {\r\n  readonly _RealtimePresence: RealtimePresencePlugin | null;\r\n  // Extra transport implementations available to this client, in addition to those in Platform.Transports.bundledImplementations\r\n  readonly _additionalTransportImplementations: TransportImplementations;\r\n  _channels: any;\r\n  connection: Connection;\r\n\r\n  /*\r\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\r\n   *\r\n   * 1. passes a string (which is quite likely if they\u2019re e.g. migrating from the default variant to the modular variant)\r\n   * 2. passes no argument at all\r\n   *\r\n   * tell the compiler that these cases are possible so that it forces us to handle them.\r\n   */\r\n  constructor(options?: ClientOptions | string) {\r\n    super(Defaults.objectifyOptions(options, false, 'BaseRealtime', Logger.defaultLogger));\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime()', '');\r\n\r\n    // currently we cannot support using Ably.Realtime instances in Vercel Edge runtime.\r\n    // this error can be removed after fixing https://github.com/ably/ably-js/issues/1731,\r\n    // and https://github.com/ably/ably-js/issues/1732\r\n    // @ts-ignore\r\n    if (typeof EdgeRuntime === 'string') {\r\n      throw new ErrorInfo(\r\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime.` +\r\n          ` If you are running Vercel Edge functions, please replace your` +\r\n          ` \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API` +\r\n          ` instead of the Realtime API. If you are server-rendering your application` +\r\n          ` in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\"` +\r\n          ` to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    this._additionalTransportImplementations = BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\r\n    this._RealtimePresence = this.options.plugins?.RealtimePresence ?? null;\r\n    this.connection = new Connection(this, this.options);\r\n    this._channels = new Channels(this);\r\n    if (this.options.autoConnect !== false) this.connect();\r\n  }\r\n\r\n  private static transportImplementationsFromPlugins(plugins?: ModularPlugins) {\r\n    const transports: TransportImplementations = {};\r\n\r\n    if (plugins?.WebSocketTransport) {\r\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\r\n    }\r\n    if (plugins?.XHRPolling) {\r\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\r\n    }\r\n\r\n    return transports;\r\n  }\r\n\r\n  get channels() {\r\n    return this._channels;\r\n  }\r\n\r\n  connect(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime.connect()', '');\r\n    this.connection.connect();\r\n  }\r\n\r\n  close(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime.close()', '');\r\n    this.connection.close();\r\n  }\r\n}\r\n\r\nclass Channels extends EventEmitter {\r\n  realtime: BaseRealtime;\r\n  all: Record<string, RealtimeChannel>;\r\n\r\n  constructor(realtime: BaseRealtime) {\r\n    super(realtime.logger);\r\n    this.realtime = realtime;\r\n    this.all = Object.create(null);\r\n    realtime.connection.connectionManager.on('transport.active', () => {\r\n      this.onTransportActive();\r\n    });\r\n  }\r\n\r\n  channelSerials(): { [name: string]: string } {\r\n    let serials: { [name: string]: string } = {};\r\n    for (const name of Utils.keysArray(this.all, true)) {\r\n      const channel = this.all[name];\r\n      if (channel.properties.channelSerial) {\r\n        serials[name] = channel.properties.channelSerial;\r\n      }\r\n    }\r\n    return serials;\r\n  }\r\n\r\n  // recoverChannels gets the given channels and sets their channel serials.\r\n  recoverChannels(channelSerials: { [name: string]: string }) {\r\n    for (const name of Utils.keysArray(channelSerials, true)) {\r\n      const channel = this.get(name);\r\n      channel.properties.channelSerial = channelSerials[name];\r\n    }\r\n  }\r\n\r\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\r\n  async processChannelMessage(msg: ProtocolMessage) {\r\n    const channelName = msg.channel;\r\n    if (channelName === undefined) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'Channels.processChannelMessage()',\r\n        'received event unspecified channel, action = ' + msg.action,\r\n      );\r\n      return;\r\n    }\r\n    const channel = this.all[channelName];\r\n    if (!channel) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'Channels.processChannelMessage()',\r\n        'received event for non-existent channel: ' + channelName,\r\n      );\r\n      return;\r\n    }\r\n    await channel.processMessage(msg);\r\n  }\r\n\r\n  /* called when a transport becomes connected; reattempt attach/detach\r\n   * for channels that are attaching or detaching. */\r\n  onTransportActive() {\r\n    for (const channelName in this.all) {\r\n      const channel = this.all[channelName];\r\n      if (channel.state === 'attaching' || channel.state === 'detaching') {\r\n        channel.checkPendingState();\r\n      } else if (channel.state === 'suspended') {\r\n        channel._attach(false, null);\r\n      } else if (channel.state === 'attached') {\r\n        // Note explicity request the state, channel.attach() would do nothing\r\n        // as its already attached.\r\n        channel.requestState('attaching');\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Connection interruptions (ie when the connection will no longer queue\r\n   * events) imply connection state changes for any channel which is either\r\n   * attached, pending, or will attempt to become attached in the future */\r\n  propogateConnectionInterruption(connectionState: string, reason: ErrorInfo) {\r\n    const connectionStateToChannelState: Record<string, API.ChannelState> = {\r\n      closing: 'detached',\r\n      closed: 'detached',\r\n      failed: 'failed',\r\n      suspended: 'suspended',\r\n    };\r\n    const fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];\r\n    const toChannelState = connectionStateToChannelState[connectionState];\r\n\r\n    for (const channelId in this.all) {\r\n      const channel = this.all[channelId];\r\n      if (fromChannelStates.includes(channel.state)) {\r\n        channel.notifyState(toChannelState, reason);\r\n      }\r\n    }\r\n  }\r\n\r\n  get(name: string, channelOptions?: ChannelOptions) {\r\n    name = String(name);\r\n    let channel = this.all[name];\r\n    if (!channel) {\r\n      channel = this.all[name] = new RealtimeChannel(this.realtime, name, channelOptions);\r\n    } else if (channelOptions) {\r\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\r\n        throw new ErrorInfo(\r\n          'Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.',\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n      channel.setOptions(channelOptions);\r\n    }\r\n    return channel;\r\n  }\r\n\r\n  getDerived(name: string, deriveOptions: API.DeriveOptions, channelOptions?: ChannelOptions) {\r\n    if (deriveOptions.filter) {\r\n      const filter = Utils.toBase64(deriveOptions.filter);\r\n      const match = Utils.matchDerivedChannel(name);\r\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\r\n    }\r\n    return this.get(name, channelOptions);\r\n  }\r\n\r\n  /* Included to support certain niche use-cases; most users should ignore this.\r\n   * Please do not use this unless you know what you're doing */\r\n  release(name: string) {\r\n    name = String(name);\r\n    const channel = this.all[name];\r\n    if (!channel) {\r\n      return;\r\n    }\r\n    const releaseErr = channel.getReleaseErr();\r\n    if (releaseErr) {\r\n      throw releaseErr;\r\n    }\r\n    delete this.all[name];\r\n  }\r\n}\r\n\r\nexport default BaseRealtime;\r\n", "import * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport PresenceMessage, {\r\n  fromValues as presenceMessageFromValues,\r\n  fromData as presenceMessageFromData,\r\n  encode as encodePresenceMessage,\r\n} from '../types/presencemessage';\r\nimport ErrorInfo, { PartialErrorInfo } from '../types/errorinfo';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport Multicaster from '../util/multicaster';\r\nimport ChannelStateChange from './channelstatechange';\r\nimport { CipherOptions } from '../types/message';\r\nimport { ErrCallback } from '../../types/utils';\r\nimport { PaginatedResult } from './paginatedresource';\r\n\r\ninterface RealtimePresenceParams {\r\n  waitForSync?: boolean;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n}\r\n\r\ninterface RealtimeHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n  untilAttach?: boolean;\r\n  from_serial?: string | null;\r\n}\r\n\r\nfunction getClientId(realtimePresence: RealtimePresence) {\r\n  return realtimePresence.channel.client.auth.clientId;\r\n}\r\n\r\nfunction isAnonymousOrWildcard(realtimePresence: RealtimePresence) {\r\n  const realtime = realtimePresence.channel.client;\r\n  /* If not currently connected, we can't assume that we're an anonymous\r\n   * client, as realtime may inform us of our clientId in the CONNECTED\r\n   * message. So assume we're not anonymous and leave it to realtime to\r\n   * return an error if we are */\r\n  const clientId = realtime.auth.clientId;\r\n  return (!clientId || clientId === '*') && realtime.connection.state === 'connected';\r\n}\r\n\r\n/* Callback is called only in the event of an error */\r\nfunction waitAttached(channel: RealtimeChannel, callback: ErrCallback, action: () => void) {\r\n  switch (channel.state) {\r\n    case 'attached':\r\n    case 'suspended':\r\n      action();\r\n      break;\r\n    case 'initialized':\r\n    case 'detached':\r\n    case 'detaching':\r\n    case 'attaching':\r\n      Utils.whenPromiseSettles(channel.attach(), function (err: Error | null) {\r\n        if (err) callback(err);\r\n        else action();\r\n      });\r\n      break;\r\n    default:\r\n      callback(ErrorInfo.fromValues(channel.invalidStateError()));\r\n  }\r\n}\r\n\r\nfunction newerThan(item: PresenceMessage, existing: PresenceMessage) {\r\n  /* RTP2b1: if either is synthesised, compare by timestamp */\r\n  if (item.isSynthesized() || existing.isSynthesized()) {\r\n    // RTP2b1a: if equal, prefer the newly-arrived one\r\n    return (item.timestamp as number) >= (existing.timestamp as number);\r\n  }\r\n\r\n  /* RTP2b2 */\r\n  const itemOrderings = item.parseId(),\r\n    existingOrderings = existing.parseId();\r\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\r\n    return itemOrderings.index > existingOrderings.index;\r\n  } else {\r\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\r\n  }\r\n}\r\n\r\nclass RealtimePresence extends EventEmitter {\r\n  channel: RealtimeChannel;\r\n  pendingPresence: { presence: PresenceMessage; callback: ErrCallback }[];\r\n  syncComplete: boolean;\r\n  members: PresenceMap;\r\n  _myMembers: PresenceMap;\r\n  subscriptions: EventEmitter;\r\n  name?: string;\r\n\r\n  constructor(channel: RealtimeChannel) {\r\n    super(channel.logger);\r\n    this.channel = channel;\r\n    this.syncComplete = false;\r\n    this.members = new PresenceMap(this, (item) => item.clientId + ':' + item.connectionId);\r\n    // RTP17h: Store own members by clientId only.\r\n    this._myMembers = new PresenceMap(this, (item) => item.clientId!);\r\n    this.subscriptions = new EventEmitter(this.logger);\r\n    this.pendingPresence = [];\r\n  }\r\n\r\n  async enter(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must be specified to enter a presence channel', 40012, 400);\r\n    }\r\n    return this._enterOrUpdateClient(undefined, undefined, data, 'enter');\r\n  }\r\n\r\n  async update(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must be specified to update presence data', 40012, 400);\r\n    }\r\n    return this._enterOrUpdateClient(undefined, undefined, data, 'update');\r\n  }\r\n\r\n  async enterClient(clientId: string, data: unknown): Promise<void> {\r\n    return this._enterOrUpdateClient(undefined, clientId, data, 'enter');\r\n  }\r\n\r\n  async updateClient(clientId: string, data: unknown): Promise<void> {\r\n    return this._enterOrUpdateClient(undefined, clientId, data, 'update');\r\n  }\r\n\r\n  async _enterOrUpdateClient(\r\n    id: string | undefined,\r\n    clientId: string | undefined,\r\n    data: unknown,\r\n    action: string,\r\n  ): Promise<void> {\r\n    const channel = this.channel;\r\n    if (!channel.connectionManager.activeState()) {\r\n      throw channel.connectionManager.getError();\r\n    }\r\n\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.' + action + 'Client()',\r\n      'channel = ' + channel.name + ', id = ' + id + ', client = ' + (clientId || '(implicit) ' + getClientId(this)),\r\n    );\r\n\r\n    const presence = presenceMessageFromData(data);\r\n    presence.action = action;\r\n    if (id) {\r\n      presence.id = id;\r\n    }\r\n    if (clientId) {\r\n      presence.clientId = clientId;\r\n    }\r\n\r\n    await encodePresenceMessage(presence, channel.channelOptions as CipherOptions);\r\n    switch (channel.state) {\r\n      case 'attached':\r\n        return new Promise((resolve, reject) => {\r\n          channel.sendPresence(presence, (err) => (err ? reject(err) : resolve()));\r\n        });\r\n      case 'initialized':\r\n      case 'detached':\r\n        channel.attach();\r\n      // eslint-disable-next-line no-fallthrough\r\n      case 'attaching':\r\n        return new Promise((resolve, reject) => {\r\n          this.pendingPresence.push({\r\n            presence: presence,\r\n            callback: (err) => (err ? reject(err) : resolve()),\r\n          });\r\n        });\r\n      default: {\r\n        const err = new PartialErrorInfo(\r\n          'Unable to ' + action + ' presence channel while in ' + channel.state + ' state',\r\n          90001,\r\n        );\r\n        err.code = 90001;\r\n        throw err;\r\n      }\r\n    }\r\n  }\r\n\r\n  async leave(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must have been specified to enter or leave a presence channel', 40012, 400);\r\n    }\r\n    return this.leaveClient(undefined, data);\r\n  }\r\n\r\n  async leaveClient(clientId?: string, data?: unknown): Promise<void> {\r\n    const channel = this.channel;\r\n    if (!channel.connectionManager.activeState()) {\r\n      throw channel.connectionManager.getError();\r\n    }\r\n\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.leaveClient()',\r\n      'leaving; channel = ' + this.channel.name + ', client = ' + clientId,\r\n    );\r\n    const presence = presenceMessageFromData(data);\r\n    presence.action = 'leave';\r\n    if (clientId) {\r\n      presence.clientId = clientId;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      switch (channel.state) {\r\n        case 'attached':\r\n          channel.sendPresence(presence, (err) => (err ? reject(err) : resolve()));\r\n          break;\r\n        case 'attaching':\r\n          this.pendingPresence.push({\r\n            presence: presence,\r\n            callback: (err) => (err ? reject(err) : resolve()),\r\n          });\r\n          break;\r\n        case 'initialized':\r\n        case 'failed': {\r\n          /* we're not attached; therefore we let any entered status\r\n           * timeout by itself instead of attaching just in order to leave */\r\n          const err = new PartialErrorInfo('Unable to leave presence channel (incompatible state)', 90001);\r\n          reject(err);\r\n          break;\r\n        }\r\n        default:\r\n          reject(channel.invalidStateError());\r\n      }\r\n    });\r\n  }\r\n\r\n  async get(params?: RealtimePresenceParams): Promise<PresenceMessage[]> {\r\n    const waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      function returnMembers(members: PresenceMap) {\r\n        resolve(params ? members.list(params) : members.values());\r\n      }\r\n\r\n      /* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */\r\n      if (this.channel.state === 'suspended') {\r\n        if (waitForSync) {\r\n          reject(\r\n            ErrorInfo.fromValues({\r\n              statusCode: 400,\r\n              code: 91005,\r\n              message: 'Presence state is out of sync due to channel being in the SUSPENDED state',\r\n            }),\r\n          );\r\n        } else {\r\n          returnMembers(this.members);\r\n        }\r\n        return;\r\n      }\r\n\r\n      waitAttached(\r\n        this.channel,\r\n        (err) => reject(err),\r\n        () => {\r\n          const members = this.members;\r\n          if (waitForSync) {\r\n            members.waitSync(function () {\r\n              returnMembers(members);\r\n            });\r\n          } else {\r\n            returnMembers(members);\r\n          }\r\n        },\r\n      );\r\n    });\r\n  }\r\n\r\n  async history(params: RealtimeHistoryParams | null): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);\r\n    // We fetch this first so that any plugin-not-provided error takes priority over other errors\r\n    const restMixin = this.channel.client.rest.presenceMixin;\r\n\r\n    if (params && params.untilAttach) {\r\n      if (this.channel.state === 'attached') {\r\n        delete params.untilAttach;\r\n        params.from_serial = this.channel.properties.attachSerial;\r\n      } else {\r\n        throw new ErrorInfo(\r\n          'option untilAttach requires the channel to be attached, was: ' + this.channel.state,\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n    }\r\n\r\n    return restMixin.history(this, params);\r\n  }\r\n\r\n  setPresence(presenceSet: PresenceMessage[], isSync: boolean, syncChannelSerial?: string): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.setPresence()',\r\n      'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial,\r\n    );\r\n    let syncCursor, match;\r\n    const members = this.members,\r\n      myMembers = this._myMembers,\r\n      broadcastMessages = [],\r\n      connId = this.channel.connectionManager.connectionId;\r\n\r\n    if (isSync) {\r\n      this.members.startSync();\r\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\r\n        syncCursor = match[1];\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < presenceSet.length; i++) {\r\n      const presence = presenceMessageFromValues(presenceSet[i]);\r\n      switch (presence.action) {\r\n        case 'leave':\r\n          if (members.remove(presence)) {\r\n            broadcastMessages.push(presence);\r\n          }\r\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\r\n            myMembers.remove(presence);\r\n          }\r\n          break;\r\n        case 'enter':\r\n        case 'present':\r\n        case 'update':\r\n          if (members.put(presence)) {\r\n            broadcastMessages.push(presence);\r\n          }\r\n          if (presence.connectionId === connId) {\r\n            myMembers.put(presence);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    /* if this is the last (or only) message in a sequence of sync updates, end the sync */\r\n    if (isSync && !syncCursor) {\r\n      members.endSync();\r\n      this.channel.syncChannelSerial = null;\r\n    }\r\n\r\n    /* broadcast to listeners */\r\n    for (let i = 0; i < broadcastMessages.length; i++) {\r\n      const presence = broadcastMessages[i];\r\n      this.subscriptions.emit(presence.action as string, presence);\r\n    }\r\n  }\r\n\r\n  onAttached(hasPresence?: boolean): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'RealtimePresence.onAttached()',\r\n      'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence,\r\n    );\r\n\r\n    if (hasPresence) {\r\n      this.members.startSync();\r\n    } else {\r\n      this._synthesizeLeaves(this.members.values());\r\n      this.members.clear();\r\n    }\r\n\r\n    // RTP17f: Re-enter own members when moving into the attached state.\r\n    this._ensureMyMembersPresent();\r\n\r\n    /* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */\r\n    const pendingPresence = this.pendingPresence,\r\n      pendingPresCount = pendingPresence.length;\r\n\r\n    if (pendingPresCount) {\r\n      this.pendingPresence = [];\r\n      const presenceArray = [];\r\n      const multicaster = Multicaster.create(this.logger);\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'RealtimePresence.onAttached',\r\n        'sending ' + pendingPresCount + ' queued presence messages',\r\n      );\r\n      for (let i = 0; i < pendingPresCount; i++) {\r\n        const event = pendingPresence[i];\r\n        presenceArray.push(event.presence);\r\n        multicaster.push(event.callback);\r\n      }\r\n      this.channel.sendPresence(presenceArray, multicaster);\r\n    }\r\n  }\r\n\r\n  actOnChannelState(state: string, hasPresence?: boolean, err?: ErrorInfo | null): void {\r\n    switch (state) {\r\n      case 'attached':\r\n        this.onAttached(hasPresence);\r\n        break;\r\n      case 'detached':\r\n      case 'failed':\r\n        this._clearMyMembers();\r\n        this.members.clear();\r\n      /* falls through */\r\n      case 'suspended':\r\n        this.failPendingPresence(err);\r\n        break;\r\n    }\r\n  }\r\n\r\n  failPendingPresence(err?: ErrorInfo | null): void {\r\n    if (this.pendingPresence.length) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'RealtimeChannel.failPendingPresence',\r\n        'channel; name = ' + this.channel.name + ', err = ' + Utils.inspectError(err),\r\n      );\r\n      for (let i = 0; i < this.pendingPresence.length; i++)\r\n        try {\r\n          this.pendingPresence[i].callback(err);\r\n          // eslint-disable-next-line no-empty\r\n        } catch (e) {}\r\n      this.pendingPresence = [];\r\n    }\r\n  }\r\n\r\n  _clearMyMembers(): void {\r\n    this._myMembers.clear();\r\n  }\r\n\r\n  _ensureMyMembersPresent(): void {\r\n    const myMembers = this._myMembers,\r\n      reenterCb = (err?: ErrorInfo | null) => {\r\n        if (err) {\r\n          const msg = 'Presence auto-re-enter failed: ' + err.toString();\r\n          const wrappedErr = new ErrorInfo(msg, 91004, 400);\r\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);\r\n          const change = new ChannelStateChange(this.channel.state, this.channel.state, true, false, wrappedErr);\r\n          this.channel.emit('update', change);\r\n        }\r\n      };\r\n\r\n    for (const memberKey in myMembers.map) {\r\n      const entry = myMembers.map[memberKey];\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'RealtimePresence._ensureMyMembersPresent()',\r\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set',\r\n      );\r\n      // RTP17g: Send ENTER containing the member id, clientId and data\r\n      // attributes.\r\n      Utils.whenPromiseSettles(this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, 'enter'), reenterCb);\r\n    }\r\n  }\r\n\r\n  _synthesizeLeaves(items: PresenceMessage[]): void {\r\n    const subscriptions = this.subscriptions;\r\n    items.forEach(function (item) {\r\n      const presence = presenceMessageFromValues({\r\n        action: 'leave',\r\n        connectionId: item.connectionId,\r\n        clientId: item.clientId,\r\n        data: item.data,\r\n        encoding: item.encoding,\r\n        timestamp: Date.now(),\r\n      });\r\n      subscriptions.emit('leave', presence);\r\n    });\r\n  }\r\n\r\n  async subscribe(..._args: unknown[] /* [event], listener */): Promise<void> {\r\n    const args = RealtimeChannel.processListenerArgs(_args);\r\n    const event = args[0];\r\n    const listener = args[1];\r\n    const channel = this.channel;\r\n\r\n    if (channel.state === 'failed') {\r\n      throw ErrorInfo.fromValues(channel.invalidStateError());\r\n    }\r\n\r\n    this.subscriptions.on(event, listener);\r\n    await channel.attach();\r\n  }\r\n\r\n  unsubscribe(..._args: unknown[] /* [event], listener */): void {\r\n    const args = RealtimeChannel.processListenerArgs(_args);\r\n    const event = args[0];\r\n    const listener = args[1];\r\n    this.subscriptions.off(event, listener);\r\n  }\r\n}\r\n\r\nclass PresenceMap extends EventEmitter {\r\n  map: Record<string, PresenceMessage>;\r\n  residualMembers: Record<string, PresenceMessage> | null;\r\n  syncInProgress: boolean;\r\n  presence: RealtimePresence;\r\n  memberKey: (item: PresenceMessage) => string;\r\n\r\n  constructor(presence: RealtimePresence, memberKey: (item: PresenceMessage) => string) {\r\n    super(presence.logger);\r\n    this.presence = presence;\r\n    this.map = Object.create(null);\r\n    this.syncInProgress = false;\r\n    this.residualMembers = null;\r\n    this.memberKey = memberKey;\r\n  }\r\n\r\n  get(key: string) {\r\n    return this.map[key];\r\n  }\r\n\r\n  getClient(clientId: string) {\r\n    const map = this.map,\r\n      result = [];\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.clientId == clientId && item.action != 'absent') result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  list(params: RealtimePresenceParams) {\r\n    const map = this.map,\r\n      clientId = params && params.clientId,\r\n      connectionId = params && params.connectionId,\r\n      result = [];\r\n\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.action === 'absent') continue;\r\n      if (clientId && clientId != item.clientId) continue;\r\n      if (connectionId && connectionId != item.connectionId) continue;\r\n      result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  put(item: PresenceMessage) {\r\n    if (item.action === 'enter' || item.action === 'update') {\r\n      item = presenceMessageFromValues(item);\r\n      item.action = 'present';\r\n    }\r\n    const map = this.map,\r\n      key = this.memberKey(item);\r\n    /* we've seen this member, so do not remove it at the end of sync */\r\n    if (this.residualMembers) delete this.residualMembers[key];\r\n\r\n    /* compare the timestamp of the new item with any existing member (or ABSENT witness) */\r\n    const existingItem = map[key];\r\n    if (existingItem && !newerThan(item, existingItem)) {\r\n      return false;\r\n    }\r\n    map[key] = item;\r\n    return true;\r\n  }\r\n\r\n  values() {\r\n    const map = this.map,\r\n      result = [];\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.action != 'absent') result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  remove(item: PresenceMessage) {\r\n    const map = this.map,\r\n      key = this.memberKey(item);\r\n    const existingItem = map[key];\r\n\r\n    if (existingItem && !newerThan(item, existingItem)) {\r\n      return false;\r\n    }\r\n\r\n    /* RTP2f */\r\n    if (this.syncInProgress) {\r\n      item = presenceMessageFromValues(item);\r\n      item.action = 'absent';\r\n      map[key] = item;\r\n    } else {\r\n      delete map[key];\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  startSync() {\r\n    const map = this.map,\r\n      syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.startSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    /* we might be called multiple times while a sync is in progress */\r\n    if (!this.syncInProgress) {\r\n      this.residualMembers = Utils.copy(map);\r\n      this.setInProgress(true);\r\n    }\r\n  }\r\n\r\n  endSync() {\r\n    const map = this.map,\r\n      syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.endSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    if (syncInProgress) {\r\n      /* we can now strip out the ABSENT members, as we have\r\n       * received all of the out-of-order sync messages */\r\n      for (const memberKey in map) {\r\n        const entry = map[memberKey];\r\n        if (entry.action === 'absent') {\r\n          delete map[memberKey];\r\n        }\r\n      }\r\n      /* any members that were present at the start of the sync,\r\n       * and have not been seen in sync, can be removed, and leave events emitted */\r\n      this.presence._synthesizeLeaves(Utils.valuesArray(this.residualMembers as Record<string, PresenceMessage>));\r\n      for (const memberKey in this.residualMembers) {\r\n        delete map[memberKey];\r\n      }\r\n      this.residualMembers = null;\r\n\r\n      /* finish, notifying any waiters */\r\n      this.setInProgress(false);\r\n    }\r\n    this.emit('sync');\r\n  }\r\n\r\n  waitSync(callback: () => void) {\r\n    const syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.waitSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    if (!syncInProgress) {\r\n      callback();\r\n      return;\r\n    }\r\n    this.once('sync', callback);\r\n  }\r\n\r\n  clear() {\r\n    this.map = {};\r\n    this.setInProgress(false);\r\n    this.residualMembers = null;\r\n  }\r\n\r\n  setInProgress(inProgress: boolean) {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);\r\n    this.syncInProgress = inProgress;\r\n    this.presence.syncComplete = !inProgress;\r\n  }\r\n}\r\n\r\nexport default RealtimePresence;\r\n", "import Platform from 'common/platform';\r\nimport * as Utils from '../util/utils';\r\nimport Transport from './transport';\r\nimport Defaults from '../util/defaults';\r\nimport Logger from '../util/logger';\r\nimport ProtocolMessage, {\r\n  serialize as serializeProtocolMessage,\r\n  deserialize as deserializeProtocolMessage,\r\n} from '../types/protocolmessage';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport NodeWebSocket from 'ws';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport Auth from '../client/auth';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nconst shortName = TransportNames.WebSocket;\r\n\r\nfunction isNodeWebSocket(ws: WebSocket | NodeWebSocket): ws is NodeWebSocket {\r\n  return !!(ws as NodeWebSocket).on;\r\n}\r\n\r\nclass WebSocketTransport extends Transport {\r\n  shortName = shortName;\r\n  wsHost: string;\r\n  uri?: string;\r\n  wsConnection?: WebSocket | NodeWebSocket;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params);\r\n    /* If is a browser, can't detect pings, so request protocol heartbeats */\r\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\r\n    this.wsHost = params.host as string;\r\n  }\r\n\r\n  static isAvailable() {\r\n    return !!Platform.Config.WebSocket;\r\n  }\r\n\r\n  createWebSocket(uri: string, connectParams: Record<string, string>) {\r\n    this.uri = uri + Utils.toQueryString(connectParams);\r\n    return new Platform.Config.WebSocket(this.uri);\r\n  }\r\n\r\n  toString() {\r\n    return 'WebSocketTransport; uri=' + this.uri;\r\n  }\r\n\r\n  connect() {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'starting');\r\n    Transport.prototype.connect.call(this);\r\n    const self = this,\r\n      params = this.params,\r\n      options = params.options;\r\n    const wsScheme = options.tls ? 'wss://' : 'ws://';\r\n    const wsUri = wsScheme + this.wsHost + ':' + Defaults.getPort(options) + '/';\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);\r\n    Utils.whenPromiseSettles(\r\n      this.auth.getAuthParams(),\r\n      function (err: ErrorInfo | null, authParams?: Record<string, string>) {\r\n        if (self.isDisposed) {\r\n          return;\r\n        }\r\n        let paramStr = '';\r\n        for (const param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';\r\n        Logger.logAction(\r\n          self.logger,\r\n          Logger.LOG_MINOR,\r\n          'WebSocketTransport.connect()',\r\n          'authParams:' + paramStr + ' err: ' + err,\r\n        );\r\n        if (err) {\r\n          self.disconnect(err);\r\n          return;\r\n        }\r\n        const connectParams = params.getConnectParams(authParams!);\r\n        try {\r\n          const wsConnection = (self.wsConnection = self.createWebSocket(wsUri, connectParams));\r\n          wsConnection.binaryType = Platform.Config.binaryType;\r\n          wsConnection.onopen = function () {\r\n            self.onWsOpen();\r\n          };\r\n          wsConnection.onclose = function (ev: CloseEvent) {\r\n            self.onWsClose(ev);\r\n          };\r\n          wsConnection.onmessage = function (ev: MessageEvent) {\r\n            self.onWsData(ev.data);\r\n          };\r\n          wsConnection.onerror = function (ev: Event) {\r\n            self.onWsError(ev as ErrorEvent);\r\n          };\r\n          if (isNodeWebSocket(wsConnection)) {\r\n            /* node; browsers currently don't have a general eventemitter and can't detect\r\n             * pings. Also, no need to reply with a pong explicitly, ws lib handles that */\r\n            wsConnection.on('ping', function () {\r\n              self.onActivity();\r\n            });\r\n          }\r\n        } catch (e) {\r\n          Logger.logAction(\r\n            self.logger,\r\n            Logger.LOG_ERROR,\r\n            'WebSocketTransport.connect()',\r\n            'Unexpected exception creating websocket: err = ' + ((e as Error).stack || (e as Error).message),\r\n          );\r\n          self.disconnect(e as Error);\r\n        }\r\n      },\r\n    );\r\n  }\r\n\r\n  send(message: ProtocolMessage) {\r\n    const wsConnection = this.wsConnection;\r\n    if (!wsConnection) {\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');\r\n      return;\r\n    }\r\n    try {\r\n      (wsConnection as NodeWebSocket).send(\r\n        serializeProtocolMessage(message, this.connectionManager.realtime._MsgPack, this.params.format),\r\n      );\r\n    } catch (e) {\r\n      const msg = 'Exception from ws connection when trying to send: ' + Utils.inspectError(e);\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'WebSocketTransport.send()', msg);\r\n      /* Don't try to request a disconnect, that'll just involve sending data\r\n       * down the websocket again. Just finish the transport. */\r\n      this.finish('disconnected', new ErrorInfo(msg, 50000, 500));\r\n    }\r\n  }\r\n\r\n  onWsData(data: string) {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'WebSocketTransport.onWsData()',\r\n      'data received; length = ' + data.length + '; type = ' + typeof data,\r\n    );\r\n    try {\r\n      this.onProtocolMessage(\r\n        deserializeProtocolMessage(\r\n          data,\r\n          this.connectionManager.realtime._MsgPack,\r\n          this.connectionManager.realtime._RealtimePresence,\r\n          this.format,\r\n        ),\r\n      );\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'WebSocketTransport.onWsData()',\r\n        'Unexpected exception handing channel message: ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  onWsOpen() {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');\r\n    this.emit('preconnect');\r\n  }\r\n\r\n  onWsClose(ev: number | CloseEvent) {\r\n    let wasClean, code;\r\n    if (typeof ev == 'object') {\r\n      /* W3C spec-compatible */\r\n      code = ev.code;\r\n      // ev.wasClean is undefined in reactnative\r\n      wasClean = ev.wasClean || code === 1000;\r\n    } /*if(typeof(ev) == 'number')*/ else {\r\n      /* ws in node */\r\n      code = ev;\r\n      wasClean = code == 1000;\r\n    }\r\n    delete this.wsConnection;\r\n    if (wasClean) {\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');\r\n      const err = new ErrorInfo('Websocket closed', 80003, 400);\r\n      this.finish('disconnected', err);\r\n    } else {\r\n      const msg = 'Unclean disconnection of WebSocket ; code = ' + code,\r\n        err = new ErrorInfo(msg, 80003, 400);\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);\r\n      this.finish('disconnected', err);\r\n    }\r\n    this.emit('disposed');\r\n  }\r\n\r\n  onWsError(err: ErrorEvent) {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'WebSocketTransport.onError()',\r\n      'Error from WebSocket: ' + err.message,\r\n    );\r\n    /* Wait a tick before aborting: if the websocket was connected, this event\r\n     * will be immediately followed by an onclose event with a close code. Allow\r\n     * that to close it (so we see the close code) rather than anticipating it */\r\n    Platform.Config.nextTick(() => {\r\n      this.disconnect(Error(err.message));\r\n    });\r\n  }\r\n\r\n  dispose() {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.dispose()', '');\r\n    this.isDisposed = true;\r\n    const wsConnection = this.wsConnection;\r\n    if (wsConnection) {\r\n      /* Ignore any messages that come through after dispose() is called but before\r\n       * websocket is actually closed. (mostly would be harmless, but if it's a\r\n       * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */\r\n      wsConnection.onmessage = function () {};\r\n      delete this.wsConnection;\r\n      /* defer until the next event loop cycle before closing the socket,\r\n       * giving some implementations the opportunity to send any outstanding close message */\r\n      Platform.Config.nextTick(() => {\r\n        Logger.logAction(this.logger, Logger.LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');\r\n        if (!wsConnection) {\r\n          throw new Error('WebSocketTransport.dispose(): wsConnection is not defined');\r\n        }\r\n        wsConnection.close();\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport default WebSocketTransport;\r\n", "import * as API from '../../../../ably';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport Message from '../types/message';\r\n\r\nexport class FilteredSubscriptions {\r\n  static subscribeFilter(channel: RealtimeChannel, filter: API.MessageFilter, listener: API.messageCallback<Message>) {\r\n    const filteredListener = (m: Message) => {\r\n      const mapping: { [key in keyof API.MessageFilter]: any } = {\r\n        name: m.name,\r\n        refTimeserial: m.extras?.ref?.timeserial,\r\n        refType: m.extras?.ref?.type,\r\n        isRef: !!m.extras?.ref?.timeserial,\r\n        clientId: m.clientId,\r\n      };\r\n      // Check if any values are defined in the filter and if they match the value in the message object\r\n      if (\r\n        Object.entries(filter).find(([key, value]) =>\r\n          value !== undefined ? mapping[key as keyof API.MessageFilter] !== value : false,\r\n        )\r\n      ) {\r\n        return;\r\n      }\r\n      listener(m);\r\n    };\r\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\r\n    channel.subscriptions.on(filteredListener);\r\n  }\r\n\r\n  // Adds a new filtered subscription\r\n  static addFilteredSubscription(\r\n    channel: RealtimeChannel,\r\n    filter: API.MessageFilter,\r\n    realListener: API.messageCallback<Message>,\r\n    filteredListener: API.messageCallback<Message>,\r\n  ) {\r\n    if (!channel.filteredSubscriptions) {\r\n      channel.filteredSubscriptions = new Map<\r\n        API.messageCallback<Message>,\r\n        Map<API.MessageFilter, API.messageCallback<Message>[]>\r\n      >();\r\n    }\r\n    if (channel.filteredSubscriptions.has(realListener)) {\r\n      const realListenerMap = channel.filteredSubscriptions.get(realListener) as Map<\r\n        API.MessageFilter,\r\n        API.messageCallback<Message>[]\r\n      >;\r\n      // Add the filtered listener to the map, or append to the array if this filter has already been used\r\n      realListenerMap.set(filter, realListenerMap?.get(filter)?.concat(filteredListener) || [filteredListener]);\r\n    } else {\r\n      channel.filteredSubscriptions.set(\r\n        realListener,\r\n        new Map<API.MessageFilter, API.messageCallback<Message>[]>([[filter, [filteredListener]]]),\r\n      );\r\n    }\r\n  }\r\n\r\n  static getAndDeleteFilteredSubscriptions(\r\n    channel: RealtimeChannel,\r\n    filter: API.MessageFilter | undefined,\r\n    realListener: API.messageCallback<Message> | undefined,\r\n  ): API.messageCallback<Message>[] {\r\n    // No filtered subscriptions map means there has been no filtered subscriptions yet, so return nothing\r\n    if (!channel.filteredSubscriptions) {\r\n      return [];\r\n    }\r\n    // Only a filter is passed in with no specific listener\r\n    if (!realListener && filter) {\r\n      // Return each listener which is attached to the specified filter object\r\n      return Array.from(channel.filteredSubscriptions.entries())\r\n        .map(([key, filterMaps]) => {\r\n          // Get (then delete) the maps matching this filter\r\n          let listenerMaps = filterMaps.get(filter);\r\n          filterMaps.delete(filter);\r\n          // Clear the parent if nothing is left\r\n          if (filterMaps.size === 0) {\r\n            channel.filteredSubscriptions?.delete(key);\r\n          }\r\n          return listenerMaps;\r\n        })\r\n        .reduce(\r\n          (prev, cur) => (cur ? (prev as API.messageCallback<Message>[]).concat(...cur) : prev),\r\n          [],\r\n        ) as API.messageCallback<Message>[];\r\n    }\r\n\r\n    // No subscriptions for this listener\r\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\r\n      return [];\r\n    }\r\n    const realListenerMap = channel.filteredSubscriptions.get(realListener) as Map<\r\n      API.MessageFilter,\r\n      API.messageCallback<Message>[]\r\n    >;\r\n    // If no filter is specified return all listeners using that function\r\n    if (!filter) {\r\n      // array.flat is not available unless we support es2019 or higher\r\n      const listeners = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\r\n      // remove the listener from the map\r\n      channel.filteredSubscriptions.delete(realListener);\r\n      return listeners;\r\n    }\r\n\r\n    let listeners = realListenerMap.get(filter);\r\n    realListenerMap.delete(filter);\r\n\r\n    return listeners || [];\r\n  }\r\n}\r\n", "import BaseRealtime from './baserealtime';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { allCommonModularPlugins } from './modularplugins';\r\nimport * as Utils from '../util/utils';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport ProtocolMessage from '../types/protocolmessage';\r\nimport Platform from 'common/platform';\r\nimport { DefaultMessage } from '../types/defaultmessage';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport RealtimePresence from './realtimepresence';\r\nimport { DefaultPresenceMessage } from '../types/defaultpresencemessage';\r\nimport WebSocketTransport from '../transport/websockettransport';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\nimport {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from '../types/presencemessage';\r\nimport { Http } from 'common/types/http';\r\nimport Defaults from '../util/defaults';\r\nimport Logger from '../util/logger';\r\n\r\n/**\r\n `DefaultRealtime` is the class that the non tree-shakable version of the SDK exports as `Realtime`. It ensures that this version of the SDK includes all of the functionality which is optionally available in the tree-shakable version.\r\n */\r\nexport class DefaultRealtime extends BaseRealtime {\r\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\r\n  constructor(options?: ClientOptions | string) {\r\n    const MsgPack = DefaultRealtime._MsgPack;\r\n    if (!MsgPack) {\r\n      throw new Error('Expected DefaultRealtime._MsgPack to have been set');\r\n    }\r\n\r\n    super(\r\n      Defaults.objectifyOptions(options, true, 'Realtime', Logger.defaultLogger, {\r\n        ...allCommonModularPlugins,\r\n        Crypto: DefaultRealtime.Crypto ?? undefined,\r\n        MsgPack,\r\n        RealtimePresence: {\r\n          RealtimePresence,\r\n          presenceMessageFromValues,\r\n          presenceMessagesFromValuesArray,\r\n        },\r\n        WebSocketTransport,\r\n        MessageInteractions: FilteredSubscriptions,\r\n      }),\r\n    );\r\n  }\r\n\r\n  static Utils = Utils;\r\n  static ConnectionManager = ConnectionManager;\r\n  static ProtocolMessage = ProtocolMessage;\r\n\r\n  private static _Crypto: typeof Platform.Crypto = null;\r\n  static get Crypto() {\r\n    if (this._Crypto === null) {\r\n      throw new Error('Encryption not enabled; use ably.encryption.js instead');\r\n    }\r\n\r\n    return this._Crypto;\r\n  }\r\n  static set Crypto(newValue: typeof Platform.Crypto) {\r\n    this._Crypto = newValue;\r\n  }\r\n\r\n  static Message = DefaultMessage;\r\n  static PresenceMessage = DefaultPresenceMessage;\r\n\r\n  static _MsgPack: MsgPack | null = null;\r\n\r\n  // Used by tests\r\n  static _Http = Http;\r\n}\r\n", "/**\r\n * Copied from https://gist.github.com/stevendesu/2d52f7b5e1f1184af3b667c0b5e054b8\r\n *\r\n * \"A simple, open-source, HMAC-SHA256 implementation in pure JavaScript. Designed for efficient minification.\"\r\n *\r\n * I asked about licensing, and the author said:\r\n *\r\n * > Feel free to use it however you'd like \uD83D\uDE04 As the gist title indicates,\r\n * > this is \"a simple open source implementation\". Feel free to choose whatever\r\n * > license you find most permissible, but I offer no warranty for the code.\r\n * > It's 100% free to do with as you please.\r\n */\r\n\r\n// To ensure cross-browser support even without a proper SubtleCrypto\r\n// impelmentation (or without access to the impelmentation, as is the case with\r\n// Chrome loaded over HTTP instead of HTTPS), this library can create SHA-256\r\n// HMAC signatures using nothing but raw JavaScript\r\n\r\n/* eslint-disable no-magic-numbers, id-length, no-param-reassign, new-cap */\r\n\r\n// By giving internal functions names that we can mangle, future calls to\r\n// them are reduced to a single byte (minor space savings in minified file)\r\nvar uint8Array = Uint8Array;\r\nvar uint32Array = Uint32Array;\r\nvar pow = Math.pow;\r\n\r\n// Will be initialized below\r\n// Using a Uint32Array instead of a simple array makes the minified code\r\n// a bit bigger (we lose our `unshift()` hack), but comes with huge\r\n// performance gains\r\nvar DEFAULT_STATE = new uint32Array(8);\r\nvar ROUND_CONSTANTS: number[] = [];\r\n\r\n// Reusable object for expanded message\r\n// Using a Uint32Array instead of a simple array makes the minified code\r\n// 7 bytes larger, but comes with huge performance gains\r\nvar M = new uint32Array(64);\r\n\r\n// After minification the code to compute the default state and round\r\n// constants is smaller than the output. More importantly, this serves as a\r\n// good educational aide for anyone wondering where the magic numbers come\r\n// from. No magic numbers FTW!\r\nfunction getFractionalBits(n: number) {\r\n  return ((n - (n | 0)) * pow(2, 32)) | 0;\r\n}\r\n\r\nvar n = 2,\r\n  nPrime = 0;\r\nwhile (nPrime < 64) {\r\n  // isPrime() was in-lined from its original function form to save\r\n  // a few bytes\r\n  var isPrime = true;\r\n  // Math.sqrt() was replaced with pow(n, 1/2) to save a few bytes\r\n  // var sqrtN = pow(n, 1 / 2);\r\n  // So technically to determine if a number is prime you only need to\r\n  // check numbers up to the square root. However this function only runs\r\n  // once and we're only computing the first 64 primes (up to 311), so on\r\n  // any modern CPU this whole function runs in a couple milliseconds.\r\n  // By going to n / 2 instead of sqrt(n) we net 8 byte savings and no\r\n  // scaling performance cost\r\n  for (var factor = 2; factor <= n / 2; factor++) {\r\n    if (n % factor === 0) {\r\n      isPrime = false;\r\n    }\r\n  }\r\n  if (isPrime) {\r\n    if (nPrime < 8) {\r\n      DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));\r\n    }\r\n    ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));\r\n\r\n    nPrime++;\r\n  }\r\n\r\n  n++;\r\n}\r\n\r\n// For cross-platform support we need to ensure that all 32-bit words are\r\n// in the same endianness. A UTF-8 TextEncoder will return BigEndian data,\r\n// so upon reading or writing to our ArrayBuffer we'll only swap the bytes\r\n// if our system is LittleEndian (which is about 99% of CPUs)\r\nvar LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];\r\n\r\nfunction convertEndian(word: number) {\r\n  if (LittleEndian) {\r\n    return (\r\n      // byte 1 -> byte 4\r\n      (word >>> 24) |\r\n      // byte 2 -> byte 3\r\n      (((word >>> 16) & 0xff) << 8) |\r\n      // byte 3 -> byte 2\r\n      ((word & 0xff00) << 8) |\r\n      // byte 4 -> byte 1\r\n      (word << 24)\r\n    );\r\n  } else {\r\n    return word;\r\n  }\r\n}\r\n\r\nfunction rightRotate(word: number, bits: number) {\r\n  return (word >>> bits) | (word << (32 - bits));\r\n}\r\n\r\nfunction sha256(data: Uint8Array) {\r\n  // Copy default state\r\n  var STATE = DEFAULT_STATE.slice();\r\n\r\n  // Caching this reduces occurrences of \".length\" in minified JavaScript\r\n  // 3 more byte savings! :D\r\n  var legth = data.length;\r\n\r\n  // Pad data\r\n  var bitLength = legth * 8;\r\n  var newBitLength = 512 - ((bitLength + 64) % 512) - 1 + bitLength + 65;\r\n\r\n  // \"bytes\" and \"words\" are stored BigEndian\r\n  var bytes = new uint8Array(newBitLength / 8);\r\n  var words = new uint32Array(bytes.buffer);\r\n\r\n  bytes.set(data, 0);\r\n  // Append a 1\r\n  bytes[legth] = 0b10000000;\r\n  // Store length in BigEndian\r\n  words[words.length - 1] = convertEndian(bitLength);\r\n\r\n  // Loop iterator (avoid two instances of \"var\") -- saves 2 bytes\r\n  var round;\r\n\r\n  // Process blocks (512 bits / 64 bytes / 16 words at a time)\r\n  for (var block = 0; block < newBitLength / 32; block += 16) {\r\n    var workingState = STATE.slice();\r\n\r\n    // Rounds\r\n    for (round = 0; round < 64; round++) {\r\n      var MRound;\r\n      // Expand message\r\n      if (round < 16) {\r\n        // Convert to platform Endianness for later math\r\n        MRound = convertEndian(words[block + round]);\r\n      } else {\r\n        var gamma0x = M[round - 15];\r\n        var gamma1x = M[round - 2];\r\n        MRound =\r\n          M[round - 7] +\r\n          M[round - 16] +\r\n          (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ (gamma0x >>> 3)) +\r\n          (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ (gamma1x >>> 10));\r\n      }\r\n\r\n      // M array matches platform endianness\r\n      M[round] = MRound |= 0;\r\n\r\n      // Computation\r\n      var t1 =\r\n        (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) +\r\n        ((workingState[4] & workingState[5]) ^ (~workingState[4] & workingState[6])) +\r\n        workingState[7] +\r\n        MRound +\r\n        ROUND_CONSTANTS[round];\r\n      var t2 =\r\n        (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) +\r\n        ((workingState[0] & workingState[1]) ^ (workingState[2] & (workingState[0] ^ workingState[1])));\r\n      for (var i = 7; i > 0; i--) {\r\n        workingState[i] = workingState[i - 1];\r\n      }\r\n      workingState[0] = (t1 + t2) | 0;\r\n      workingState[4] = (workingState[4] + t1) | 0;\r\n    }\r\n\r\n    // Update state\r\n    for (round = 0; round < 8; round++) {\r\n      STATE[round] = (STATE[round] + workingState[round]) | 0;\r\n    }\r\n  }\r\n\r\n  // Finally the state needs to be converted to BigEndian for output\r\n  // And we want to return a Uint8Array, not a Uint32Array\r\n  return new uint8Array(\r\n    new uint32Array(\r\n      STATE.map(function (val) {\r\n        return convertEndian(val);\r\n      }),\r\n    ).buffer,\r\n  );\r\n}\r\n\r\nexport function hmac(key: Uint8Array, data: Uint8Array) {\r\n  if (key.length > 64) key = sha256(key);\r\n\r\n  if (key.length < 64) {\r\n    const tmp = new Uint8Array(64);\r\n    tmp.set(key, 0);\r\n    key = tmp;\r\n  }\r\n\r\n  // Generate inner and outer keys\r\n  var innerKey = new Uint8Array(64);\r\n  var outerKey = new Uint8Array(64);\r\n  for (var i = 0; i < 64; i++) {\r\n    innerKey[i] = 0x36 ^ key[i];\r\n    outerKey[i] = 0x5c ^ key[i];\r\n  }\r\n\r\n  // Append the innerKey\r\n  var msg = new Uint8Array(data.length + 64);\r\n  msg.set(innerKey, 0);\r\n  msg.set(data, 64);\r\n\r\n  // Has the previous message and append the outerKey\r\n  var result = new Uint8Array(64 + 32);\r\n  result.set(outerKey, 0);\r\n  result.set(sha256(msg), 64);\r\n\r\n  // Hash the previous message\r\n  return sha256(result);\r\n}\r\n", "import Platform from 'common/platform';\r\nimport IBufferUtils from 'common/types/IBufferUtils';\r\nimport { hmac as hmacSha256 } from './hmac-sha256';\r\n\r\n/* Most BufferUtils methods that return a binary object return an ArrayBuffer\r\n * The exception is toBuffer, which returns a Uint8Array */\r\n\r\nexport type Bufferlike = BufferSource;\r\nexport type Output = Bufferlike;\r\nexport type ToBufferOutput = Uint8Array;\r\n\r\nclass BufferUtils implements IBufferUtils<Bufferlike, Output, ToBufferOutput> {\r\n  base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n  hexCharSet = '0123456789abcdef';\r\n\r\n  // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js\r\n  private uint8ViewToBase64(bytes: Uint8Array): string {\r\n    let base64 = '';\r\n    const encodings = this.base64CharSet;\r\n\r\n    const byteLength = bytes.byteLength;\r\n    const byteRemainder = byteLength % 3;\r\n    const mainLength = byteLength - byteRemainder;\r\n\r\n    let a, b, c, d;\r\n    let chunk;\r\n\r\n    // Main loop deals with bytes in chunks of 3\r\n    for (let i = 0; i < mainLength; i = i + 3) {\r\n      // Combine the three bytes into a single integer\r\n      chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\r\n\r\n      // Use bitmasks to extract 6-bit segments from the triplet\r\n      a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\r\n      b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\r\n      c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\r\n      d = chunk & 63; // 63       = 2^6 - 1\r\n\r\n      // Convert the raw binary segments to the appropriate ASCII encoding\r\n      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\r\n    }\r\n\r\n    // Deal with the remaining bytes and padding\r\n    if (byteRemainder == 1) {\r\n      chunk = bytes[mainLength];\r\n\r\n      a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\r\n\r\n      // Set the 4 least significant bits to zero\r\n      b = (chunk & 3) << 4; // 3   = 2^2 - 1\r\n\r\n      base64 += encodings[a] + encodings[b] + '==';\r\n    } else if (byteRemainder == 2) {\r\n      chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\r\n\r\n      a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\r\n      b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\r\n\r\n      // Set the 2 least significant bits to zero\r\n      c = (chunk & 15) << 2; // 15    = 2^4 - 1\r\n\r\n      base64 += encodings[a] + encodings[b] + encodings[c] + '=';\r\n    }\r\n\r\n    return base64;\r\n  }\r\n\r\n  private base64ToArrayBuffer(base64: string): Output {\r\n    const binary_string = atob?.(base64) as string; // this will always be defined in browser so it's safe to cast\r\n    const len = binary_string.length;\r\n    const bytes = new Uint8Array(len);\r\n    for (let i = 0; i < len; i++) {\r\n      const ascii = binary_string.charCodeAt(i);\r\n      bytes[i] = ascii;\r\n    }\r\n    return this.toArrayBuffer(bytes);\r\n  }\r\n\r\n  isBuffer(buffer: unknown): buffer is Bufferlike {\r\n    return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\r\n  }\r\n\r\n  toBuffer(buffer: Bufferlike): ToBufferOutput {\r\n    if (!ArrayBuffer) {\r\n      throw new Error(\"Can't convert to Buffer: browser does not support the necessary types\");\r\n    }\r\n\r\n    if (buffer instanceof ArrayBuffer) {\r\n      return new Uint8Array(buffer);\r\n    }\r\n\r\n    if (ArrayBuffer.isView(buffer)) {\r\n      return new Uint8Array(this.toArrayBuffer(buffer));\r\n    }\r\n\r\n    throw new Error('BufferUtils.toBuffer expected an ArrayBuffer or a view onto one');\r\n  }\r\n\r\n  toArrayBuffer(buffer: Bufferlike): ArrayBuffer {\r\n    if (!ArrayBuffer) {\r\n      throw new Error(\"Can't convert to ArrayBuffer: browser does not support the necessary types\");\r\n    }\r\n\r\n    if (buffer instanceof ArrayBuffer) {\r\n      return buffer;\r\n    }\r\n\r\n    if (ArrayBuffer.isView(buffer)) {\r\n      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n    }\r\n\r\n    throw new Error('BufferUtils.toArrayBuffer expected an ArrayBuffer or a view onto one');\r\n  }\r\n\r\n  base64Encode(buffer: Bufferlike): string {\r\n    return this.uint8ViewToBase64(this.toBuffer(buffer));\r\n  }\r\n\r\n  base64Decode(str: string): Output {\r\n    if (ArrayBuffer && Platform.Config.atob) {\r\n      return this.base64ToArrayBuffer(str);\r\n    } else {\r\n      throw new Error('Expected ArrayBuffer to exist and Platform.Config.atob to be configured');\r\n    }\r\n  }\r\n\r\n  hexEncode(buffer: Bufferlike): string {\r\n    const uint8Array = this.toBuffer(buffer);\r\n    return uint8Array.reduce((accum, byte) => accum + byte.toString(16).padStart(2, '0'), '');\r\n  }\r\n\r\n  hexDecode(hexEncodedBytes: string): Output {\r\n    if (hexEncodedBytes.length % 2 !== 0) {\r\n      throw new Error(\"Can't create a byte array from a hex string of odd length\");\r\n    }\r\n\r\n    const uint8Array = new Uint8Array(hexEncodedBytes.length / 2);\r\n\r\n    for (let i = 0; i < uint8Array.length; i++) {\r\n      uint8Array[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);\r\n    }\r\n\r\n    return this.toArrayBuffer(uint8Array);\r\n  }\r\n\r\n  utf8Encode(string: string): Output {\r\n    if (Platform.Config.TextEncoder) {\r\n      const encodedByteArray = new Platform.Config.TextEncoder().encode(string);\r\n      return this.toArrayBuffer(encodedByteArray);\r\n    } else {\r\n      throw new Error('Expected TextEncoder to be configured');\r\n    }\r\n  }\r\n\r\n  /* For utf8 decoding we apply slightly stricter input validation than to\r\n   * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from\r\n   * can take (in particular allowing strings, which are just interpreted as\r\n   * binary); here we ensure that the input is actually a buffer since trying\r\n   * to utf8-decode a string to another string is almost certainly a mistake */\r\n  utf8Decode(buffer: Bufferlike): string {\r\n    if (!this.isBuffer(buffer)) {\r\n      throw new Error('Expected input of utf8decode to be an arraybuffer or typed array');\r\n    }\r\n    if (TextDecoder) {\r\n      return new TextDecoder().decode(buffer);\r\n    } else {\r\n      throw new Error('Expected TextDecoder to be configured');\r\n    }\r\n  }\r\n\r\n  areBuffersEqual(buffer1: Bufferlike, buffer2: Bufferlike): boolean {\r\n    if (!buffer1 || !buffer2) return false;\r\n    const arrayBuffer1 = this.toArrayBuffer(buffer1);\r\n    const arrayBuffer2 = this.toArrayBuffer(buffer2);\r\n\r\n    if (arrayBuffer1.byteLength != arrayBuffer2.byteLength) return false;\r\n\r\n    const bytes1 = new Uint8Array(arrayBuffer1);\r\n    const bytes2 = new Uint8Array(arrayBuffer2);\r\n\r\n    for (var i = 0; i < bytes1.length; i++) {\r\n      if (bytes1[i] != bytes2[i]) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  byteLength(buffer: Bufferlike): number {\r\n    if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {\r\n      return buffer.byteLength;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  arrayBufferViewToBuffer(arrayBufferView: ArrayBufferView): ArrayBuffer {\r\n    return this.toArrayBuffer(arrayBufferView);\r\n  }\r\n\r\n  hmacSha256(message: Bufferlike, key: Bufferlike): Output {\r\n    const hash = hmacSha256(this.toBuffer(key), this.toBuffer(message));\r\n    return this.toArrayBuffer(hash);\r\n  }\r\n}\r\n\r\nexport default new BufferUtils();\r\n", "import Logger from '../../../../common/lib/util/logger';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport * as API from '../../../../../ably';\r\nimport ICryptoStatic, { IGetCipherParams } from '../../../../common/types/ICryptoStatic';\r\nimport ICipher from '../../../../common/types/ICipher';\r\nimport { CryptoDataTypes } from '../../../../common/types/cryptoDataTypes';\r\nimport BufferUtils, { Bufferlike, Output as BufferUtilsOutput } from './bufferutils';\r\nimport { IPlatformConfig } from 'common/types/IPlatformConfig';\r\n\r\n// The type to which ./msgpack.ts deserializes elements of the `bin` or `ext` type\r\ntype MessagePackBinaryType = ArrayBuffer;\r\n\r\ntype IV = CryptoDataTypes.IV<BufferUtilsOutput>;\r\ntype InputPlaintext = CryptoDataTypes.InputPlaintext<Bufferlike, BufferUtilsOutput>;\r\ntype OutputCiphertext = ArrayBuffer;\r\ntype InputCiphertext = CryptoDataTypes.InputCiphertext<MessagePackBinaryType, BufferUtilsOutput>;\r\ntype OutputPlaintext = ArrayBuffer;\r\n\r\nvar createCryptoClass = function (config: IPlatformConfig, bufferUtils: typeof BufferUtils) {\r\n  var DEFAULT_ALGORITHM = 'aes';\r\n  var DEFAULT_KEYLENGTH = 256; // bits\r\n  var DEFAULT_MODE = 'cbc';\r\n  var DEFAULT_BLOCKLENGTH = 16; // bytes\r\n\r\n  /**\r\n   * Internal: checks that the cipherParams are a valid combination. Currently\r\n   * just checks that the calculated keyLength is a valid one for aes-cbc\r\n   */\r\n  function validateCipherParams(params: API.CipherParams) {\r\n    if (params.algorithm === 'aes' && params.mode === 'cbc') {\r\n      if (params.keyLength === 128 || params.keyLength === 256) {\r\n        return;\r\n      }\r\n      throw new Error(\r\n        'Unsupported key length ' +\r\n          params.keyLength +\r\n          ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)',\r\n      );\r\n    }\r\n  }\r\n\r\n  function normaliseBase64(string: string) {\r\n    /* url-safe base64 strings use _ and - instread of / and + */\r\n    return string.replace('_', '/').replace('-', '+');\r\n  }\r\n\r\n  function isCipherParams(params: API.CipherParams | API.CipherParamOptions): params is API.CipherParams {\r\n    // Although API.CipherParams is an interface, the documentation for its `key` property makes it clear that the only valid way to form one is by using getDefaultParams. The implementation of getDefaultParams returns an instance of CipherParams.\r\n    return params instanceof CipherParams;\r\n  }\r\n\r\n  /**\r\n   * A class encapsulating the client-specifiable parameters for\r\n   * the cipher.\r\n   *\r\n   * algorithm is the name of the algorithm in the default system provider,\r\n   * or the lower-cased version of it; eg \"aes\" or \"AES\".\r\n   *\r\n   * Clients are recommended to not call this directly, but instead to use the\r\n   * Crypto.getDefaultParams helper, which will fill in any fields not supplied\r\n   * with default values and validation the result.\r\n   */\r\n  class CipherParams implements API.CipherParams {\r\n    algorithm: string;\r\n    keyLength: number;\r\n    mode: string;\r\n    key: ArrayBuffer;\r\n\r\n    constructor(algorithm: string, keyLength: number, mode: string, key: ArrayBuffer) {\r\n      this.algorithm = algorithm;\r\n      this.keyLength = keyLength;\r\n      this.mode = mode;\r\n      this.key = key;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Utility classes and interfaces for message payload encryption.\r\n   *\r\n   * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits\r\n   * but supporting other keylengths. Other algorithms and chaining modes are\r\n   * not supported directly, but supportable by extending/implementing the base\r\n   * classes and interfaces here.\r\n   *\r\n   * Secure random data for creation of Initialization Vectors (IVs) and keys\r\n   * is obtained from window.crypto.getRandomValues.\r\n   *\r\n   * Each message payload is encrypted with an IV in CBC mode, and the IV is\r\n   * concatenated with the resulting raw ciphertext to construct the \"ciphertext\"\r\n   * data passed to the recipient.\r\n   */\r\n  class Crypto {\r\n    static CipherParams = CipherParams;\r\n\r\n    /**\r\n     * Obtain a complete CipherParams instance from the provided params, filling\r\n     * in any not provided with default values, calculating a keyLength from\r\n     * the supplied key, and validating the result.\r\n     * @param params an object containing at a minimum a `key` key with value the\r\n     * key, as either a binary or a base64-encoded string.\r\n     * May optionally also contain: algorithm (defaults to AES),\r\n     * mode (defaults to 'cbc')\r\n     */\r\n    static getDefaultParams(params: API.CipherParamOptions) {\r\n      var key: ArrayBuffer;\r\n\r\n      if (!params.key) {\r\n        throw new Error('Crypto.getDefaultParams: a key is required');\r\n      }\r\n\r\n      if (typeof params.key === 'string') {\r\n        key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));\r\n      } else if (params.key instanceof ArrayBuffer) {\r\n        key = params.key;\r\n      } else {\r\n        key = bufferUtils.toArrayBuffer(params.key);\r\n      }\r\n\r\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\r\n      var keyLength = key.byteLength * 8;\r\n      var mode = params.mode || DEFAULT_MODE;\r\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\r\n\r\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\r\n        throw new Error(\r\n          'Crypto.getDefaultParams: a keyLength of ' +\r\n            params.keyLength +\r\n            ' was specified, but the key actually has length ' +\r\n            cipherParams.keyLength,\r\n        );\r\n      }\r\n\r\n      validateCipherParams(cipherParams);\r\n      return cipherParams;\r\n    }\r\n\r\n    /**\r\n     * Generate a random encryption key from the supplied keylength (or the\r\n     * default keyLength if none supplied) as an ArrayBuffer\r\n     * @param keyLength (optional) the required keyLength in bits\r\n     */\r\n    static async generateRandomKey(keyLength?: number): Promise<API.CipherKey> {\r\n      try {\r\n        return config.getRandomArrayBuffer((keyLength || DEFAULT_KEYLENGTH) / 8);\r\n      } catch (err) {\r\n        throw new ErrorInfo('Failed to generate random key: ' + (err as Error).message, 400, 50000, err as Error);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Internal; get a ChannelCipher instance based on the given cipherParams\r\n     * @param params either a CipherParams instance or some subset of its\r\n     * fields that includes a key\r\n     */\r\n    static getCipher(params: IGetCipherParams<IV>, logger: Logger) {\r\n      var cipherParams = isCipherParams(params) ? (params as CipherParams) : this.getDefaultParams(params);\r\n\r\n      return {\r\n        cipherParams: cipherParams,\r\n        cipher: new CBCCipher(cipherParams, params.iv ?? null, logger),\r\n      };\r\n    }\r\n  }\r\n\r\n  Crypto satisfies ICryptoStatic<IV, InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext>;\r\n\r\n  class CBCCipher implements ICipher<InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext> {\r\n    algorithm: string;\r\n    webCryptoAlgorithm: string;\r\n    key: ArrayBuffer;\r\n    iv: ArrayBuffer | null;\r\n\r\n    constructor(params: CipherParams, iv: IV | null, private readonly logger: Logger) {\r\n      if (!crypto.subtle) {\r\n        if (isSecureContext) {\r\n          throw new Error(\r\n            'Crypto operations are not possible since the browser\u2019s SubtleCrypto class is unavailable (reason unknown).',\r\n          );\r\n        } else {\r\n          throw new Error(\r\n            'Crypto operations are is not possible since the current environment is a non-secure context and hence the browser\u2019s SubtleCrypto class is not available.',\r\n          );\r\n        }\r\n      }\r\n\r\n      this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;\r\n      this.webCryptoAlgorithm = params.algorithm + '-' + params.mode;\r\n      this.key = bufferUtils.toArrayBuffer(params.key);\r\n      this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;\r\n    }\r\n\r\n    private concat(buffer1: Bufferlike, buffer2: Bufferlike) {\r\n      const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);\r\n      const outputView = new DataView(output);\r\n\r\n      const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));\r\n      for (let i = 0; i < buffer1View.byteLength; i++) {\r\n        outputView.setInt8(i, buffer1View.getInt8(i));\r\n      }\r\n\r\n      const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));\r\n      for (let i = 0; i < buffer2View.byteLength; i++) {\r\n        outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));\r\n      }\r\n\r\n      return output;\r\n    }\r\n\r\n    async encrypt(plaintext: InputPlaintext): Promise<OutputCiphertext> {\r\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'CBCCipher.encrypt()', '');\r\n\r\n      const iv = await this.getIv();\r\n      const cryptoKey = await crypto.subtle.importKey('raw', this.key, this.webCryptoAlgorithm, false, ['encrypt']);\r\n      const ciphertext = await crypto.subtle.encrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, plaintext);\r\n\r\n      return this.concat(iv, ciphertext);\r\n    }\r\n\r\n    async decrypt(ciphertext: InputCiphertext): Promise<OutputPlaintext> {\r\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'CBCCipher.decrypt()', '');\r\n\r\n      const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);\r\n      const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);\r\n      const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);\r\n\r\n      const cryptoKey = await crypto.subtle.importKey('raw', this.key, this.webCryptoAlgorithm, false, ['decrypt']);\r\n      return crypto.subtle.decrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, ciphertextBody);\r\n    }\r\n\r\n    async getIv(): Promise<ArrayBuffer> {\r\n      if (this.iv) {\r\n        var iv = this.iv;\r\n        this.iv = null;\r\n        return iv;\r\n      }\r\n\r\n      const randomBlock = await config.getRandomArrayBuffer(DEFAULT_BLOCKLENGTH);\r\n      return bufferUtils.toArrayBuffer(randomBlock);\r\n    }\r\n  }\r\n\r\n  return Crypto;\r\n};\r\n\r\nexport { createCryptoClass };\r\n", "enum XHRStates {\r\n  REQ_SEND = 0,\r\n  REQ_RECV = 1,\r\n  REQ_RECV_POLL = 2,\r\n  REQ_RECV_STREAM = 3,\r\n}\r\n\r\nexport default XHRStates;\r\n", "import Platform from 'common/platform';\r\nimport Defaults from 'common/lib/util/defaults';\r\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport { RequestBody, RequestResultError, RequestParams, RequestResult } from 'common/types/http';\r\nimport HttpMethods from 'common/constants/HttpMethods';\r\nimport BaseClient from 'common/lib/client/baseclient';\r\nimport XHRStates from 'common/constants/XHRStates';\r\nimport Logger from 'common/lib/util/logger';\r\nimport { StandardCallback } from 'common/types/utils';\r\nimport { isSuccessCode } from 'common/constants/HttpStatusCodes';\r\nimport { ModularPlugins } from 'common/lib/client/modularplugins';\r\n\r\nexport type HTTPRequestImplementations = Pick<ModularPlugins, 'XHRRequest' | 'FetchRequest'>;\r\n\r\nfunction createMissingImplementationError() {\r\n  return new ErrorInfo(\r\n    'No HTTP request plugin provided. Provide at least one of the FetchRequest or XHRRequest plugins.',\r\n    400,\r\n    40000,\r\n  );\r\n}\r\n\r\nconst Http = class {\r\n  static methods = [HttpMethods.Get, HttpMethods.Delete, HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\r\n  static methodsWithoutBody = [HttpMethods.Get, HttpMethods.Delete];\r\n  static methodsWithBody = [HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\r\n  // HTTP request implementations that are available even without a BaseClient object (needed by some tests which directly instantiate `Http` without a client)\r\n  static bundledRequestImplementations: HTTPRequestImplementations;\r\n  checksInProgress: Array<StandardCallback<boolean>> | null = null;\r\n  private client: BaseClient | null;\r\n\r\n  constructor(client?: BaseClient) {\r\n    this.client = client ?? null;\r\n    const connectivityCheckUrl = client?.options.connectivityCheckUrl || Defaults.connectivityCheckUrl;\r\n    const connectivityCheckParams = client?.options.connectivityCheckParams ?? null;\r\n    const connectivityUrlIsDefault = !client?.options.connectivityCheckUrl;\r\n\r\n    const requestImplementations = {\r\n      ...Http.bundledRequestImplementations,\r\n      ...client?._additionalHTTPRequestImplementations,\r\n    };\r\n    const xhrRequestImplementation = requestImplementations.XHRRequest;\r\n    const fetchRequestImplementation = requestImplementations.FetchRequest;\r\n    const hasImplementation = !!(xhrRequestImplementation || fetchRequestImplementation);\r\n\r\n    if (!hasImplementation) {\r\n      throw createMissingImplementationError();\r\n    }\r\n\r\n    if (Platform.Config.xhrSupported && xhrRequestImplementation) {\r\n      this.supportsAuthHeaders = true;\r\n      this.Request = async function (\r\n        method: HttpMethods,\r\n        uri: string,\r\n        headers: Record<string, string> | null,\r\n        params: RequestParams,\r\n        body: RequestBody | null,\r\n      ) {\r\n        return new Promise((resolve) => {\r\n          const req = xhrRequestImplementation.createRequest(\r\n            uri,\r\n            headers,\r\n            params,\r\n            body,\r\n            XHRStates.REQ_SEND,\r\n            (client && client.options.timeouts) ?? null,\r\n            this.logger,\r\n            method,\r\n          );\r\n          req.once(\r\n            'complete',\r\n            (\r\n              error: RequestResult['error'],\r\n              body: RequestResult['body'],\r\n              headers: RequestResult['headers'],\r\n              unpacked: RequestResult['unpacked'],\r\n              statusCode: RequestResult['statusCode'],\r\n            ) => resolve({ error, body, headers, unpacked, statusCode }),\r\n          );\r\n          req.exec();\r\n        });\r\n      };\r\n      if (client?.options.disableConnectivityCheck) {\r\n        this.checkConnectivity = async function () {\r\n          return true;\r\n        };\r\n      } else {\r\n        this.checkConnectivity = async function () {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MICRO,\r\n            '(XHRRequest)Http.checkConnectivity()',\r\n            'Sending; ' + connectivityCheckUrl,\r\n          );\r\n\r\n          const requestResult = await this.doUri(\r\n            HttpMethods.Get,\r\n            connectivityCheckUrl,\r\n            null,\r\n            null,\r\n            connectivityCheckParams,\r\n          );\r\n\r\n          let result = false;\r\n          if (!connectivityUrlIsDefault) {\r\n            result = !requestResult.error && isSuccessCode(requestResult.statusCode as number);\r\n          } else {\r\n            result = !requestResult.error && (requestResult.body as string)?.replace(/\\n/, '') == 'yes';\r\n          }\r\n\r\n          Logger.logAction(this.logger, Logger.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);\r\n          return result;\r\n        };\r\n      }\r\n    } else if (Platform.Config.fetchSupported && fetchRequestImplementation) {\r\n      this.supportsAuthHeaders = true;\r\n      this.Request = async (method, uri, headers, params, body) => {\r\n        return fetchRequestImplementation(method, client ?? null, uri, headers, params, body);\r\n      };\r\n      this.checkConnectivity = async function () {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          '(Fetch)Http.checkConnectivity()',\r\n          'Sending; ' + connectivityCheckUrl,\r\n        );\r\n        const requestResult = await this.doUri(HttpMethods.Get, connectivityCheckUrl, null, null, null);\r\n        const result = !requestResult.error && (requestResult.body as string)?.replace(/\\n/, '') == 'yes';\r\n        Logger.logAction(this.logger, Logger.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Result: ' + result);\r\n        return result;\r\n      };\r\n    } else {\r\n      this.Request = async () => {\r\n        const error = hasImplementation\r\n          ? new PartialErrorInfo('no supported HTTP transports available', null, 400)\r\n          : createMissingImplementationError();\r\n        return { error };\r\n      };\r\n    }\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.client?.logger ?? Logger.defaultLogger;\r\n  }\r\n\r\n  async doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    if (!this.Request) {\r\n      return { error: new PartialErrorInfo('Request invoked before assigned to', null, 500) };\r\n    }\r\n    return this.Request(method, uri, headers, params, body);\r\n  }\r\n\r\n  private Request?: (\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n  ) => Promise<RequestResult>;\r\n\r\n  checkConnectivity?: () => Promise<boolean> = undefined;\r\n\r\n  supportsAuthHeaders = false;\r\n  supportsLinkHeaders = false;\r\n\r\n  shouldFallback(errorInfo: RequestResultError) {\r\n    const statusCode = errorInfo.statusCode as number;\r\n    /* 400 + no code = a generic xhr onerror. Browser doesn't give us enough\r\n     * detail to know whether it's fallback-fixable, but it may be (eg if a\r\n     * network issue), so try just in case */\r\n    return (\r\n      (statusCode === 408 && !errorInfo.code) ||\r\n      (statusCode === 400 && !errorInfo.code) ||\r\n      (statusCode >= 500 && statusCode <= 504)\r\n    );\r\n  }\r\n};\r\n\r\nexport default Http;\r\n", "import { IPlatformConfig } from '../../common/types/IPlatformConfig';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\n// Workaround for salesforce lightning locker compat\r\nconst globalObject = Utils.getGlobalObject();\r\n\r\n// @ts-ignore\r\nconst isVercelEdgeRuntime = typeof EdgeRuntime === 'string';\r\n\r\n// We get false positive result here in the Vercel Edge runtime because it lacks the usual global browser objects, such as Window.\r\n// However, it is closer to the browser environment, so it intentionally uses browser bundles when importing packages.\r\n// Therefore, we do an additional check to avoid logging this incorrect warning for Vercel Edge runtime.\r\nif (typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined' && !isVercelEdgeRuntime) {\r\n  console.log(\r\n    \"Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm\",\r\n  );\r\n}\r\n\r\nfunction allowComet() {\r\n  /* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg\r\n   * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask\r\n   * So if websockets are supported, then just forget about comet transports and use that */\r\n  const loc = globalObject.location;\r\n  return !globalObject.WebSocket || !loc || !loc.origin || loc.origin.indexOf('http') > -1;\r\n}\r\n\r\n// from: https://stackoverflow.com/a/18002694\r\nexport function isWebWorkerContext(): boolean {\r\n  // run this in global scope of window or worker. since window.self = window, we're ok\r\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nconst userAgent = globalObject.navigator && globalObject.navigator.userAgent.toString();\r\nconst currentUrl = globalObject.location && globalObject.location.href;\r\n\r\nconst Config: IPlatformConfig = {\r\n  agent: 'browser',\r\n  logTimestamps: true,\r\n  userAgent: userAgent,\r\n  currentUrl: currentUrl,\r\n  binaryType: 'arraybuffer',\r\n  WebSocket: globalObject.WebSocket,\r\n  fetchSupported: !!globalObject.fetch,\r\n  xhrSupported: globalObject.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),\r\n  allowComet: allowComet(),\r\n  useProtocolHeartbeats: true,\r\n  supportsBinary: !!globalObject.TextDecoder,\r\n  /* Per Paddy (https://ably-real-time.slack.com/archives/CURL4U2FP/p1705674537763479) web intentionally prefers JSON to MessagePack:\r\n   *\r\n   * > browsers' support for binary types in general was historically poor, and JSON transport performance is significantly better in a browser than msgpack. In modern browsers then binary is supported consistently, but I'd still expect that JSON encode/decode performance is dramatically better than msgpack in a browser.\r\n   */\r\n  preferBinary: false,\r\n  ArrayBuffer: globalObject.ArrayBuffer,\r\n  atob: globalObject.atob,\r\n  nextTick:\r\n    typeof globalObject.setImmediate !== 'undefined'\r\n      ? globalObject.setImmediate.bind(globalObject)\r\n      : function (f: () => void) {\r\n          setTimeout(f, 0);\r\n        },\r\n  addEventListener: globalObject.addEventListener,\r\n  inspect: JSON.stringify,\r\n  stringByteSize: function (str: string) {\r\n    /* str.length will be an underestimate for non-ascii strings. But if we're\r\n     * in a browser too old to support TextDecoder, not much we can do. Better\r\n     * to underestimate, so if we do go over-size, the server will reject the\r\n     * message */\r\n    return (globalObject.TextDecoder && new globalObject.TextEncoder().encode(str).length) || str.length;\r\n  },\r\n  TextEncoder: globalObject.TextEncoder,\r\n  TextDecoder: globalObject.TextDecoder,\r\n  getRandomArrayBuffer: async function (byteLength: number): Promise<ArrayBuffer> {\r\n    const byteArray = new Uint8Array(byteLength);\r\n    globalObject.crypto.getRandomValues(byteArray);\r\n    return byteArray.buffer;\r\n  },\r\n  isWebworker: isWebWorkerContext(),\r\n};\r\n\r\nexport default Config;\r\n", "import * as Utils from '../util/utils';\r\nimport ProtocolMessage, {\r\n  actions,\r\n  fromValues as protocolMessageFromValues,\r\n  fromDeserialized as protocolMessageFromDeserialized,\r\n} from '../types/protocolmessage';\r\nimport Transport from './transport';\r\nimport Logger from '../util/logger';\r\nimport Defaults from '../util/defaults';\r\nimport ConnectionErrors from './connectionerrors';\r\nimport Auth from '../client/auth';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport IXHRRequest from '../../types/IXHRRequest';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport XHRStates from '../../constants/XHRStates';\r\nimport Platform from 'common/platform';\r\n\r\n/* TODO: can remove once realtime sends protocol message responses for comet errors */\r\nfunction shouldBeErrorAction(err: ErrorInfo) {\r\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\r\n  if (err.code) {\r\n    if (Auth.isTokenErr(err)) return false;\r\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code)) return true;\r\n    return err.code >= 40000 && err.code < 50000;\r\n  } else {\r\n    /* Likely a network or transport error of some kind. Certainly not fatal to the connection */\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction protocolMessageFromRawError(err: ErrorInfo) {\r\n  /* err will be either a legacy (non-protocolmessage) comet error response\r\n   * (which will have an err.code), or a xhr/network error (which won't). */\r\n  if (shouldBeErrorAction(err)) {\r\n    return [protocolMessageFromValues({ action: actions.ERROR, error: err })];\r\n  } else {\r\n    return [protocolMessageFromValues({ action: actions.DISCONNECTED, error: err })];\r\n  }\r\n}\r\n\r\n/*\r\n * A base comet transport class\r\n */\r\nabstract class CometTransport extends Transport {\r\n  stream: string | boolean;\r\n  sendRequest: IXHRRequest | null;\r\n  recvRequest: null | IXHRRequest;\r\n  pendingCallback: null;\r\n  pendingItems: null | Array<ProtocolMessage>;\r\n  baseUri?: string;\r\n  authParams?: Record<string, any>;\r\n  closeUri?: string;\r\n  disconnectUri?: string;\r\n  sendUri?: string;\r\n  recvUri?: string;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params, /* binary not supported for comet so force JSON protocol */ true);\r\n    this.stream = 'stream' in params ? params.stream : true;\r\n    this.sendRequest = null;\r\n    this.recvRequest = null;\r\n    this.pendingCallback = null;\r\n    this.pendingItems = null;\r\n  }\r\n\r\n  abstract createRequest(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params?: Record<string, unknown> | null,\r\n    body?: unknown,\r\n    requestMode?: number,\r\n  ): IXHRRequest;\r\n\r\n  connect(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.connect()', 'starting');\r\n    Transport.prototype.connect.call(this);\r\n    const params = this.params;\r\n    const options = params.options;\r\n    const host = Defaults.getHost(options, params.host);\r\n    const port = Defaults.getPort(options);\r\n    const cometScheme = options.tls ? 'https://' : 'http://';\r\n\r\n    this.baseUri = cometScheme + host + ':' + port + '/comet/';\r\n    const connectUri = this.baseUri + 'connect';\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);\r\n    Utils.whenPromiseSettles(this.auth.getAuthParams(), (err: Error | null, authParams?: Record<string, any>) => {\r\n      if (err) {\r\n        this.disconnect(err);\r\n        return;\r\n      }\r\n      if (this.isDisposed) {\r\n        return;\r\n      }\r\n      this.authParams = authParams;\r\n      const connectParams = this.params.getConnectParams(authParams!);\r\n      if ('stream' in connectParams) this.stream = connectParams.stream;\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'CometTransport.connect()',\r\n        'connectParams:' + Utils.toQueryString(connectParams),\r\n      );\r\n\r\n      /* this will be the 'recvRequest' so this connection can stream messages */\r\n      let preconnected = false;\r\n      const connectRequest = (this.recvRequest = this.createRequest(\r\n        connectUri,\r\n        null,\r\n        connectParams,\r\n        null,\r\n        this.stream ? XHRStates.REQ_RECV_STREAM : XHRStates.REQ_RECV,\r\n      ));\r\n\r\n      connectRequest.on('data', (data: any) => {\r\n        if (!this.recvRequest) {\r\n          /* the transport was disposed before we connected */\r\n          return;\r\n        }\r\n        if (!preconnected) {\r\n          preconnected = true;\r\n          this.emit('preconnect');\r\n        }\r\n        this.onData(data);\r\n      });\r\n      connectRequest.on('complete', (err: ErrorInfo) => {\r\n        if (!this.recvRequest) {\r\n          /* the transport was disposed before we connected */\r\n          err = err || new ErrorInfo('Request cancelled', 80003, 400);\r\n        }\r\n        this.recvRequest = null;\r\n        /* Connect request may complete without a emitting 'data' event since that is not\r\n         * emitted for e.g. a non-streamed error response. Still implies preconnect. */\r\n        if (!preconnected && !err) {\r\n          preconnected = true;\r\n          this.emit('preconnect');\r\n        }\r\n        this.onActivity();\r\n        if (err) {\r\n          if (err.code) {\r\n            /* A protocol error received from realtime. TODO: once realtime\r\n             * consistendly sends errors wrapped in protocol messages, should be\r\n             * able to remove this */\r\n            this.onData(protocolMessageFromRawError(err));\r\n          } else {\r\n            /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n             * just disconnect the transport */\r\n            this.disconnect(err);\r\n          }\r\n          return;\r\n        }\r\n        Platform.Config.nextTick(() => {\r\n          this.recv();\r\n        });\r\n      });\r\n      connectRequest.exec();\r\n    });\r\n  }\r\n\r\n  requestClose(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.requestClose()');\r\n    this._requestCloseOrDisconnect(true);\r\n  }\r\n\r\n  requestDisconnect(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.requestDisconnect()');\r\n    this._requestCloseOrDisconnect(false);\r\n  }\r\n\r\n  _requestCloseOrDisconnect(closing: boolean): void {\r\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\r\n    if (closeOrDisconnectUri) {\r\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates.REQ_SEND);\r\n\r\n      request.on('complete', (err: ErrorInfo) => {\r\n        if (err) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_ERROR,\r\n            'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'),\r\n            'request returned err = ' + Utils.inspectError(err),\r\n          );\r\n          this.finish('disconnected', err);\r\n        }\r\n      });\r\n      request.exec();\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.dispose()', '');\r\n    if (!this.isDisposed) {\r\n      this.isDisposed = true;\r\n      if (this.recvRequest) {\r\n        Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');\r\n        this.recvRequest.abort();\r\n        this.recvRequest = null;\r\n      }\r\n      /* In almost all cases the transport will be finished before it's\r\n       * disposed. Finish here just to make sure. */\r\n      this.finish('disconnected', ConnectionErrors.disconnected());\r\n      Platform.Config.nextTick(() => {\r\n        this.emit('disposed');\r\n      });\r\n    }\r\n  }\r\n\r\n  onConnect(message: ProtocolMessage): void {\r\n    /* if this transport has been disposed whilst awaiting connection, do nothing */\r\n    if (this.isDisposed) {\r\n      return;\r\n    }\r\n\r\n    /* the connectionKey in a comet connected response is really\r\n     * <instId>-<connectionKey> */\r\n    const connectionStr = message.connectionDetails?.connectionKey;\r\n    Transport.prototype.onConnect.call(this, message);\r\n\r\n    const baseConnectionUri = (this.baseUri as string) + connectionStr;\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri);\r\n    this.sendUri = baseConnectionUri + '/send';\r\n    this.recvUri = baseConnectionUri + '/recv';\r\n    this.closeUri = baseConnectionUri + '/close';\r\n    this.disconnectUri = baseConnectionUri + '/disconnect';\r\n  }\r\n\r\n  send(message: ProtocolMessage): void {\r\n    if (this.sendRequest) {\r\n      /* there is a pending send, so queue this message */\r\n      this.pendingItems = this.pendingItems || [];\r\n      this.pendingItems.push(message);\r\n      return;\r\n    }\r\n    /* send this, plus any pending, now */\r\n    const pendingItems = this.pendingItems || [];\r\n    pendingItems.push(message);\r\n    this.pendingItems = null;\r\n\r\n    this.sendItems(pendingItems);\r\n  }\r\n\r\n  sendAnyPending(): void {\r\n    const pendingItems = this.pendingItems;\r\n\r\n    if (!pendingItems) {\r\n      return;\r\n    }\r\n\r\n    this.pendingItems = null;\r\n    this.sendItems(pendingItems);\r\n  }\r\n\r\n  sendItems(items: Array<ProtocolMessage>): void {\r\n    const sendRequest = (this.sendRequest = this.createRequest(\r\n      this.sendUri as string,\r\n      null,\r\n      this.authParams,\r\n      this.encodeRequest(items),\r\n      XHRStates.REQ_SEND,\r\n    ));\r\n\r\n    sendRequest.on('complete', (err: ErrorInfo, data: string) => {\r\n      if (err)\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_ERROR,\r\n          'CometTransport.sendItems()',\r\n          'on complete: err = ' + Utils.inspectError(err),\r\n        );\r\n      this.sendRequest = null;\r\n\r\n      /* the result of the request, even if a nack, is usually a protocol response\r\n       * contained in the data. An err is anomolous, and indicates some issue with the\r\n       * network,transport, or connection */\r\n      if (err) {\r\n        if (err.code) {\r\n          /* A protocol error received from realtime. TODO: once realtime\r\n           * consistendly sends errors wrapped in protocol messages, should be\r\n           * able to remove this */\r\n          this.onData(protocolMessageFromRawError(err));\r\n        } else {\r\n          /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n           * just disconnect the transport */\r\n          this.disconnect(err);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (data) {\r\n        this.onData(data);\r\n      }\r\n\r\n      if (this.pendingItems) {\r\n        Platform.Config.nextTick(() => {\r\n          /* If there's a new send request by now, any pending items will have\r\n           * been picked up by that; any new ones added since then will be\r\n           * picked up after that one completes */\r\n          if (!this.sendRequest) {\r\n            this.sendAnyPending();\r\n          }\r\n        });\r\n      }\r\n    });\r\n    sendRequest.exec();\r\n  }\r\n\r\n  recv(): void {\r\n    /* do nothing if there is an active request, which might be streaming */\r\n    if (this.recvRequest) return;\r\n\r\n    /* If we're no longer connected, do nothing */\r\n    if (!this.isConnected) return;\r\n\r\n    const recvRequest = (this.recvRequest = this.createRequest(\r\n      this.recvUri as string,\r\n      null,\r\n      this.authParams,\r\n      null,\r\n      this.stream ? XHRStates.REQ_RECV_STREAM : XHRStates.REQ_RECV_POLL,\r\n    ));\r\n\r\n    recvRequest.on('data', (data: string) => {\r\n      this.onData(data);\r\n    });\r\n    recvRequest.on('complete', (err: ErrorInfo) => {\r\n      this.recvRequest = null;\r\n      /* A request completing must be considered activity, as realtime sends\r\n       * heartbeats every 15s since a request began, not every 15s absolutely */\r\n      this.onActivity();\r\n      if (err) {\r\n        if (err.code) {\r\n          /* A protocol error received from realtime. TODO: once realtime\r\n           * consistently sends errors wrapped in protocol messages, should be\r\n           * able to remove this */\r\n          this.onData(protocolMessageFromRawError(err));\r\n        } else {\r\n          /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n           * just disconnect the transport */\r\n          this.disconnect(err);\r\n        }\r\n        return;\r\n      }\r\n      Platform.Config.nextTick(() => {\r\n        this.recv();\r\n      });\r\n    });\r\n    recvRequest.exec();\r\n  }\r\n\r\n  onData(responseData: string | Record<string, any>): void {\r\n    try {\r\n      const items = this.decodeResponse(responseData);\r\n      if (items && items.length)\r\n        for (let i = 0; i < items.length; i++)\r\n          this.onProtocolMessage(\r\n            protocolMessageFromDeserialized(items[i], this.connectionManager.realtime._RealtimePresence),\r\n          );\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'CometTransport.onData()',\r\n        'Unexpected exception handing channel event: ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  encodeRequest(requestItems: Array<ProtocolMessage>): string {\r\n    return JSON.stringify(requestItems);\r\n  }\r\n\r\n  decodeResponse(responseData: string | Record<string, any>): Record<string, any> {\r\n    if (typeof responseData == 'string') return JSON.parse(responseData);\r\n    return responseData;\r\n  }\r\n\r\n  /* Historical comment, back from when we supported JSONP:\r\n   *\r\n   * > For comet, we could do the auth update by aborting the current recv and\r\n   * > starting a new one with the new token, that'd be sufficient for realtime.\r\n   * > Problem is JSONP - you can't cancel truly abort a recv once started. So\r\n   * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\r\n   * > comet transports the same and do it for all of them. So we send the AUTH\r\n   * > instead, and don't need to abort the recv\r\n   *\r\n   * Now that we\u2019ve dropped JSONP support, we may be able to revisit the above;\r\n   * see https://github.com/ably/ably-js/issues/1214.\r\n   */\r\n  onAuthUpdated = (tokenDetails: API.TokenDetails): void => {\r\n    this.authParams = { access_token: tokenDetails.token };\r\n  };\r\n}\r\n\r\nexport default CometTransport;\r\n", "import * as Utils from 'common/lib/util/utils';\r\nimport EventEmitter from 'common/lib/util/eventemitter';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport Logger from 'common/lib/util/logger';\r\nimport Defaults from 'common/lib/util/defaults';\r\nimport HttpMethods from 'common/constants/HttpMethods';\r\nimport IXHRRequest from 'common/types/IXHRRequest';\r\nimport { RequestBody, RequestParams } from 'common/types/http';\r\nimport XHRStates from 'common/constants/XHRStates';\r\nimport Platform from 'common/platform';\r\n\r\nfunction isAblyError(responseBody: unknown, headers: Record<string, string>): responseBody is { error?: ErrorInfo } {\r\n  return Utils.allToLowerCase(Utils.keysArray(headers)).includes('x-ably-errorcode');\r\n}\r\n\r\nfunction getAblyError(responseBody: unknown, headers: Record<string, string>) {\r\n  if (isAblyError(responseBody, headers)) {\r\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\r\n  }\r\n}\r\n\r\nconst noop = function () {};\r\nlet idCounter = 0;\r\nconst pendingRequests: Record<string, XHRRequest> = {};\r\n\r\nfunction getHeader(xhr: XMLHttpRequest, header: string) {\r\n  return xhr.getResponseHeader && xhr.getResponseHeader(header);\r\n}\r\n\r\n/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact\r\n * it is 'chunked'. So instead, decide that it is chunked when\r\n * transfer-encoding is present or content-length is absent.  ('or' because\r\n * when using http2 streaming, there's no transfer-encoding header, but can\r\n * still deduce streaming from lack of content-length) */\r\nfunction isEncodingChunked(xhr: XMLHttpRequest) {\r\n  return (\r\n    xhr.getResponseHeader && (xhr.getResponseHeader('transfer-encoding') || !xhr.getResponseHeader('content-length'))\r\n  );\r\n}\r\n\r\nfunction getHeadersAsObject(xhr: XMLHttpRequest) {\r\n  const headerPairs = xhr.getAllResponseHeaders().trim().split('\\r\\n');\r\n  const headers: Record<string, string> = {};\r\n  for (let i = 0; i < headerPairs.length; i++) {\r\n    const parts = headerPairs[i].split(':').map((x) => x.trim());\r\n    headers[parts[0].toLowerCase()] = parts[1];\r\n  }\r\n  return headers;\r\n}\r\n\r\nclass XHRRequest extends EventEmitter implements IXHRRequest {\r\n  uri: string;\r\n  headers: Record<string, string>;\r\n  body: RequestBody | null;\r\n  method: string;\r\n  requestMode: number;\r\n  timeouts: Record<string, number>;\r\n  timedOut: boolean;\r\n  requestComplete: boolean;\r\n  id: string;\r\n  streamComplete?: boolean;\r\n  xhr?: XMLHttpRequest | null;\r\n  timer?: NodeJS.Timeout | number | null;\r\n\r\n  constructor(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: Record<string, string>,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n    timeouts: Record<string, number>,\r\n    logger: Logger,\r\n    method?: HttpMethods,\r\n  ) {\r\n    super(logger);\r\n    params = params || {};\r\n    params.rnd = Utils.cheapRandStr();\r\n    this.uri = uri + Utils.toQueryString(params);\r\n    this.headers = headers || {};\r\n    this.body = body;\r\n    this.method = method ? method.toUpperCase() : Utils.isNil(body) ? 'GET' : 'POST';\r\n    this.requestMode = requestMode;\r\n    this.timeouts = timeouts;\r\n    this.timedOut = false;\r\n    this.requestComplete = false;\r\n    this.id = String(++idCounter);\r\n    pendingRequests[this.id] = this;\r\n  }\r\n\r\n  static createRequest(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n    timeouts: Record<string, number> | null,\r\n    logger: Logger,\r\n    method?: HttpMethods,\r\n  ): XHRRequest {\r\n    /* XHR requests are used either with the context being a realtime\r\n     * transport, or with timeouts passed in (for when used by a rest client),\r\n     * or completely standalone.  Use the appropriate timeouts in each case */\r\n    const _timeouts = timeouts || Defaults.TIMEOUTS;\r\n    return new XHRRequest(\r\n      uri,\r\n      headers,\r\n      Utils.copy(params) as Record<string, string>,\r\n      body,\r\n      requestMode,\r\n      _timeouts,\r\n      logger,\r\n      method,\r\n    );\r\n  }\r\n\r\n  complete(\r\n    err?: IPartialErrorInfo | null,\r\n    body?: unknown,\r\n    headers?: Record<string, string> | null,\r\n    unpacked?: boolean | null,\r\n    statusCode?: number,\r\n  ): void {\r\n    if (!this.requestComplete) {\r\n      this.requestComplete = true;\r\n      if (!err && body) {\r\n        this.emit('data', body);\r\n      }\r\n      this.emit('complete', err, body, headers, unpacked, statusCode);\r\n      this.dispose();\r\n    }\r\n  }\r\n\r\n  abort(): void {\r\n    this.dispose();\r\n  }\r\n\r\n  exec(): void {\r\n    let headers = this.headers;\r\n    const timeout =\r\n        this.requestMode == XHRStates.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,\r\n      timer = (this.timer = setTimeout(() => {\r\n        this.timedOut = true;\r\n        xhr.abort();\r\n      }, timeout)),\r\n      method = this.method,\r\n      xhr = (this.xhr = new XMLHttpRequest()),\r\n      accept = headers['accept'];\r\n    let body = this.body;\r\n    let responseType: XMLHttpRequestResponseType = 'text';\r\n\r\n    if (!accept) {\r\n      // Default to JSON\r\n      headers['accept'] = 'application/json';\r\n    } else if (accept.indexOf('application/x-msgpack') === 0) {\r\n      // Msgpack responses will be typed as ArrayBuffer\r\n      responseType = 'arraybuffer';\r\n    }\r\n\r\n    if (body) {\r\n      const contentType = headers['content-type'] || (headers['content-type'] = 'application/json');\r\n      if (contentType.indexOf('application/json') > -1 && typeof body != 'string') body = JSON.stringify(body);\r\n    }\r\n\r\n    // Can probably remove this directive if https://github.com/nodesecurity/eslint-plugin-security/issues/26 is resolved\r\n    // eslint-disable-next-line security/detect-non-literal-fs-filename\r\n    xhr.open(method, this.uri, true);\r\n    xhr.responseType = responseType;\r\n\r\n    if ('authorization' in headers) {\r\n      xhr.withCredentials = true;\r\n    }\r\n\r\n    for (const h in headers) xhr.setRequestHeader(h, headers[h]);\r\n\r\n    const errorHandler = (\r\n      errorEvent: ProgressEvent<EventTarget>,\r\n      message: string,\r\n      code: number | null,\r\n      statusCode: number,\r\n    ) => {\r\n      let errorMessage = message + ' (event type: ' + errorEvent.type + ')';\r\n      if (this?.xhr?.statusText) errorMessage += ', current statusText is ' + this.xhr.statusText;\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);\r\n      this.complete(new PartialErrorInfo(errorMessage, code, statusCode));\r\n    };\r\n    xhr.onerror = function (errorEvent) {\r\n      errorHandler(errorEvent, 'XHR error occurred', null, 400);\r\n    };\r\n    xhr.onabort = (errorEvent) => {\r\n      if (this.timedOut) {\r\n        errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);\r\n      } else {\r\n        errorHandler(errorEvent, 'Request cancelled', null, 400);\r\n      }\r\n    };\r\n    xhr.ontimeout = function (errorEvent) {\r\n      errorHandler(errorEvent, 'Request timed out', null, 408);\r\n    };\r\n\r\n    let streaming: boolean | string;\r\n    let statusCode: number;\r\n    let successResponse: boolean;\r\n    let streamPos = 0;\r\n    let unpacked = false;\r\n\r\n    const onResponse = () => {\r\n      clearTimeout(timer);\r\n      successResponse = statusCode < 400;\r\n      if (statusCode == 204) {\r\n        this.complete(null, null, null, null, statusCode);\r\n        return;\r\n      }\r\n      streaming = this.requestMode == XHRStates.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);\r\n    };\r\n\r\n    const onEnd = () => {\r\n      let parsedResponse: any;\r\n      try {\r\n        const contentType = getHeader(xhr, 'content-type');\r\n        /* Be liberal in what we accept; buggy auth servers may respond\r\n         * without the correct contenttype, but assume they're still\r\n         * responding with json */\r\n        const json = contentType ? contentType.indexOf('application/json') >= 0 : xhr.responseType == 'text';\r\n\r\n        if (json) {\r\n          /* If we requested msgpack but server responded with json, then since\r\n           * we set the responseType expecting msgpack, the response will be\r\n           * an ArrayBuffer containing json */\r\n          const jsonResponseBody =\r\n            xhr.responseType === 'arraybuffer'\r\n              ? Platform.BufferUtils.utf8Decode(xhr.response)\r\n              : String(xhr.responseText);\r\n          if (jsonResponseBody.length) {\r\n            parsedResponse = JSON.parse(jsonResponseBody);\r\n          } else {\r\n            parsedResponse = jsonResponseBody;\r\n          }\r\n          unpacked = true;\r\n        } else {\r\n          parsedResponse = xhr.response;\r\n        }\r\n\r\n        if (parsedResponse.response !== undefined) {\r\n          /* unwrap JSON envelope */\r\n          statusCode = parsedResponse.statusCode;\r\n          successResponse = statusCode < 400;\r\n          headers = parsedResponse.headers;\r\n          parsedResponse = parsedResponse.response;\r\n        } else {\r\n          headers = getHeadersAsObject(xhr);\r\n        }\r\n      } catch (e) {\r\n        this.complete(new PartialErrorInfo('Malformed response body from server: ' + (e as Error).message, null, 400));\r\n        return;\r\n      }\r\n\r\n      /* If response is an array, it's an array of protocol messages -- even if\r\n       * is contains an error action (hence the nonsuccess statuscode), we can\r\n       * consider the request to have succeeded, just pass it on to\r\n       * onProtocolMessage to decide what to do */\r\n      if (successResponse || Array.isArray(parsedResponse)) {\r\n        this.complete(null, parsedResponse, headers, unpacked, statusCode);\r\n        return;\r\n      }\r\n\r\n      let err: IPartialErrorInfo | undefined = getAblyError(parsedResponse, headers);\r\n      if (!err) {\r\n        err = new PartialErrorInfo(\r\n          'Error response received from server: ' +\r\n            statusCode +\r\n            ' body was: ' +\r\n            Platform.Config.inspect(parsedResponse),\r\n          null,\r\n          statusCode,\r\n        );\r\n      }\r\n      this.complete(err, parsedResponse, headers, unpacked, statusCode);\r\n    };\r\n\r\n    function onProgress() {\r\n      const responseText = xhr.responseText;\r\n      const bodyEnd = responseText.length - 1;\r\n      let idx, chunk;\r\n      while (streamPos < bodyEnd && (idx = responseText.indexOf('\\n', streamPos)) > -1) {\r\n        chunk = responseText.slice(streamPos, idx);\r\n        streamPos = idx + 1;\r\n        onChunk(chunk);\r\n      }\r\n    }\r\n\r\n    const onChunk = (chunk: string) => {\r\n      try {\r\n        chunk = JSON.parse(chunk);\r\n      } catch (e) {\r\n        this.complete(new PartialErrorInfo('Malformed response body from server: ' + (e as Error).message, null, 400));\r\n        return;\r\n      }\r\n      this.emit('data', chunk);\r\n    };\r\n\r\n    const onStreamEnd = () => {\r\n      onProgress();\r\n      this.streamComplete = true;\r\n      Platform.Config.nextTick(() => {\r\n        this.complete();\r\n      });\r\n    };\r\n\r\n    xhr.onreadystatechange = function () {\r\n      const readyState = xhr.readyState;\r\n      if (readyState < 3) return;\r\n      if (xhr.status !== 0) {\r\n        if (statusCode === undefined) {\r\n          statusCode = xhr.status;\r\n          onResponse();\r\n        }\r\n        if (readyState == 3 && streaming) {\r\n          onProgress();\r\n        } else if (readyState == 4) {\r\n          if (streaming) onStreamEnd();\r\n          else onEnd();\r\n        }\r\n      }\r\n    };\r\n    xhr.send(body as any);\r\n  }\r\n\r\n  dispose(): void {\r\n    const xhr = this.xhr;\r\n    if (xhr) {\r\n      xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;\r\n      this.xhr = null;\r\n      const timer = this.timer;\r\n      if (timer) {\r\n        clearTimeout(timer as NodeJS.Timeout);\r\n        this.timer = null;\r\n      }\r\n      if (!this.requestComplete) xhr.abort();\r\n    }\r\n    delete pendingRequests[this.id];\r\n  }\r\n}\r\n\r\nexport default XHRRequest;\r\n", "import Platform from '../../../../common/platform';\r\nimport CometTransport from '../../../../common/lib/transport/comettransport';\r\nimport XHRRequest from '../http/request/xhrrequest';\r\nimport ConnectionManager, { TransportParams } from 'common/lib/transport/connectionmanager';\r\nimport Auth from 'common/lib/client/auth';\r\nimport { RequestBody, RequestParams } from 'common/types/http';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nvar shortName = TransportNames.XhrPolling;\r\nclass XHRPollingTransport extends CometTransport {\r\n  shortName = shortName;\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params);\r\n    params.stream = false;\r\n    this.shortName = shortName;\r\n  }\r\n\r\n  static isAvailable() {\r\n    return !!(Platform.Config.xhrSupported && Platform.Config.allowComet);\r\n  }\r\n\r\n  toString() {\r\n    return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;\r\n  }\r\n\r\n  createRequest(\r\n    uri: string,\r\n    headers: Record<string, string>,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n  ) {\r\n    return XHRRequest.createRequest(uri, headers, params, body, requestMode, this.timeouts, this.logger);\r\n  }\r\n}\r\n\r\nexport default XHRPollingTransport;\r\n", "import TransportName from 'common/constants/TransportName';\r\nimport Platform from 'common/platform';\r\nimport XhrPollingTransport from './xhrpollingtransport';\r\nimport WebSocketTransport from '../../../../common/lib/transport/websockettransport';\r\n\r\n// For reasons that I don\u2019t understand, if we use [TransportNames.XhrPolling] for the keys in defaultTransports\u2019s, then defaultTransports does not get tree-shaken. Hence using literals instead. They\u2019re still correctly type-checked.\r\n\r\nconst order: TransportName[] = ['xhr_polling'];\r\n\r\nconst defaultTransports: (typeof Platform)['Transports'] = {\r\n  order,\r\n  bundledImplementations: {\r\n    web_socket: WebSocketTransport,\r\n    xhr_polling: XhrPollingTransport,\r\n  },\r\n};\r\n\r\nexport default defaultTransports;\r\n\r\nexport const ModularTransports: (typeof Platform)['Transports'] = {\r\n  order,\r\n  bundledImplementations: {},\r\n};\r\n", "import IWebStorage from 'common/types/IWebStorage';\r\n\r\nconst test = 'ablyjs-storage-test';\r\n\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nclass Webstorage implements IWebStorage {\r\n  sessionSupported: boolean;\r\n  localSupported: boolean;\r\n\r\n  constructor() {\r\n    /* Even just accessing the session/localStorage object can throw a\r\n     * security exception in some circumstances with some browsers. In\r\n     * others, calling setItem will throw. So have to check in this\r\n     * somewhat roundabout way. (If unsupported or no global object,\r\n     * will throw on accessing a property of undefined) */\r\n    try {\r\n      globalObject.sessionStorage.setItem(test, test);\r\n      globalObject.sessionStorage.removeItem(test);\r\n      this.sessionSupported = true;\r\n    } catch (e) {\r\n      this.sessionSupported = false;\r\n    }\r\n\r\n    try {\r\n      globalObject.localStorage.setItem(test, test);\r\n      globalObject.localStorage.removeItem(test);\r\n      this.localSupported = true;\r\n    } catch (e) {\r\n      this.localSupported = false;\r\n    }\r\n  }\r\n\r\n  get(name: string): any {\r\n    return this._get(name, false);\r\n  }\r\n\r\n  getSession(name: string): any {\r\n    return this._get(name, true);\r\n  }\r\n\r\n  remove(name: string): void {\r\n    return this._remove(name, false);\r\n  }\r\n\r\n  removeSession(name: string): void {\r\n    return this._remove(name, true);\r\n  }\r\n\r\n  set(name: string, value: string, ttl?: number): void {\r\n    return this._set(name, value, ttl, false);\r\n  }\r\n\r\n  setSession(name: string, value: string, ttl?: number): void {\r\n    return this._set(name, value, ttl, true);\r\n  }\r\n\r\n  private _set(name: string, value: string, ttl: number | undefined, session: any) {\r\n    const wrappedValue: Record<string, any> = { value: value };\r\n    if (ttl) {\r\n      wrappedValue.expires = Date.now() + ttl;\r\n    }\r\n    return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));\r\n  }\r\n\r\n  private _get(name: string, session?: boolean) {\r\n    if (session && !this.sessionSupported) throw new Error('Session Storage not supported');\r\n    if (!session && !this.localSupported) throw new Error('Local Storage not supported');\r\n    const rawItem = this.storageInterface(session).getItem(name);\r\n    if (!rawItem) return null;\r\n    const wrappedValue = JSON.parse(rawItem);\r\n    if (wrappedValue.expires && wrappedValue.expires < Date.now()) {\r\n      this.storageInterface(session).removeItem(name);\r\n      return null;\r\n    }\r\n    return wrappedValue.value;\r\n  }\r\n\r\n  private _remove(name: string, session?: boolean) {\r\n    return this.storageInterface(session).removeItem(name);\r\n  }\r\n\r\n  private storageInterface(session?: boolean) {\r\n    return session ? globalObject.sessionStorage : globalObject.localStorage;\r\n  }\r\n}\r\n\r\nexport default new Webstorage();\r\n", "import IDefaults from 'common/types/IDefaults';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nconst Defaults: IDefaults = {\r\n  connectivityCheckUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',\r\n  wsConnectivityUrl: 'wss://ws-up.ably-realtime.com',\r\n  /* Order matters here: the base transport is the leftmost one in the\r\n   * intersection of baseTransportOrder and the transports clientOption that's\r\n   * supported. */\r\n  defaultTransports: [TransportNames.XhrPolling, TransportNames.WebSocket],\r\n};\r\n\r\nexport default Defaults;\r\n", "function inspect(buffer: undefined | ArrayBuffer | DataView) {\r\n  if (buffer === undefined) return 'undefined';\r\n  let view;\r\n  let type;\r\n  if (buffer instanceof ArrayBuffer) {\r\n    type = 'ArrayBuffer';\r\n    view = new DataView(buffer);\r\n  } else if (buffer instanceof DataView) {\r\n    type = 'DataView';\r\n    view = buffer;\r\n  }\r\n  if (!view) return JSON.stringify(buffer);\r\n  const bytes = [];\r\n  for (let i = 0; i < buffer.byteLength; i++) {\r\n    if (i > 20) {\r\n      bytes.push('...');\r\n      break;\r\n    }\r\n    let byte_ = view.getUint8(i).toString(16);\r\n    if (byte_.length === 1) byte_ = '0' + byte_;\r\n    bytes.push(byte_);\r\n  }\r\n  return '<' + type + ' ' + bytes.join(' ') + '>';\r\n}\r\n\r\n// Encode string as utf8 into dataview at offset\r\nfunction utf8Write(view: DataView, offset: number, string: string) {\r\n  for (let i = 0, l = string.length; i < l; i++) {\r\n    const codePoint = string.charCodeAt(i);\r\n\r\n    // One byte of UTF-8\r\n    if (codePoint < 0x80) {\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x7f) | 0x00);\r\n      continue;\r\n    }\r\n\r\n    // Two bytes of UTF-8\r\n    if (codePoint < 0x800) {\r\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x1f) | 0xc0);\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\r\n      continue;\r\n    }\r\n\r\n    // Three bytes of UTF-8.\r\n    if (codePoint < 0x10000) {\r\n      view.setUint8(offset++, ((codePoint >>> 12) & 0x0f) | 0xe0);\r\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\r\n      continue;\r\n    }\r\n\r\n    // Four bytes of UTF-8\r\n    if (codePoint < 0x110000) {\r\n      view.setUint8(offset++, ((codePoint >>> 18) & 0x07) | 0xf0);\r\n      view.setUint8(offset++, ((codePoint >>> 12) & 0x3f) | 0x80);\r\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\r\n      continue;\r\n    }\r\n    throw new Error('bad codepoint ' + codePoint);\r\n  }\r\n}\r\n\r\nfunction utf8Read(view: DataView, offset: number, length: number) {\r\n  let string = '';\r\n  for (let i = offset, end = offset + length; i < end; i++) {\r\n    const byte_ = view.getUint8(i);\r\n    // One byte character\r\n    if ((byte_ & 0x80) === 0x00) {\r\n      string += String.fromCharCode(byte_);\r\n      continue;\r\n    }\r\n    // Two byte character\r\n    if ((byte_ & 0xe0) === 0xc0) {\r\n      string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));\r\n      continue;\r\n    }\r\n    // Three byte character\r\n    if ((byte_ & 0xf0) === 0xe0) {\r\n      string += String.fromCharCode(\r\n        ((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0),\r\n      );\r\n      continue;\r\n    }\r\n    // Four byte character\r\n    if ((byte_ & 0xf8) === 0xf0) {\r\n      string += String.fromCharCode(\r\n        ((byte_ & 0x07) << 18) |\r\n          ((view.getUint8(++i) & 0x3f) << 12) |\r\n          ((view.getUint8(++i) & 0x3f) << 6) |\r\n          ((view.getUint8(++i) & 0x3f) << 0),\r\n      );\r\n      continue;\r\n    }\r\n    throw new Error('Invalid byte ' + byte_.toString(16));\r\n  }\r\n  return string;\r\n}\r\n\r\nfunction utf8ByteCount(string: string) {\r\n  let count = 0;\r\n  for (let i = 0, l = string.length; i < l; i++) {\r\n    const codePoint = string.charCodeAt(i);\r\n    if (codePoint < 0x80) {\r\n      count += 1;\r\n      continue;\r\n    }\r\n    if (codePoint < 0x800) {\r\n      count += 2;\r\n      continue;\r\n    }\r\n    if (codePoint < 0x10000) {\r\n      count += 3;\r\n      continue;\r\n    }\r\n    if (codePoint < 0x110000) {\r\n      count += 4;\r\n      continue;\r\n    }\r\n    throw new Error('bad codepoint ' + codePoint);\r\n  }\r\n  return count;\r\n}\r\n\r\nfunction encode(value: unknown, sparse?: boolean) {\r\n  const size = sizeof(value, sparse);\r\n  if (size === 0) return undefined;\r\n  const buffer = new ArrayBuffer(size);\r\n  const view = new DataView(buffer);\r\n  _encode(value, view, 0, sparse);\r\n  return buffer;\r\n}\r\n\r\nconst SH_L_32 = (1 << 16) * (1 << 16),\r\n  SH_R_32 = 1 / SH_L_32;\r\nfunction getInt64(view: DataView, offset: number) {\r\n  offset = offset || 0;\r\n  return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);\r\n}\r\n\r\nfunction getUint64(view: DataView, offset: number) {\r\n  offset = offset || 0;\r\n  return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);\r\n}\r\n\r\nfunction setInt64(view: DataView, offset: number, val: number) {\r\n  if (val < 0x8000000000000000) {\r\n    view.setInt32(offset, Math.floor(val * SH_R_32));\r\n    view.setInt32(offset + 4, val & -1);\r\n  } else {\r\n    view.setUint32(offset, 0x7fffffff);\r\n    view.setUint32(offset + 4, 0x7fffffff);\r\n  }\r\n}\r\n\r\nfunction setUint64(view: DataView, offset: number, val: number) {\r\n  if (val < 0x10000000000000000) {\r\n    view.setUint32(offset, Math.floor(val * SH_R_32));\r\n    view.setInt32(offset + 4, val & -1);\r\n  } else {\r\n    view.setUint32(offset, 0xffffffff);\r\n    view.setUint32(offset + 4, 0xffffffff);\r\n  }\r\n}\r\n\r\n// https://gist.github.com/frsyuki/5432559 - v5 spec\r\n//\r\n// I've used one extension point from `fixext 1` to store `undefined`. On the wire this\r\n// should translate to exactly 0xd40000\r\n//\r\n// +--------+--------+--------+\r\n// |  0xd4  |  0x00  |  0x00  |\r\n// +--------+--------+--------+\r\n//    ^ fixext |        ^ value part unused (fixed to be 0)\r\n//             ^ indicates undefined value\r\n//\r\n\r\nclass Decoder {\r\n  offset: number;\r\n  view: DataView;\r\n\r\n  constructor(view: DataView, offset?: number) {\r\n    this.offset = offset || 0;\r\n    this.view = view;\r\n  }\r\n\r\n  map = (length: number) => {\r\n    const value: { [key: string]: ArrayBuffer } = {};\r\n    for (let i = 0; i < length; i++) {\r\n      const key = this.parse();\r\n      value[key as string] = this.parse() as ArrayBuffer;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  bin = (length: number) => {\r\n    const value = new ArrayBuffer(length);\r\n    new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);\r\n    this.offset += length;\r\n    return value;\r\n  };\r\n\r\n  buf = this.bin;\r\n\r\n  str = (length: number) => {\r\n    const value = utf8Read(this.view, this.offset, length);\r\n    this.offset += length;\r\n    return value;\r\n  };\r\n\r\n  array = (length: number) => {\r\n    const value = new Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n      value[i] = this.parse();\r\n    }\r\n    return value;\r\n  };\r\n\r\n  ext = (length: number) => {\r\n    this.offset += length;\r\n    return {\r\n      type: this.view.getInt8(this.offset),\r\n      data: this.buf(length),\r\n    };\r\n  };\r\n\r\n  parse = (): unknown => {\r\n    const type = this.view.getUint8(this.offset);\r\n    let value, length;\r\n\r\n    // Positive FixInt - 0xxxxxxx\r\n    if ((type & 0x80) === 0x00) {\r\n      this.offset++;\r\n      return type;\r\n    }\r\n\r\n    // FixMap - 1000xxxx\r\n    if ((type & 0xf0) === 0x80) {\r\n      length = type & 0x0f;\r\n      this.offset++;\r\n      return this.map(length);\r\n    }\r\n\r\n    // FixArray - 1001xxxx\r\n    if ((type & 0xf0) === 0x90) {\r\n      length = type & 0x0f;\r\n      this.offset++;\r\n      return this.array(length);\r\n    }\r\n\r\n    // FixStr - 101xxxxx\r\n    if ((type & 0xe0) === 0xa0) {\r\n      length = type & 0x1f;\r\n      this.offset++;\r\n      return this.str(length);\r\n    }\r\n\r\n    // Negative FixInt - 111xxxxx\r\n    if ((type & 0xe0) === 0xe0) {\r\n      value = this.view.getInt8(this.offset);\r\n      this.offset++;\r\n      return value;\r\n    }\r\n\r\n    switch (type) {\r\n      // nil\r\n      case 0xc0:\r\n        this.offset++;\r\n        return null;\r\n\r\n      // 0xc1 never used - use for undefined (NON-STANDARD)\r\n      case 0xc1:\r\n        this.offset++;\r\n        return undefined;\r\n\r\n      // false\r\n      case 0xc2:\r\n        this.offset++;\r\n        return false;\r\n\r\n      // true\r\n      case 0xc3:\r\n        this.offset++;\r\n        return true;\r\n\r\n      // bin 8\r\n      case 0xc4:\r\n        length = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return this.bin(length);\r\n\r\n      // bin 16\r\n      case 0xc5:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.bin(length);\r\n\r\n      // bin 32\r\n      case 0xc6:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.bin(length);\r\n\r\n      // ext 8\r\n      case 0xc7:\r\n        length = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return this.ext(length);\r\n\r\n      // ext 16\r\n      case 0xc8:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.ext(length);\r\n\r\n      // ext 32\r\n      case 0xc9:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.ext(length);\r\n\r\n      // float 32\r\n      case 0xca:\r\n        value = this.view.getFloat32(this.offset + 1);\r\n        this.offset += 5;\r\n        return value;\r\n\r\n      // float 64\r\n      case 0xcb:\r\n        value = this.view.getFloat64(this.offset + 1);\r\n        this.offset += 9;\r\n        return value;\r\n\r\n      // uint8\r\n      case 0xcc:\r\n        value = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return value;\r\n\r\n      // uint 16\r\n      case 0xcd:\r\n        value = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return value;\r\n\r\n      // uint 32\r\n      case 0xce:\r\n        value = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return value;\r\n\r\n      // uint 64\r\n      case 0xcf:\r\n        value = getUint64(this.view, this.offset + 1);\r\n        this.offset += 9;\r\n        return value;\r\n\r\n      // int 8\r\n      case 0xd0:\r\n        value = this.view.getInt8(this.offset + 1);\r\n        this.offset += 2;\r\n        return value;\r\n\r\n      // int 16\r\n      case 0xd1:\r\n        value = this.view.getInt16(this.offset + 1);\r\n        this.offset += 3;\r\n        return value;\r\n\r\n      // int 32\r\n      case 0xd2:\r\n        value = this.view.getInt32(this.offset + 1);\r\n        this.offset += 5;\r\n        return value;\r\n\r\n      // int 64\r\n      case 0xd3:\r\n        value = getInt64(this.view, this.offset + 1);\r\n        this.offset += 9;\r\n        return value;\r\n\r\n      // fixext 1\r\n      case 0xd4:\r\n        length = 1;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 2\r\n      case 0xd5:\r\n        length = 2;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 4\r\n      case 0xd6:\r\n        length = 4;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 8\r\n      case 0xd7:\r\n        length = 8;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 16\r\n      case 0xd8:\r\n        length = 16;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // str8\r\n      case 0xd9:\r\n        length = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return this.str(length);\r\n\r\n      // str 16\r\n      case 0xda:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.str(length);\r\n\r\n      // str 32\r\n      case 0xdb:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.str(length);\r\n\r\n      // array 16\r\n      case 0xdc:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.array(length);\r\n\r\n      // array 32\r\n      case 0xdd:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.array(length);\r\n\r\n      // map 16\r\n      case 0xde:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.map(length);\r\n\r\n      // map 32\r\n      case 0xdf:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.map(length);\r\n    }\r\n    throw new Error('Unknown type 0x' + type.toString(16));\r\n  };\r\n}\r\n\r\nfunction decode(buffer: ArrayBuffer) {\r\n  const view = new DataView(buffer);\r\n  const decoder = new Decoder(view);\r\n  const value = decoder.parse();\r\n  if (decoder.offset !== buffer.byteLength) throw new Error(buffer.byteLength - decoder.offset + ' trailing bytes');\r\n  return value;\r\n}\r\n\r\nfunction encodeableKeys(value: { [key: string]: unknown }, sparse?: boolean) {\r\n  return Object.keys(value).filter(function (e) {\r\n    const val = value[e],\r\n      type = typeof val;\r\n    return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!(val as Date).toJSON);\r\n  });\r\n}\r\n\r\nfunction _encode(value: unknown, view: DataView, offset: number, sparse?: boolean): number {\r\n  const type = typeof value;\r\n\r\n  // Strings Bytes\r\n  // There are four string types: fixstr/str8/str16/str32\r\n  if (typeof value === 'string') {\r\n    const length = utf8ByteCount(value);\r\n\r\n    // fixstr\r\n    if (length < 0x20) {\r\n      view.setUint8(offset, length | 0xa0);\r\n      utf8Write(view, offset + 1, value);\r\n      return 1 + length;\r\n    }\r\n\r\n    // str8\r\n    if (length < 0x100) {\r\n      view.setUint8(offset, 0xd9);\r\n      view.setUint8(offset + 1, length);\r\n      utf8Write(view, offset + 2, value);\r\n      return 2 + length;\r\n    }\r\n\r\n    // str16\r\n    if (length < 0x10000) {\r\n      view.setUint8(offset, 0xda);\r\n      view.setUint16(offset + 1, length);\r\n      utf8Write(view, offset + 3, value);\r\n      return 3 + length;\r\n    }\r\n    // str32\r\n    if (length < 0x100000000) {\r\n      view.setUint8(offset, 0xdb);\r\n      view.setUint32(offset + 1, length);\r\n      utf8Write(view, offset + 5, value);\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\r\n    // extract the arraybuffer and fallthrough\r\n    value = value.buffer;\r\n  }\r\n\r\n  // There are three bin types: bin8/bin16/bin32\r\n  if (value instanceof ArrayBuffer) {\r\n    const length = value.byteLength;\r\n\r\n    // bin8\r\n    if (length < 0x100) {\r\n      view.setUint8(offset, 0xc4);\r\n      view.setUint8(offset + 1, length);\r\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);\r\n      return 2 + length;\r\n    }\r\n\r\n    // bin16\r\n    if (length < 0x10000) {\r\n      view.setUint8(offset, 0xc5);\r\n      view.setUint16(offset + 1, length);\r\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);\r\n      return 3 + length;\r\n    }\r\n\r\n    // bin 32\r\n    if (length < 0x100000000) {\r\n      view.setUint8(offset, 0xc6);\r\n      view.setUint32(offset + 1, length);\r\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    // Floating Point\r\n    // NOTE: We're always using float64\r\n    if (Math.floor(value) !== value) {\r\n      view.setUint8(offset, 0xcb);\r\n      view.setFloat64(offset + 1, value);\r\n      return 9;\r\n    }\r\n\r\n    // Integers\r\n    if (value >= 0) {\r\n      // positive fixnum\r\n      if (value < 0x80) {\r\n        view.setUint8(offset, value);\r\n        return 1;\r\n      }\r\n      // uint 8\r\n      if (value < 0x100) {\r\n        view.setUint8(offset, 0xcc);\r\n        view.setUint8(offset + 1, value);\r\n        return 2;\r\n      }\r\n      // uint 16\r\n      if (value < 0x10000) {\r\n        view.setUint8(offset, 0xcd);\r\n        view.setUint16(offset + 1, value);\r\n        return 3;\r\n      }\r\n      // uint 32\r\n      if (value < 0x100000000) {\r\n        view.setUint8(offset, 0xce);\r\n        view.setUint32(offset + 1, value);\r\n        return 5;\r\n      }\r\n      // uint 64\r\n      if (value < 0x10000000000000000) {\r\n        view.setUint8(offset, 0xcf);\r\n        setUint64(view, offset + 1, value);\r\n        return 9;\r\n      }\r\n      throw new Error('Number too big 0x' + value.toString(16));\r\n    }\r\n\r\n    // negative fixnum\r\n    if (value >= -0x20) {\r\n      view.setInt8(offset, value);\r\n      return 1;\r\n    }\r\n    // int 8\r\n    if (value >= -0x80) {\r\n      view.setUint8(offset, 0xd0);\r\n      view.setInt8(offset + 1, value);\r\n      return 2;\r\n    }\r\n    // int 16\r\n    if (value >= -0x8000) {\r\n      view.setUint8(offset, 0xd1);\r\n      view.setInt16(offset + 1, value);\r\n      return 3;\r\n    }\r\n    // int 32\r\n    if (value >= -0x80000000) {\r\n      view.setUint8(offset, 0xd2);\r\n      view.setInt32(offset + 1, value);\r\n      return 5;\r\n    }\r\n    // int 64\r\n    if (value >= -0x8000000000000000) {\r\n      view.setUint8(offset, 0xd3);\r\n      setInt64(view, offset + 1, value);\r\n      return 9;\r\n    }\r\n    throw new Error('Number too small -0x' + (-value).toString(16).substr(1));\r\n  }\r\n\r\n  // undefined - use d4 (NON-STANDARD)\r\n  if (type === 'undefined') {\r\n    if (sparse) return 0;\r\n    view.setUint8(offset, 0xd4);\r\n    view.setUint8(offset + 1, 0x00);\r\n    view.setUint8(offset + 2, 0x00);\r\n    return 3;\r\n  }\r\n\r\n  // null\r\n  if (value === null) {\r\n    if (sparse) return 0;\r\n    view.setUint8(offset, 0xc0);\r\n    return 1;\r\n  }\r\n\r\n  // Boolean\r\n  if (type === 'boolean') {\r\n    view.setUint8(offset, value ? 0xc3 : 0xc2);\r\n    return 1;\r\n  }\r\n\r\n  if ('function' === typeof (value as Date).toJSON) return _encode((value as Date).toJSON(), view, offset, sparse);\r\n\r\n  // Container Types\r\n  if (type === 'object') {\r\n    let length: number,\r\n      size = 0;\r\n    let keys: string[] | undefined;\r\n    const isArray = Array.isArray(value);\r\n\r\n    if (isArray) {\r\n      length = (value as unknown[]).length;\r\n    } else {\r\n      keys = encodeableKeys(value as { [key: string]: unknown }, sparse);\r\n      length = keys.length;\r\n    }\r\n\r\n    if (length < 0x10) {\r\n      view.setUint8(offset, length | (isArray ? 0x90 : 0x80));\r\n      size = 1;\r\n    } else if (length < 0x10000) {\r\n      view.setUint8(offset, isArray ? 0xdc : 0xde);\r\n      view.setUint16(offset + 1, length);\r\n      size = 3;\r\n    } else if (length < 0x100000000) {\r\n      view.setUint8(offset, isArray ? 0xdd : 0xdf);\r\n      view.setUint32(offset + 1, length);\r\n      size = 5;\r\n    }\r\n\r\n    if (isArray) {\r\n      for (let i = 0; i < length; i++) {\r\n        size += _encode((value as unknown[])[i], view, offset + size, sparse);\r\n      }\r\n    } else if (keys) {\r\n      for (let i = 0; i < length; i++) {\r\n        const key = keys[i];\r\n        size += _encode(key, view, offset + size);\r\n        size += _encode((value as { [key: string]: unknown })[key], view, offset + size, sparse);\r\n      }\r\n    }\r\n\r\n    return size;\r\n  }\r\n  if (type === 'function') return 0;\r\n\r\n  throw new Error('Unknown type ' + type);\r\n}\r\n\r\nfunction sizeof(value: unknown, sparse?: boolean): number {\r\n  const type = typeof value;\r\n\r\n  // fixstr or str8 or str16 or str32\r\n  if (type === 'string') {\r\n    const length = utf8ByteCount(value as string);\r\n    if (length < 0x20) {\r\n      return 1 + length;\r\n    }\r\n    if (length < 0x100) {\r\n      return 2 + length;\r\n    }\r\n    if (length < 0x10000) {\r\n      return 3 + length;\r\n    }\r\n    if (length < 0x100000000) {\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\r\n    // extract the arraybuffer and fallthrough\r\n    value = value.buffer;\r\n  }\r\n\r\n  // bin8 or bin16 or bin32\r\n  if (value instanceof ArrayBuffer) {\r\n    const length = value.byteLength;\r\n    if (length < 0x100) {\r\n      return 2 + length;\r\n    }\r\n    if (length < 0x10000) {\r\n      return 3 + length;\r\n    }\r\n    if (length < 0x100000000) {\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    // Floating Point (32 bits)\r\n    // double\r\n    if (Math.floor(value) !== value) return 9;\r\n\r\n    // Integers\r\n    if (value >= 0) {\r\n      // positive fixint\r\n      if (value < 0x80) return 1;\r\n      // uint 8\r\n      if (value < 0x100) return 2;\r\n      // uint 16\r\n      if (value < 0x10000) return 3;\r\n      // uint 32\r\n      if (value < 0x100000000) return 5;\r\n      // uint 64\r\n      if (value < 0x10000000000000000) return 9;\r\n      // Too big\r\n      throw new Error('Number too big 0x' + value.toString(16));\r\n    }\r\n    // negative fixint\r\n    if (value >= -0x20) return 1;\r\n    // int 8\r\n    if (value >= -0x80) return 2;\r\n    // int 16\r\n    if (value >= -0x8000) return 3;\r\n    // int 32\r\n    if (value >= -0x80000000) return 5;\r\n    // int 64\r\n    if (value >= -0x8000000000000000) return 9;\r\n    // Too small\r\n    throw new Error('Number too small -0x' + value.toString(16).substr(1));\r\n  }\r\n\r\n  // Boolean\r\n  if (type === 'boolean') return 1;\r\n\r\n  // undefined, null\r\n  if (value === null) return sparse ? 0 : 1;\r\n  if (value === undefined) return sparse ? 0 : 3;\r\n\r\n  if ('function' === typeof (value as Date).toJSON) return sizeof((value as Date).toJSON(), sparse);\r\n\r\n  // Container Types\r\n  if (type === 'object') {\r\n    let length: number,\r\n      size = 0;\r\n    if (Array.isArray(value)) {\r\n      length = value.length;\r\n      for (let i = 0; i < length; i++) {\r\n        size += sizeof(value[i], sparse);\r\n      }\r\n    } else {\r\n      const keys = encodeableKeys(value as { [key: string]: unknown }, sparse);\r\n      length = keys.length;\r\n      for (let i = 0; i < length; i++) {\r\n        const key = keys[i];\r\n        size += sizeof(key) + sizeof((value as { [key: string]: unknown })[key], sparse);\r\n      }\r\n    }\r\n    if (length < 0x10) {\r\n      return 1 + size;\r\n    }\r\n    if (length < 0x10000) {\r\n      return 3 + size;\r\n    }\r\n    if (length < 0x100000000) {\r\n      return 5 + size;\r\n    }\r\n    throw new Error('Array or object too long 0x' + length.toString(16));\r\n  }\r\n  if (type === 'function') return 0;\r\n\r\n  throw new Error('Unknown type ' + type);\r\n}\r\n\r\nexport default {\r\n  encode,\r\n  decode,\r\n  inspect,\r\n  utf8Write,\r\n  utf8Read,\r\n  utf8ByteCount,\r\n};\r\n", "import HttpMethods from 'common/constants/HttpMethods';\r\nimport BaseClient from 'common/lib/client/baseclient';\r\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport { RequestBody, RequestResultError, ResponseHeaders, RequestParams, RequestResult } from 'common/types/http';\r\nimport Platform from 'common/platform';\r\nimport Defaults from 'common/lib/util/defaults';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\nfunction isAblyError(responseBody: unknown, headers: Headers): responseBody is { error?: ErrorInfo } {\r\n  return !!headers.get('x-ably-errorcode');\r\n}\r\n\r\nfunction getAblyError(responseBody: unknown, headers: Headers) {\r\n  if (isAblyError(responseBody, headers)) {\r\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\r\n  }\r\n}\r\n\r\nfunction convertHeaders(headers: Headers) {\r\n  const result: ResponseHeaders = {};\r\n\r\n  headers.forEach((value, key) => {\r\n    result[key] = value;\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nexport default async function fetchRequest(\r\n  method: HttpMethods,\r\n  client: BaseClient | null,\r\n  uri: string,\r\n  headers: Record<string, string> | null,\r\n  params: RequestParams,\r\n  body: RequestBody | null,\r\n): Promise<RequestResult> {\r\n  const fetchHeaders = new Headers(headers || {});\r\n  const _method = method ? method.toUpperCase() : Utils.isNil(body) ? 'GET' : 'POST';\r\n\r\n  const controller = new AbortController();\r\n\r\n  let timeout: ReturnType<typeof setTimeout>; // This way we don\u2019t have to worry about the fact that the TypeScript compiler is \u2014 for reasons I haven\u2019t looked into \u2014 picking up the signature of the Node version of setTimeout, which has a different return type to the web one\r\n  const timeoutPromise: Promise<RequestResult> = new Promise((resolve) => {\r\n    timeout = setTimeout(\r\n      () => {\r\n        controller.abort();\r\n        // When AbortController.abort() is called, the fetch() promise rejects with a DOMException named AbortError (source: https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\r\n        // However, we beat it in the Promise.race() by resolving our custom 'Request timed out' error on the next line, thereby exposing users to the better-formatted error.\r\n        resolve({ error: new PartialErrorInfo('Request timed out', null, 408) });\r\n      },\r\n      client ? client.options.timeouts.httpRequestTimeout : Defaults.TIMEOUTS.httpRequestTimeout,\r\n    );\r\n  });\r\n\r\n  const requestInit: RequestInit = {\r\n    method: _method,\r\n    headers: fetchHeaders,\r\n    body: body as any,\r\n    signal: controller.signal,\r\n  };\r\n\r\n  if (!Platform.Config.isWebworker) {\r\n    requestInit.credentials = fetchHeaders.has('authorization') ? 'include' : 'same-origin';\r\n  }\r\n\r\n  const resultPromise = (async (): Promise<RequestResult> => {\r\n    try {\r\n      const res = await Utils.getGlobalObject().fetch(uri + '?' + new URLSearchParams(params || {}), requestInit);\r\n\r\n      clearTimeout(timeout!);\r\n\r\n      if (res.status == 204) {\r\n        return { error: null, statusCode: res.status };\r\n      }\r\n\r\n      const contentType = res.headers.get('Content-Type');\r\n      let body;\r\n      if (contentType && contentType.indexOf('application/x-msgpack') > -1) {\r\n        body = await res.arrayBuffer();\r\n      } else if (contentType && contentType.indexOf('application/json') > -1) {\r\n        body = await res.json();\r\n      } else {\r\n        body = await res.text();\r\n      }\r\n\r\n      const unpacked = !!contentType && contentType.indexOf('application/x-msgpack') === -1;\r\n      const headers = convertHeaders(res.headers);\r\n\r\n      if (!res.ok) {\r\n        const error =\r\n          getAblyError(body, res.headers) ||\r\n          new PartialErrorInfo(\r\n            'Error response received from server: ' + res.status + ' body was: ' + Platform.Config.inspect(body),\r\n            null,\r\n            res.status,\r\n          );\r\n\r\n        return { error, body, headers, unpacked, statusCode: res.status };\r\n      } else {\r\n        return { error: null, body, headers, unpacked, statusCode: res.status };\r\n      }\r\n    } catch (error) {\r\n      clearTimeout(timeout!);\r\n      return { error: error as RequestResultError };\r\n    }\r\n  })();\r\n\r\n  return Promise.race([timeoutPromise, resultPromise]);\r\n}\r\n", "import { HTTPRequestImplementations } from '../http';\r\nimport XHRRequest from './xhrrequest';\r\nimport fetchRequest from './fetchrequest';\r\n\r\nexport const defaultBundledRequestImplementations: HTTPRequestImplementations = {\r\n  XHRRequest: XHRRequest,\r\n  FetchRequest: fetchRequest,\r\n};\r\n\r\nexport const modularBundledRequestImplementations: HTTPRequestImplementations = {};\r\n"],
  "mappings": "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",
  "names": ["_a", "Format", "_a", "n", "agent", "Crypto", "HttpMethods", "HttpStatusCodes", "tokenDetails", "_a", "err", "_a", "_a", "version", "_a", "logResult", "headers", "params", "_a", "self", "_a", "headers", "Crypto", "fromEncoded", "fromValues", "decode", "fromEncodedArray", "decode", "fromResponseBody", "fromValues", "fromValuesArray", "headers", "fromResponseBody", "_a", "headers", "headers", "fromResponseBody", "headers", "version", "_a", "fromEncoded", "fromEncodedArray", "fromValues", "_a", "self", "actions", "serialize", "fromValues", "fromValuesArray", "actions", "fromValues", "actions", "_a", "TransportNames", "globalObject", "_a", "actions", "self", "connectionDetails", "fromValues", "noop", "_a", "actions", "fromValues", "decode", "_a", "Channels", "fromValues", "self", "serialize", "_a", "listeners", "_a", "fromValues", "fromValuesArray", "n", "hmac", "uint8Array", "hmac", "Crypto", "_a", "XHRStates", "Http", "_a", "body", "headers", "globalObject", "fromValues", "actions", "err", "_a", "noop", "statusCode", "_a", "shortName", "transport_default", "globalObject", "Defaults", "defaults_default", "encode", "decode", "isAblyError", "getAblyError", "body", "headers", "transport_default", "defaults_default"]
}
