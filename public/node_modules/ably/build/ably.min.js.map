{
  "version": 3,
  "sources": ["../src/platform/web/index.ts", "../src/common/platform.ts", "../src/common/lib/util/logger.ts", "../src/common/lib/util/utils.ts", "../src/common/lib/types/errorinfo.ts", "../package.json", "../src/common/lib/util/defaults.ts", "../src/common/lib/util/multicaster.ts", "../src/common/constants/HttpMethods.ts", "../src/common/constants/HttpStatusCodes.ts", "../src/common/lib/client/auth.ts", "../src/common/types/http.ts", "../src/common/lib/client/baseclient.ts", "../src/common/lib/types/devicedetails.ts", "../src/common/lib/client/resource.ts", "../src/common/lib/client/paginatedresource.ts", "../src/common/lib/types/pushchannelsubscription.ts", "../src/common/lib/client/push.ts", "../src/common/lib/types/message.ts", "../src/common/lib/types/presencemessage.ts", "../src/common/lib/client/restpresence.ts", "../src/common/lib/client/restchannel.ts", "../src/common/lib/types/stats.ts", "../src/common/lib/client/restchannelmixin.ts", "../src/common/lib/client/restpresencemixin.ts", "../src/common/lib/client/rest.ts", "../src/common/lib/client/baserest.ts", "../src/common/lib/client/modularplugins.ts", "../src/common/lib/types/defaultmessage.ts", "../src/common/lib/types/defaultpresencemessage.ts", "../src/common/lib/client/defaultrest.ts", "../src/common/lib/util/eventemitter.ts", "../src/common/lib/types/protocolmessage.ts", "../src/common/lib/transport/messagequeue.ts", "../src/common/lib/transport/protocol.ts", "../src/common/lib/client/connectionstatechange.ts", "../src/common/lib/transport/connectionerrors.ts", "../src/common/lib/transport/transport.ts", "../src/common/constants/TransportName.ts", "../src/common/lib/transport/connectionmanager.ts", "../src/common/lib/client/connection.ts", "../src/common/lib/client/channelstatechange.ts", "../src/common/lib/client/realtimechannel.ts", "../src/common/lib/client/baserealtime.ts", "../src/common/lib/client/realtimepresence.ts", "../src/common/lib/transport/websockettransport.ts", "../src/common/lib/client/filteredsubscriptions.ts", "../src/common/lib/client/defaultrealtime.ts", "../src/platform/web/lib/util/hmac-sha256.ts", "../src/platform/web/lib/util/bufferutils.ts", "../src/platform/web/lib/util/crypto.ts", "../src/common/constants/XHRStates.ts", "../src/platform/web/lib/http/http.ts", "../src/platform/web/config.ts", "../src/common/lib/transport/comettransport.ts", "../src/platform/web/lib/http/request/xhrrequest.ts", "../src/platform/web/lib/transport/xhrpollingtransport.ts", "../src/platform/web/lib/transport/index.ts", "../src/platform/web/lib/util/webstorage.ts", "../src/platform/web/lib/util/defaults.ts", "../src/platform/web/lib/util/msgpack.ts", "../src/platform/web/lib/http/request/fetchrequest.ts", "../src/platform/web/lib/http/request/index.ts"],
  "sourcesContent": ["// Common\r\nimport { DefaultRest } from '../../common/lib/client/defaultrest';\r\nimport { DefaultRealtime } from '../../common/lib/client/defaultrealtime';\r\nimport Platform from '../../common/platform';\r\nimport ErrorInfo from '../../common/lib/types/errorinfo';\r\nimport { fromDeserializedIncludingDependencies as protocolMessageFromDeserialized } from '../../common/lib/types/protocolmessage';\r\n\r\n// Platform Specific\r\nimport BufferUtils from './lib/util/bufferutils';\r\n// @ts-ignore\r\nimport { createCryptoClass } from './lib/util/crypto';\r\nimport Http from './lib/http/http';\r\nimport Config from './config';\r\n// @ts-ignore\r\nimport Transports from './lib/transport';\r\nimport Logger from '../../common/lib/util/logger';\r\nimport { getDefaults } from '../../common/lib/util/defaults';\r\nimport WebStorage from './lib/util/webstorage';\r\nimport PlatformDefaults from './lib/util/defaults';\r\nimport msgpack from './lib/util/msgpack';\r\nimport { defaultBundledRequestImplementations } from './lib/http/request';\r\n\r\nconst Crypto = createCryptoClass(Config, BufferUtils);\r\n\r\nPlatform.Crypto = Crypto;\r\nPlatform.BufferUtils = BufferUtils;\r\nPlatform.Http = Http;\r\nPlatform.Config = Config;\r\nPlatform.Transports = Transports;\r\nPlatform.WebStorage = WebStorage;\r\n\r\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\r\n  clientClass.Crypto = Crypto;\r\n  clientClass._MsgPack = msgpack;\r\n}\r\n\r\nHttp.bundledRequestImplementations = defaultBundledRequestImplementations;\r\n\r\nLogger.initLogHandlers();\r\n\r\nPlatform.Defaults = getDefaults(PlatformDefaults);\r\n\r\nif (Platform.Config.agent) {\r\n  // @ts-ignore\r\n  Platform.Defaults.agent += ' ' + Platform.Config.agent;\r\n}\r\n\r\nexport { DefaultRest as Rest, DefaultRealtime as Realtime, msgpack, protocolMessageFromDeserialized, ErrorInfo };\r\n\r\nexport default {\r\n  ErrorInfo,\r\n  Rest: DefaultRest,\r\n  Realtime: DefaultRealtime,\r\n  msgpack,\r\n};\r\n", "import { IPlatformConfig } from './types/IPlatformConfig';\r\nimport { IPlatformHttpStatic } from './types/http';\r\nimport IDefaults from './types/IDefaults';\r\nimport IWebStorage from './types/IWebStorage';\r\nimport IBufferUtils from './types/IBufferUtils';\r\nimport * as WebBufferUtils from '../platform/web/lib/util/bufferutils';\r\nimport * as NodeBufferUtils from '../platform/nodejs/lib/util/bufferutils';\r\nimport { IUntypedCryptoStatic } from '../common/types/ICryptoStatic';\r\nimport TransportName from './constants/TransportName';\r\nimport { TransportCtor } from './lib/transport/transport';\r\n\r\nexport type Bufferlike = WebBufferUtils.Bufferlike | NodeBufferUtils.Bufferlike;\r\ntype BufferUtilsOutput = WebBufferUtils.Output | NodeBufferUtils.Output;\r\ntype ToBufferOutput = WebBufferUtils.ToBufferOutput | NodeBufferUtils.ToBufferOutput;\r\n\r\nexport type TransportImplementations = Partial<Record<TransportName, TransportCtor>>;\r\n\r\nexport default class Platform {\r\n  static Config: IPlatformConfig;\r\n  /*\r\n     What we actually _want_ is for Platform to be a generic class\r\n     parameterised by Bufferlike etc, but that requires far-reaching changes to\r\n     components that make use of Platform. So instead we have to advertise a\r\n     BufferUtils object that accepts a broader range of data types than it\r\n     can in reality handle.\r\n   */\r\n  static BufferUtils: IBufferUtils<Bufferlike, BufferUtilsOutput, ToBufferOutput>;\r\n  /*\r\n     We\u2019d like this to be ICryptoStatic with the correct generic arguments,\r\n     but Platform doesn\u2019t currently allow that, as described in the BufferUtils\r\n     comment above.\r\n   */\r\n  static Crypto: IUntypedCryptoStatic | null;\r\n  static Http: IPlatformHttpStatic;\r\n  static Transports: {\r\n    order: TransportName[];\r\n    // Transport implementations that always come with this platform\r\n    bundledImplementations: TransportImplementations;\r\n  };\r\n  static Defaults: IDefaults;\r\n  static WebStorage: IWebStorage | null;\r\n}\r\n", "import Platform from 'common/platform';\r\n\r\nexport type LoggerOptions = {\r\n  handler: LoggerFunction;\r\n  level: LogLevels;\r\n};\r\ntype LoggerFunction = (...args: string[]) => void;\r\n\r\n// Workaround for salesforce lightning locker compatibility\r\n// This is a shorthand version of Utils.getGlobalObject (which we can't use here without creating a circular import)\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nenum LogLevels {\r\n  None = 0,\r\n  Error = 1,\r\n  Major = 2,\r\n  Minor = 3,\r\n  Micro = 4,\r\n}\r\n\r\nfunction pad(timeSegment: number, three?: number) {\r\n  return `${timeSegment}`.padStart(three ? 3 : 2, '0');\r\n}\r\n\r\nfunction getHandler(logger: Function): Function {\r\n  return Platform.Config.logTimestamps\r\n    ? function (msg: unknown) {\r\n        const time = new Date();\r\n        logger(\r\n          pad(time.getHours()) +\r\n            ':' +\r\n            pad(time.getMinutes()) +\r\n            ':' +\r\n            pad(time.getSeconds()) +\r\n            '.' +\r\n            pad(time.getMilliseconds(), 1) +\r\n            ' ' +\r\n            msg,\r\n        );\r\n      }\r\n    : function (msg: string) {\r\n        logger(msg);\r\n      };\r\n}\r\n\r\nconst getDefaultLoggers = (): [Function, Function] => {\r\n  let consoleLogger;\r\n  let errorLogger;\r\n\r\n  // we expect ably-js to be run in environments which have `console` object available with its `log` function\r\n  if (typeof globalObject?.console?.log === 'function') {\r\n    consoleLogger = function (...args: unknown[]) {\r\n      console.log.apply(console, args);\r\n    };\r\n\r\n    errorLogger = console.warn\r\n      ? function (...args: unknown[]) {\r\n          console.warn.apply(console, args);\r\n        }\r\n      : consoleLogger;\r\n  } else {\r\n    // otherwise we should fallback to noop for log functions\r\n    consoleLogger = errorLogger = function () {};\r\n  }\r\n\r\n  return [consoleLogger, errorLogger].map(getHandler) as [Function, Function];\r\n};\r\n\r\nclass Logger {\r\n  private static defaultLogLevel: LogLevels = LogLevels.Error;\r\n  private static defaultLogHandler: Function;\r\n  private static defaultLogErrorHandler: Function;\r\n\r\n  private logLevel: LogLevels;\r\n  private logHandler: Function;\r\n  private logErrorHandler: Function;\r\n\r\n  // public constants\r\n  static readonly LOG_NONE: LogLevels = LogLevels.None;\r\n  static readonly LOG_ERROR: LogLevels = LogLevels.Error;\r\n  static readonly LOG_MAJOR: LogLevels = LogLevels.Major;\r\n  static readonly LOG_MINOR: LogLevels = LogLevels.Minor;\r\n  static readonly LOG_MICRO: LogLevels = LogLevels.Micro;\r\n\r\n  /**\r\n   * This logger instance should only be used when there is no more appropriate logger to use, for example when implementing a public static method or function whose API doesn\u2019t accept any logging configuration.\r\n   */\r\n  static defaultLogger: Logger;\r\n\r\n  static initLogHandlers() {\r\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\r\n    this.defaultLogHandler = logHandler;\r\n    this.defaultLogErrorHandler = logErrorHandler;\r\n    this.defaultLogger = new Logger();\r\n  }\r\n\r\n  constructor() {\r\n    this.logLevel = Logger.defaultLogLevel;\r\n    this.logHandler = Logger.defaultLogHandler;\r\n    this.logErrorHandler = Logger.defaultLogErrorHandler;\r\n  }\r\n\r\n  /* public static functions */\r\n  /**\r\n   * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\r\n   *\r\n   * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you can\u2019t dynamically specify the log level.\r\n   */\r\n  static logAction = (logger: Logger, level: LogLevels, action: string, message?: string) => {\r\n    this.logActionNoStrip(logger, level, action, message);\r\n  };\r\n\r\n  /**\r\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\r\n   */\r\n  static logActionNoStrip(logger: Logger, level: LogLevels, action: string, message?: string) {\r\n    logger.logAction(level, action, message);\r\n  }\r\n\r\n  private logAction(level: LogLevels, action: string, message?: string) {\r\n    if (this.shouldLog(level)) {\r\n      (level === LogLevels.Error ? this.logErrorHandler : this.logHandler)('Ably: ' + action + ': ' + message, level);\r\n    }\r\n  }\r\n\r\n  deprecated = (description: string, msg: string) => {\r\n    this.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\r\n  };\r\n\r\n  renamedClientOption(oldName: string, newName: string) {\r\n    this.deprecationWarning(\r\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`,\r\n    );\r\n  }\r\n\r\n  renamedMethod(className: string, oldName: string, newName: string) {\r\n    this.deprecationWarning(\r\n      `\\`${className}\\`\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`,\r\n    );\r\n  }\r\n\r\n  deprecationWarning(message: string) {\r\n    if (this.shouldLog(LogLevels.Error)) {\r\n      this.logErrorHandler(`Ably: Deprecation warning - ${message}`, LogLevels.Error);\r\n    }\r\n  }\r\n\r\n  /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\r\n\t   the object being serialised if the log level will not output the message */\r\n  shouldLog = (level: LogLevels) => {\r\n    return level <= this.logLevel;\r\n  };\r\n\r\n  setLog = (level: LogLevels | undefined, handler: Function | undefined) => {\r\n    if (level !== undefined) this.logLevel = level;\r\n    if (handler !== undefined) this.logHandler = this.logErrorHandler = handler;\r\n  };\r\n}\r\n\r\nexport default Logger;\r\n", "import Platform from 'common/platform';\r\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport { ModularPlugins } from '../client/modularplugins';\r\nimport { MsgPack } from 'common/types/msgpack';\r\n\r\nfunction randomPosn(arrOrStr: Array<unknown> | string) {\r\n  return Math.floor(Math.random() * arrOrStr.length);\r\n}\r\n\r\n/**\r\n * Add a set of properties to a target object\r\n *\r\n * @param target the target object\r\n * @param args objects, which enumerable properties are added to target, by reference only\r\n * @returns target object with added properties\r\n */\r\nexport function mixin(\r\n  target: Record<string, unknown>,\r\n  ...args: Array<object | undefined | null>\r\n): Record<string, unknown> {\r\n  for (let i = 0; i < args.length; i++) {\r\n    const source = args[i];\r\n    if (!source) {\r\n      break;\r\n    }\r\n\r\n    for (const key in source) {\r\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n        target[key] = (source as Record<string, unknown>)[key];\r\n      }\r\n    }\r\n  }\r\n  return target;\r\n}\r\n\r\n/**\r\n * Creates a copy of enumerable properties of the source object\r\n *\r\n * @param src object to copy\r\n * @returns copy of src\r\n */\r\nexport function copy<T = Record<string, unknown>>(src: T | Record<string, unknown> | null | undefined): T {\r\n  return mixin({}, src as Record<string, unknown>) as T;\r\n}\r\n\r\n/*\r\n * Ensures that an Array object is always returned\r\n * returning the original Array of obj is an Array\r\n * else wrapping the obj in a single element Array\r\n */\r\nexport function ensureArray(obj: Record<string, unknown>): unknown[] {\r\n  if (isNil(obj)) {\r\n    return [];\r\n  }\r\n  if (Array.isArray(obj)) {\r\n    return obj;\r\n  }\r\n  return [obj];\r\n}\r\n\r\nexport function isObject(ob: unknown): ob is Record<string, unknown> {\r\n  return Object.prototype.toString.call(ob) == '[object Object]';\r\n}\r\n\r\n/*\r\n * Determine whether or not an object contains\r\n * any enumerable properties.\r\n * ob: the object\r\n */\r\nexport function isEmpty(ob: Record<string, unknown> | unknown[]): boolean {\r\n  for (const prop in ob) return false;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Checks if `value` is `null` or `undefined`.\r\n *\r\n * Source: https://github.com/lodash/lodash/blob/main/src/isNil.ts\r\n */\r\nexport function isNil(arg: unknown): arg is null | undefined {\r\n  return arg == null;\r\n}\r\n\r\n/*\r\n * Perform a simple shallow clone of an object.\r\n * Result is an object irrespective of whether\r\n * the input is an object or array. All\r\n * enumerable properties are copied.\r\n * ob: the object\r\n */\r\nexport function shallowClone(ob: Record<string, unknown>): Record<string, unknown> {\r\n  const result = new Object() as Record<string, unknown>;\r\n  for (const prop in ob) result[prop] = ob[prop];\r\n  return result;\r\n}\r\n\r\n/*\r\n * Clone an object by creating a new object with the\r\n * given object as its prototype. Optionally\r\n * a set of additional own properties can be\r\n * supplied to be added to the newly created clone.\r\n * ob:            the object to be cloned\r\n * ownProperties: optional object with additional\r\n *                properties to add\r\n */\r\nexport function prototypicalClone(\r\n  ob: Record<string, unknown>,\r\n  ownProperties: Record<string, unknown>,\r\n): Record<string, unknown> {\r\n  class F {}\r\n  F.prototype = ob;\r\n  const result = new F() as Record<string, unknown>;\r\n  if (ownProperties) mixin(result, ownProperties);\r\n  return result;\r\n}\r\n\r\n/*\r\n * Declare a constructor to represent a subclass\r\n * of another constructor\r\n * If platform has a built-in version we use that from Platform, else we\r\n * define here (so can make use of other Utils fns)\r\n * See node.js util.inherits\r\n */\r\nexport const inherits = function (ctor: any, superCtor: Function) {\r\n  if (Platform.Config.inherits) {\r\n    Platform.Config.inherits(ctor, superCtor);\r\n    return;\r\n  }\r\n  ctor.super_ = superCtor;\r\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\r\n};\r\n\r\n/*\r\n * Determine whether or not an object has an enumerable\r\n * property whose value equals a given value.\r\n * ob:  the object\r\n * val: the value to find\r\n */\r\nexport function containsValue(ob: Record<string, unknown>, val: unknown): boolean {\r\n  for (const i in ob) {\r\n    if (ob[i] == val) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function intersect<K extends string, T>(arr: Array<K>, ob: K[] | Partial<Record<K, T>>): K[] {\r\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\r\n}\r\n\r\nexport function arrIntersect<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\r\n  const result = [];\r\n  for (let i = 0; i < arr1.length; i++) {\r\n    const member = arr1[i];\r\n    if (arr2.indexOf(member) != -1) result.push(member);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function arrIntersectOb<K extends string>(arr: Array<K>, ob: Partial<Record<K, unknown>>): K[] {\r\n  const result = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const member = arr[i];\r\n    if (member in ob) result.push(member);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function arrSubtract<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\r\n  const result = [];\r\n  for (let i = 0; i < arr1.length; i++) {\r\n    const element = arr1[i];\r\n    if (arr2.indexOf(element) == -1) result.push(element);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function arrDeleteValue<T>(arr: Array<T>, val: T): boolean {\r\n  const idx = arr.indexOf(val);\r\n  const res = idx != -1;\r\n  if (res) arr.splice(idx, 1);\r\n  return res;\r\n}\r\n\r\nexport function arrWithoutValue<T>(arr: Array<T>, val: T): Array<T> {\r\n  const newArr = arr.slice();\r\n  arrDeleteValue(newArr, val);\r\n  return newArr;\r\n}\r\n\r\n/*\r\n * Construct an array of the keys of the enumerable\r\n * properties of a given object, optionally limited\r\n * to only the own properties.\r\n * ob:      the object\r\n * ownOnly: boolean, get own properties only\r\n */\r\nexport function keysArray(ob: Record<string, unknown>, ownOnly?: boolean): Array<string> {\r\n  const result = [];\r\n  for (const prop in ob) {\r\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\r\n    result.push(prop);\r\n  }\r\n  return result;\r\n}\r\n\r\n/*\r\n * Construct an array of the values of the enumerable\r\n * properties of a given object, optionally limited\r\n * to only the own properties.\r\n * ob:      the object\r\n * ownOnly: boolean, get own properties only\r\n */\r\nexport function valuesArray<T>(ob: Record<string, T>, ownOnly?: boolean): T[] {\r\n  const result = [];\r\n  for (const prop in ob) {\r\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\r\n    result.push(ob[prop]);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function forInOwnNonNullProperties(ob: Record<string, unknown>, fn: (prop: string) => void): void {\r\n  for (const prop in ob) {\r\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\r\n      fn(prop);\r\n    }\r\n  }\r\n}\r\n\r\nexport function allSame(arr: Array<Record<string, unknown>>, prop: string): boolean {\r\n  if (arr.length === 0) {\r\n    return true;\r\n  }\r\n  const first = arr[0][prop];\r\n  return arr.every(function (item) {\r\n    return item[prop] === first;\r\n  });\r\n}\r\n\r\nexport enum Format {\r\n  msgpack = 'msgpack',\r\n  json = 'json',\r\n}\r\n\r\nexport function arrPopRandomElement<T>(arr: Array<T>): T {\r\n  return arr.splice(randomPosn(arr), 1)[0];\r\n}\r\n\r\nexport function toQueryString(params?: Record<string, string> | null): string {\r\n  const parts = [];\r\n  if (params) {\r\n    for (const key in params) parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));\r\n  }\r\n  return parts.length ? '?' + parts.join('&') : '';\r\n}\r\n\r\nexport function parseQueryString(query: string): Record<string, string> {\r\n  let match;\r\n  const search = /([^?&=]+)=?([^&]*)/g;\r\n  const result: Record<string, string> = {};\r\n\r\n  while ((match = search.exec(query))) result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\r\n\r\n  return result;\r\n}\r\n\r\nexport function isErrorInfoOrPartialErrorInfo(err: unknown): err is ErrorInfo | PartialErrorInfo {\r\n  return typeof err == 'object' && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\r\n}\r\n\r\nexport function inspectError(err: unknown): string {\r\n  if (\r\n    err instanceof Error ||\r\n    (err as ErrorInfo)?.constructor?.name === 'ErrorInfo' ||\r\n    (err as PartialErrorInfo)?.constructor?.name === 'PartialErrorInfo'\r\n  )\r\n    return (err as Error).toString();\r\n  return Platform.Config.inspect(err);\r\n}\r\n\r\nexport function inspectBody(body: unknown): string {\r\n  if (Platform.BufferUtils.isBuffer(body)) {\r\n    return (body as any).toString();\r\n  } else if (typeof body === 'string') {\r\n    return body;\r\n  } else {\r\n    return Platform.Config.inspect(body);\r\n  }\r\n}\r\n\r\n/* Data is assumed to be either a string or a buffer. */\r\nexport function dataSizeBytes(data: string | Buffer): number {\r\n  if (Platform.BufferUtils.isBuffer(data)) {\r\n    return Platform.BufferUtils.byteLength(data);\r\n  }\r\n  if (typeof data === 'string') {\r\n    return Platform.Config.stringByteSize(data);\r\n  }\r\n  throw new Error('Expected input of Utils.dataSizeBytes to be a buffer or string, but was: ' + typeof data);\r\n}\r\n\r\nexport function cheapRandStr(): string {\r\n  return String(Math.random()).substr(2);\r\n}\r\n\r\n/* Takes param the minimum number of bytes of entropy the string must\r\n * include, not the length of the string. String length produced is not\r\n * guaranteed. */\r\nexport const randomString = async (numBytes: number): Promise<string> => {\r\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\r\n  return Platform.BufferUtils.base64Encode(buffer);\r\n};\r\n\r\n/* Pick n elements at random without replacement from an array */\r\nexport function arrChooseN<T>(arr: Array<T>, n: number): Array<T> {\r\n  const numItems = Math.min(n, arr.length),\r\n    mutableArr = arr.slice(),\r\n    result: Array<T> = [];\r\n  for (let i = 0; i < numItems; i++) {\r\n    result.push(arrPopRandomElement(mutableArr));\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Uses a callback to communicate the result of a `Promise`. The first argument passed to the callback will be either an error (when the promise is rejected) or `null` (when the promise is fulfilled). In the case where the promise is fulfilled, the resulting value will be passed to the callback as a second argument.\r\n */\r\nexport function whenPromiseSettles<T, E = unknown>(\r\n  promise: Promise<T>,\r\n  callback?: (err: E | null, result?: T) => void,\r\n) {\r\n  promise\r\n    .then((result) => {\r\n      callback?.(null, result);\r\n    })\r\n    .catch((err: unknown) => {\r\n      // We make no guarantees about the type of the error that gets passed to the callback. Issue https://github.com/ably/ably-js/issues/1617 will think about how to correctly handle error types.\r\n      callback?.(err as E);\r\n    });\r\n}\r\n\r\nexport function decodeBody<T>(body: unknown, MsgPack: MsgPack | null, format?: Format | null): T {\r\n  if (format == 'msgpack') {\r\n    if (!MsgPack) {\r\n      throwMissingPluginError('MsgPack');\r\n    }\r\n    return MsgPack.decode(body as Buffer);\r\n  }\r\n\r\n  return JSON.parse(String(body));\r\n}\r\n\r\nexport function encodeBody(body: unknown, MsgPack: MsgPack | null, format?: Format): string | Buffer {\r\n  if (format == 'msgpack') {\r\n    if (!MsgPack) {\r\n      throwMissingPluginError('MsgPack');\r\n    }\r\n    return MsgPack.encode(body, true) as Buffer;\r\n  }\r\n\r\n  return JSON.stringify(body);\r\n}\r\n\r\nexport function allToLowerCase(arr: Array<string>): Array<string> {\r\n  return arr.map(function (element) {\r\n    return element && element.toLowerCase();\r\n  });\r\n}\r\n\r\nexport function allToUpperCase(arr: Array<string>): Array<string> {\r\n  return arr.map(function (element) {\r\n    return element && element.toUpperCase();\r\n  });\r\n}\r\n\r\nexport function getBackoffCoefficient(count: number) {\r\n  return Math.min((count + 2) / 3, 2);\r\n}\r\n\r\nexport function getJitterCoefficient() {\r\n  return 1 - Math.random() * 0.2;\r\n}\r\n\r\n/**\r\n *\r\n * @param initialTimeout initial timeout value\r\n * @param retryAttempt integer indicating retryAttempt\r\n * @returns RetryTimeout value for given timeout and retryAttempt.\r\n * If x is the value generated then,\r\n * Upper bound = min((retryAttempt + 2) / 3, 2) * initialTimeout,\r\n * Lower bound = 0.8 * Upper bound,\r\n * Lower bound < x < Upper bound\r\n */\r\nexport function getRetryTime(initialTimeout: number, retryAttempt: number) {\r\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\r\n}\r\n\r\nexport function getGlobalObject() {\r\n  if (typeof global !== 'undefined') {\r\n    return global;\r\n  }\r\n\r\n  if (typeof window !== 'undefined') {\r\n    return window;\r\n  }\r\n\r\n  return self;\r\n}\r\n\r\nexport function shallowEquals(source: Record<string, unknown>, target: Record<string, unknown>) {\r\n  return (\r\n    Object.keys(source).every((key) => source[key] === target[key]) &&\r\n    Object.keys(target).every((key) => target[key] === source[key])\r\n  );\r\n}\r\n\r\nexport function matchDerivedChannel(name: string) {\r\n  /**\r\n   * This regex check is to retain existing channel params if any e.g [?rewind=1]foo to\r\n   * [filter=xyz?rewind=1]foo. This is to keep channel compatibility around use of\r\n   * channel params that work with derived channels.\r\n   *\r\n   * This eslint unsafe regex warning is triggered because the RegExp uses nested quantifiers,\r\n   * but it does not create any situation where the regex engine has to\r\n   * explore a large number of possible matches so it\u2019s safe to ignore\r\n   */\r\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/; // eslint-disable-line\r\n  const match = name.match(regex);\r\n  if (!match || !match.length || match.length < 5) {\r\n    throw new ErrorInfo('regex match failed', 400, 40010);\r\n  }\r\n  // Fail if there is already a channel qualifier, eg [meta]foo should fail instead of just overriding with [filter=xyz]foo\r\n  if (match![2]) {\r\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\r\n  }\r\n  // Return match values to be added to derive channel quantifier.\r\n  return {\r\n    qualifierParam: match[3] || '',\r\n    channelName: match[4],\r\n  };\r\n}\r\n\r\nexport function toBase64(str: string) {\r\n  const bufferUtils = Platform.BufferUtils;\r\n  const textBuffer = bufferUtils.utf8Encode(str);\r\n  return bufferUtils.base64Encode(textBuffer);\r\n}\r\n\r\nexport function arrEquals(a: any[], b: any[]) {\r\n  return (\r\n    a.length === b.length &&\r\n    a.every(function (val, i) {\r\n      return val === b[i];\r\n    })\r\n  );\r\n}\r\n\r\nexport function createMissingPluginError(pluginName: keyof ModularPlugins): ErrorInfo {\r\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\r\n}\r\n\r\nexport function throwMissingPluginError(pluginName: keyof ModularPlugins): never {\r\n  throw createMissingPluginError(pluginName);\r\n}\r\n\r\nexport async function withTimeoutAsync<A>(promise: Promise<A>, timeout = 5000, err = 'Timeout expired'): Promise<A> {\r\n  const e = new ErrorInfo(err, 50000, 500);\r\n  return Promise.race([promise, new Promise<A>((_resolve, reject) => setTimeout(() => reject(e), timeout))]);\r\n}\r\n", "import Platform from 'common/platform';\r\nimport * as Utils from '../util/utils';\r\nimport * as API from '../../../../ably';\r\n\r\nexport interface IPartialErrorInfo extends Error {\r\n  code: number | null;\r\n  statusCode?: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n}\r\n\r\nfunction toString(err: ErrorInfo | PartialErrorInfo) {\r\n  let result = '[' + err.constructor.name;\r\n  if (err.message) result += ': ' + err.message;\r\n  if (err.statusCode) result += '; statusCode=' + err.statusCode;\r\n  if (err.code) result += '; code=' + err.code;\r\n  if (err.cause) result += '; cause=' + Utils.inspectError(err.cause);\r\n  if (err.href && !(err.message && err.message.indexOf('help.ably.io') > -1)) result += '; see ' + err.href + ' ';\r\n  result += ']';\r\n  return result;\r\n}\r\n\r\nexport interface IConvertibleToErrorInfo {\r\n  message: string;\r\n  code: number;\r\n  statusCode: number;\r\n}\r\n\r\nexport interface IConvertibleToPartialErrorInfo {\r\n  message: string;\r\n  code: number | null;\r\n  statusCode?: number;\r\n}\r\n\r\nexport default class ErrorInfo extends Error implements IPartialErrorInfo, API.ErrorInfo {\r\n  code: number;\r\n  statusCode: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n\r\n  constructor(message: string, code: number, statusCode: number, cause?: string | Error | ErrorInfo) {\r\n    super(message);\r\n    if (typeof Object.setPrototypeOf !== 'undefined') {\r\n      Object.setPrototypeOf(this, ErrorInfo.prototype);\r\n    }\r\n    this.code = code;\r\n    this.statusCode = statusCode;\r\n    this.cause = cause;\r\n  }\r\n\r\n  toString(): string {\r\n    return toString(this);\r\n  }\r\n\r\n  static fromValues(values: IConvertibleToErrorInfo): ErrorInfo {\r\n    const { message, code, statusCode } = values;\r\n    if (typeof message !== 'string' || typeof code !== 'number' || typeof statusCode !== 'number') {\r\n      throw new Error('ErrorInfo.fromValues(): invalid values: ' + Platform.Config.inspect(values));\r\n    }\r\n    const result = Object.assign(new ErrorInfo(message, code, statusCode), values);\r\n    if (result.code && !result.href) {\r\n      result.href = 'https://help.ably.io/error/' + result.code;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\nexport class PartialErrorInfo extends Error implements IPartialErrorInfo {\r\n  code: number | null;\r\n  statusCode?: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n\r\n  constructor(message: string, code: number | null, statusCode?: number, cause?: string | Error | ErrorInfo) {\r\n    super(message);\r\n    if (typeof Object.setPrototypeOf !== 'undefined') {\r\n      Object.setPrototypeOf(this, PartialErrorInfo.prototype);\r\n    }\r\n    this.code = code;\r\n    this.statusCode = statusCode;\r\n    this.cause = cause;\r\n  }\r\n\r\n  toString(): string {\r\n    return toString(this);\r\n  }\r\n\r\n  static fromValues(values: IConvertibleToPartialErrorInfo): PartialErrorInfo {\r\n    const { message, code, statusCode } = values;\r\n    if (\r\n      typeof message !== 'string' ||\r\n      (!Utils.isNil(code) && typeof code !== 'number') ||\r\n      (!Utils.isNil(statusCode) && typeof statusCode !== 'number')\r\n    ) {\r\n      throw new Error('PartialErrorInfo.fromValues(): invalid values: ' + Platform.Config.inspect(values));\r\n    }\r\n    const result = Object.assign(new PartialErrorInfo(message, code, statusCode), values);\r\n    if (result.code && !result.href) {\r\n      result.href = 'https://help.ably.io/error/' + result.code;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n", "{\r\n  \"name\": \"ably\",\r\n  \"description\": \"Realtime client library for Ably, the realtime messaging service\",\r\n  \"version\": \"2.2.0\",\r\n  \"license\": \"Apache-2.0\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/ably/ably-js/issues\",\r\n    \"email\": \"support@ably.com\"\r\n  },\r\n  \"main\": \"./build/ably-node.js\",\r\n  \"browser\": \"./build/ably.js\",\r\n  \"react-native\": \"./build/ably-reactnative.js\",\r\n  \"typings\": \"./ably.d.ts\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"types\": \"./ably.d.ts\",\r\n      \"node\": \"./build/ably-node.js\",\r\n      \"react-native\": \"./build/ably-reactnative.js\",\r\n      \"default\": \"./build/ably.js\"\r\n    },\r\n    \"./modular\": {\r\n      \"types\": \"./modular.d.ts\",\r\n      \"import\": \"./build/modular/index.mjs\"\r\n    },\r\n    \"./react\": {\r\n      \"require\": \"./react/cjs/index.js\",\r\n      \"import\": \"./react/mjs/index.js\"\r\n    }\r\n  },\r\n  \"files\": [\r\n    \"build/**\",\r\n    \"ably.d.ts\",\r\n    \"modular.d.ts\",\r\n    \"resources/**\",\r\n    \"src/**\",\r\n    \"react/**\"\r\n  ],\r\n  \"dependencies\": {\r\n    \"@ably/msgpack-js\": \"^0.4.0\",\r\n    \"fastestsmallesttextencoderdecoder\": \"^1.0.22\",\r\n    \"got\": \"^11.8.5\",\r\n    \"ws\": \"^8.17.1\"\r\n  },\r\n  \"peerDependencies\": {\r\n    \"react\": \">=16.8.0\",\r\n    \"react-dom\": \">=16.8.0\"\r\n  },\r\n  \"peerDependenciesMeta\": {\r\n    \"react\": {\r\n      \"optional\": true\r\n    },\r\n    \"react-dom\": {\r\n      \"optional\": true\r\n    }\r\n  },\r\n  \"devDependencies\": {\r\n    \"@ably/vcdiff-decoder\": \"1.0.6\",\r\n    \"@arethetypeswrong/cli\": \"^0.13.1\",\r\n    \"@babel/generator\": \"^7.23.6\",\r\n    \"@babel/parser\": \"^7.23.6\",\r\n    \"@babel/traverse\": \"^7.23.7\",\r\n    \"@testing-library/react\": \"^13.3.0\",\r\n    \"@types/cli-table\": \"^0.3.4\",\r\n    \"@types/jmespath\": \"^0.15.2\",\r\n    \"@types/node\": \"^18.0.0\",\r\n    \"@types/request\": \"^2.48.7\",\r\n    \"@types/ws\": \"^8.2.0\",\r\n    \"@typescript-eslint/eslint-plugin\": \"^5.59.6\",\r\n    \"@typescript-eslint/parser\": \"^5.59.6\",\r\n    \"@vitejs/plugin-react\": \"^1.3.2\",\r\n    \"async\": \"ably-forks/async#requirejs\",\r\n    \"aws-sdk\": \"^2.1413.0\",\r\n    \"chai\": \"^4.2.0\",\r\n    \"cli-table\": \"^0.3.11\",\r\n    \"cors\": \"^2.8.5\",\r\n    \"esbuild\": \"^0.18.10\",\r\n    \"esbuild-plugin-umd-wrapper\": \"ably-forks/esbuild-plugin-umd-wrapper#1.0.7-optional-amd-named-module\",\r\n    \"esbuild-runner\": \"^2.2.2\",\r\n    \"eslint\": \"^7.13.0\",\r\n    \"eslint-plugin-import\": \"^2.28.0\",\r\n    \"eslint-plugin-jsdoc\": \"^40.0.0\",\r\n    \"eslint-plugin-react\": \"^7.32.2\",\r\n    \"eslint-plugin-react-hooks\": \"^4.6.0\",\r\n    \"eslint-plugin-security\": \"^1.4.0\",\r\n    \"express\": \"^4.17.1\",\r\n    \"glob\": \"~4.4\",\r\n    \"grunt\": \"^1.6.1\",\r\n    \"grunt-cli\": \"~1.2.0\",\r\n    \"grunt-shell\": \"~1.1\",\r\n    \"grunt-webpack\": \"^5.0.0\",\r\n    \"hexy\": \"~0.2\",\r\n    \"jmespath\": \"^0.16.0\",\r\n    \"jsdom\": \"^20.0.0\",\r\n    \"minimist\": \"^1.2.5\",\r\n    \"mocha\": \"^8.1.3\",\r\n    \"mocha-junit-reporter\": \"^2.2.1\",\r\n    \"path-browserify\": \"^1.0.1\",\r\n    \"playwright\": \"^1.39.0\",\r\n    \"prettier\": \"^2.8.8\",\r\n    \"process\": \"^0.11.10\",\r\n    \"react\": \">=18.1.0\",\r\n    \"react-dom\": \">=18.1.0\",\r\n    \"requirejs\": \"~2.1\",\r\n    \"shelljs\": \"~0.8\",\r\n    \"source-map-explorer\": \"^2.5.2\",\r\n    \"source-map-support\": \"^0.5.21\",\r\n    \"stream-browserify\": \"^3.0.0\",\r\n    \"ts-loader\": \"^9.4.2\",\r\n    \"tsconfig-paths-webpack-plugin\": \"^4.0.1\",\r\n    \"tslib\": \"^2.3.1\",\r\n    \"typedoc\": \"^0.24.7\",\r\n    \"typescript\": \"^4.9.5\",\r\n    \"vite\": \"^4.4.9\",\r\n    \"vitest\": \"^0.18.0\",\r\n    \"webpack\": \"^5.79.0\",\r\n    \"webpack-cli\": \"^5.0.1\"\r\n  },\r\n  \"engines\": {\r\n    \"node\": \">=16\"\r\n  },\r\n  \"repository\": \"ably/ably-js\",\r\n  \"jspm\": {\r\n    \"registry\": \"npm\",\r\n    \"directories\": {\r\n      \"lib\": \"build\"\r\n    },\r\n    \"main\": \"ably\"\r\n  },\r\n  \"scripts\": {\r\n    \"start:react\": \"npx vite serve\",\r\n    \"grunt\": \"grunt\",\r\n    \"test\": \"npm run test:node\",\r\n    \"test:node\": \"npm run build:node && mocha\",\r\n    \"test:node:skip-build\": \"mocha\",\r\n    \"test:webserver\": \"grunt test:webserver\",\r\n    \"test:playwright\": \"node test/support/runPlaywrightTests.js\",\r\n    \"test:react\": \"vitest run\",\r\n    \"test:package\": \"grunt test:package\",\r\n    \"concat\": \"grunt concat\",\r\n    \"build\": \"grunt build:all && npm run build:react\",\r\n    \"build:node\": \"grunt build:node\",\r\n    \"build:browser\": \"grunt build:browser\",\r\n    \"build:react\": \"npm run build:react:mjs && npm run build:react:cjs && cp src/platform/react-hooks/res/package.react.json react/package.json\",\r\n    \"build:react:mjs\": \"tsc --project src/platform/react-hooks/tsconfig.mjs.json && cp src/platform/react-hooks/res/package.mjs.json react/mjs/package.json\",\r\n    \"build:react:cjs\": \"tsc --project src/platform/react-hooks/tsconfig.cjs.json && cp src/platform/react-hooks/res/package.cjs.json react/cjs/package.json\",\r\n    \"requirejs\": \"grunt requirejs\",\r\n    \"lint\": \"eslint .\",\r\n    \"lint:fix\": \"eslint --fix .\",\r\n    \"prepare\": \"npm run build\",\r\n    \"format\": \"prettier --write --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts modular.d.ts webpack.config.js Gruntfile.js scripts/*.[jt]s docs/**/*.md grunt\",\r\n    \"format:check\": \"prettier --check --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts modular.d.ts webpack.config.js Gruntfile.js scripts/*.[jt]s docs/**/*.md grunt\",\r\n    \"sourcemap\": \"source-map-explorer build/ably.min.js\",\r\n    \"modulereport\": \"tsc --noEmit --esModuleInterop scripts/moduleReport.ts && esr scripts/moduleReport.ts\",\r\n    \"docs\": \"typedoc\"\r\n  }\r\n}\r\n", "import Platform from 'common/platform';\r\nimport * as Utils from './utils';\r\nimport Logger from './logger';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport { version } from '../../../../package.json';\r\nimport ClientOptions, { NormalisedClientOptions } from 'common/types/ClientOptions';\r\nimport IDefaults from '../../types/IDefaults';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { ChannelOptions } from 'common/types/channel';\r\nimport { ModularPlugins } from '../client/modularplugins';\r\n\r\nlet agent = 'ably-js/' + version;\r\n\r\ntype CompleteDefaults = IDefaults & {\r\n  ENVIRONMENT: string;\r\n  REST_HOST: string;\r\n  REALTIME_HOST: string;\r\n  FALLBACK_HOSTS: string[];\r\n  PORT: number;\r\n  TLS_PORT: number;\r\n  TIMEOUTS: {\r\n    disconnectedRetryTimeout: number;\r\n    suspendedRetryTimeout: number;\r\n    httpRequestTimeout: number;\r\n    httpMaxRetryDuration: number;\r\n    channelRetryTimeout: number;\r\n    fallbackRetryTimeout: number;\r\n    connectionStateTtl: number;\r\n    realtimeRequestTimeout: number;\r\n    recvTimeout: number;\r\n    webSocketConnectTimeout: number;\r\n    webSocketSlowTimeout: number;\r\n  };\r\n  httpMaxRetryCount: number;\r\n  maxMessageSize: number;\r\n  version: string;\r\n  protocolVersion: number;\r\n  agent: string;\r\n  getHost(options: ClientOptions, host?: string | null, ws?: boolean): string;\r\n  getPort(options: ClientOptions, tls?: boolean): number | undefined;\r\n  getHttpScheme(options: ClientOptions): string;\r\n  environmentFallbackHosts(environment: string): string[];\r\n  getFallbackHosts(options: NormalisedClientOptions): string[];\r\n  getHosts(options: NormalisedClientOptions, ws?: boolean): string[];\r\n  checkHost(host: string): void;\r\n  objectifyOptions(\r\n    options: undefined | ClientOptions | string,\r\n    allowKeyOrToken: boolean,\r\n    sourceForErrorMessage: string,\r\n    logger: Logger,\r\n    modularPluginsToInclude?: ModularPlugins,\r\n  ): ClientOptions;\r\n  normaliseOptions(options: ClientOptions, MsgPack: MsgPack | null, logger: Logger | null): NormalisedClientOptions;\r\n  defaultGetHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\r\n  defaultPostHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\r\n};\r\n\r\nconst Defaults = {\r\n  ENVIRONMENT: '',\r\n  REST_HOST: 'rest.ably.io',\r\n  REALTIME_HOST: 'realtime.ably.io',\r\n  FALLBACK_HOSTS: [\r\n    'A.ably-realtime.com',\r\n    'B.ably-realtime.com',\r\n    'C.ably-realtime.com',\r\n    'D.ably-realtime.com',\r\n    'E.ably-realtime.com',\r\n  ],\r\n  PORT: 80,\r\n  TLS_PORT: 443,\r\n  TIMEOUTS: {\r\n    /* Documented as options params: */\r\n    disconnectedRetryTimeout: 15000,\r\n    suspendedRetryTimeout: 30000,\r\n    /* Undocumented, but part of the api and can be used by customers: */\r\n    httpRequestTimeout: 10000,\r\n    httpMaxRetryDuration: 15000,\r\n    channelRetryTimeout: 15000,\r\n    fallbackRetryTimeout: 600000,\r\n    /* For internal / test use only: */\r\n    connectionStateTtl: 120000,\r\n    realtimeRequestTimeout: 10000,\r\n    recvTimeout: 90000,\r\n    webSocketConnectTimeout: 10000,\r\n    webSocketSlowTimeout: 4000,\r\n  },\r\n  httpMaxRetryCount: 3,\r\n  maxMessageSize: 65536,\r\n\r\n  version,\r\n  protocolVersion: 3,\r\n  agent,\r\n  getHost,\r\n  getPort,\r\n  getHttpScheme,\r\n  environmentFallbackHosts,\r\n  getFallbackHosts,\r\n  getHosts,\r\n  checkHost,\r\n  objectifyOptions,\r\n  normaliseOptions,\r\n  defaultGetHeaders,\r\n  defaultPostHeaders,\r\n};\r\n\r\nexport function getHost(options: ClientOptions, host?: string | null, ws?: boolean): string {\r\n  if (ws) host = (host == options.restHost && options.realtimeHost) || host || options.realtimeHost;\r\n  else host = host || options.restHost;\r\n\r\n  return host as string;\r\n}\r\n\r\nexport function getPort(options: ClientOptions, tls?: boolean): number | undefined {\r\n  return tls || options.tls ? options.tlsPort : options.port;\r\n}\r\n\r\nexport function getHttpScheme(options: ClientOptions): string {\r\n  return options.tls ? 'https://' : 'http://';\r\n}\r\n\r\n// construct environment fallback hosts as per RSC15i\r\nexport function environmentFallbackHosts(environment: string): string[] {\r\n  return [\r\n    environment + '-a-fallback.ably-realtime.com',\r\n    environment + '-b-fallback.ably-realtime.com',\r\n    environment + '-c-fallback.ably-realtime.com',\r\n    environment + '-d-fallback.ably-realtime.com',\r\n    environment + '-e-fallback.ably-realtime.com',\r\n  ];\r\n}\r\n\r\nexport function getFallbackHosts(options: NormalisedClientOptions): string[] {\r\n  const fallbackHosts = options.fallbackHosts,\r\n    httpMaxRetryCount =\r\n      typeof options.httpMaxRetryCount !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\r\n\r\n  return fallbackHosts ? Utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\r\n}\r\n\r\nexport function getHosts(options: NormalisedClientOptions, ws?: boolean): string[] {\r\n  const hosts = [options.restHost].concat(getFallbackHosts(options));\r\n  return ws ? hosts.map((host) => getHost(options, host, true)) : hosts;\r\n}\r\n\r\nfunction checkHost(host: string): void {\r\n  if (typeof host !== 'string') {\r\n    throw new ErrorInfo('host must be a string; was a ' + typeof host, 40000, 400);\r\n  }\r\n  if (!host.length) {\r\n    throw new ErrorInfo('host must not be zero-length', 40000, 400);\r\n  }\r\n}\r\n\r\nfunction getRealtimeHost(options: ClientOptions, production: boolean, environment: string, logger: Logger): string {\r\n  if (options.realtimeHost) return options.realtimeHost;\r\n  /* prefer setting realtimeHost to restHost as a custom restHost typically indicates\r\n   * a development environment is being used that can't be inferred by the library */\r\n  if (options.restHost) {\r\n    Logger.logAction(\r\n      logger,\r\n      Logger.LOG_MINOR,\r\n      'Defaults.normaliseOptions',\r\n      'restHost is set to \"' +\r\n        options.restHost +\r\n        '\" but realtimeHost is not set, so setting realtimeHost to \"' +\r\n        options.restHost +\r\n        '\" too. If this is not what you want, please set realtimeHost explicitly.',\r\n    );\r\n    return options.restHost;\r\n  }\r\n  return production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;\r\n}\r\n\r\nfunction getTimeouts(options: ClientOptions) {\r\n  /* Allow values passed in options to override default timeouts */\r\n  const timeouts: Record<string, number> = {};\r\n  for (const prop in Defaults.TIMEOUTS) {\r\n    timeouts[prop] = (options as Record<string, number>)[prop] || (Defaults.TIMEOUTS as Record<string, number>)[prop];\r\n  }\r\n  return timeouts;\r\n}\r\n\r\nexport function getAgentString(options: ClientOptions): string {\r\n  let agentStr = Defaults.agent;\r\n  if (options.agents) {\r\n    for (var agent in options.agents) {\r\n      agentStr += ' ' + agent + '/' + options.agents[agent];\r\n    }\r\n  }\r\n  return agentStr;\r\n}\r\n\r\nexport function objectifyOptions(\r\n  options: undefined | ClientOptions | string,\r\n  allowKeyOrToken: boolean,\r\n  sourceForErrorMessage: string,\r\n  logger: Logger,\r\n  modularPluginsToInclude?: ModularPlugins,\r\n): ClientOptions {\r\n  if (options === undefined) {\r\n    const msg = allowKeyOrToken\r\n      ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token`\r\n      : `${sourceForErrorMessage} must be initialized with a client options object`;\r\n    Logger.logAction(logger, Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n    throw new Error(msg);\r\n  }\r\n\r\n  let optionsObj: ClientOptions;\r\n\r\n  if (typeof options === 'string') {\r\n    if (options.indexOf(':') == -1) {\r\n      if (!allowKeyOrToken) {\r\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\u2019s \\`token\\` property.)`;\r\n        Logger.logAction(logger, Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n        throw new Error(msg);\r\n      }\r\n\r\n      optionsObj = { token: options };\r\n    } else {\r\n      if (!allowKeyOrToken) {\r\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\u2019s \\`key\\` property.)`;\r\n        Logger.logAction(logger, Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n        throw new Error(msg);\r\n      }\r\n\r\n      optionsObj = { key: options };\r\n    }\r\n  } else {\r\n    optionsObj = options;\r\n  }\r\n\r\n  if (modularPluginsToInclude) {\r\n    optionsObj = { ...optionsObj, plugins: { ...modularPluginsToInclude, ...optionsObj.plugins } };\r\n  }\r\n\r\n  return optionsObj;\r\n}\r\n\r\nexport function normaliseOptions(\r\n  options: ClientOptions,\r\n  MsgPack: MsgPack | null,\r\n  logger: Logger | null, // should only be omitted by tests\r\n): NormalisedClientOptions {\r\n  const loggerToUse = logger ?? Logger.defaultLogger;\r\n\r\n  if (typeof options.recover === 'function' && options.closeOnUnload === true) {\r\n    Logger.logAction(\r\n      loggerToUse,\r\n      Logger.LOG_ERROR,\r\n      'Defaults.normaliseOptions',\r\n      'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter',\r\n    );\r\n    options.recover = undefined;\r\n  }\r\n\r\n  if (!('closeOnUnload' in options)) {\r\n    /* Have closeOnUnload default to true unless we have any indication that\r\n     * the user may want to recover the connection */\r\n    options.closeOnUnload = !options.recover;\r\n  }\r\n\r\n  if (!('queueMessages' in options)) options.queueMessages = true;\r\n\r\n  /* infer hosts and fallbacks based on the configured environment */\r\n  const environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;\r\n  const production = !environment || environment === 'production';\r\n\r\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\r\n    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\r\n  }\r\n\r\n  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST);\r\n  const realtimeHost = getRealtimeHost(options, production, environment, loggerToUse);\r\n\r\n  (options.fallbackHosts || []).concat(restHost, realtimeHost).forEach(checkHost);\r\n\r\n  options.port = options.port || Defaults.PORT;\r\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\r\n  if (!('tls' in options)) options.tls = true;\r\n\r\n  const timeouts = getTimeouts(options);\r\n\r\n  if (MsgPack) {\r\n    if ('useBinaryProtocol' in options) {\r\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\r\n    } else {\r\n      options.useBinaryProtocol = Platform.Config.preferBinary;\r\n    }\r\n  } else {\r\n    options.useBinaryProtocol = false;\r\n  }\r\n\r\n  const headers: Record<string, string> = {};\r\n  if (options.clientId) {\r\n    headers['X-Ably-ClientId'] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\r\n  }\r\n\r\n  if (!('idempotentRestPublishing' in options)) {\r\n    options.idempotentRestPublishing = true;\r\n  }\r\n\r\n  let connectivityCheckParams = null;\r\n  let connectivityCheckUrl = options.connectivityCheckUrl;\r\n  if (options.connectivityCheckUrl) {\r\n    let [uri, qs] = options.connectivityCheckUrl.split('?');\r\n    connectivityCheckParams = qs ? Utils.parseQueryString(qs) : {};\r\n    if (uri.indexOf('://') === -1) {\r\n      uri = 'https://' + uri;\r\n    }\r\n    connectivityCheckUrl = uri;\r\n  }\r\n\r\n  return {\r\n    ...options,\r\n    realtimeHost,\r\n    restHost,\r\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\r\n    timeouts,\r\n    connectivityCheckParams,\r\n    connectivityCheckUrl,\r\n    headers,\r\n  };\r\n}\r\n\r\nexport function normaliseChannelOptions(Crypto: IUntypedCryptoStatic | null, logger: Logger, options?: ChannelOptions) {\r\n  const channelOptions = options || {};\r\n  if (channelOptions.cipher) {\r\n    if (!Crypto) Utils.throwMissingPluginError('Crypto');\r\n    const cipher = Crypto.getCipher(channelOptions.cipher, logger);\r\n    channelOptions.cipher = cipher.cipherParams;\r\n    channelOptions.channelCipher = cipher.cipher;\r\n  } else if ('cipher' in channelOptions) {\r\n    /* Don't deactivate an existing cipher unless options\r\n     * has a 'cipher' key that's falsey */\r\n    channelOptions.cipher = undefined;\r\n    channelOptions.channelCipher = null;\r\n  }\r\n  return channelOptions;\r\n}\r\n\r\nconst contentTypes = {\r\n  json: 'application/json',\r\n  xml: 'application/xml',\r\n  html: 'text/html',\r\n  msgpack: 'application/x-msgpack',\r\n};\r\n\r\nexport interface HeadersOptions {\r\n  format?: Utils.Format;\r\n  protocolVersion?: number;\r\n}\r\n\r\nconst defaultHeadersOptions: Required<HeadersOptions> = {\r\n  format: Utils.Format.json,\r\n  protocolVersion: Defaults.protocolVersion,\r\n};\r\n\r\nexport function defaultGetHeaders(\r\n  options: NormalisedClientOptions,\r\n  {\r\n    format = defaultHeadersOptions.format,\r\n    protocolVersion = defaultHeadersOptions.protocolVersion,\r\n  }: HeadersOptions = {},\r\n): Record<string, string> {\r\n  const accept = contentTypes[format];\r\n  return {\r\n    accept: accept,\r\n    'X-Ably-Version': protocolVersion.toString(),\r\n    'Ably-Agent': getAgentString(options),\r\n  };\r\n}\r\n\r\nexport function defaultPostHeaders(\r\n  options: NormalisedClientOptions,\r\n  {\r\n    format = defaultHeadersOptions.format,\r\n    protocolVersion = defaultHeadersOptions.protocolVersion,\r\n  }: HeadersOptions = {},\r\n): Record<string, string> {\r\n  let contentType;\r\n  const accept = (contentType = contentTypes[format]);\r\n\r\n  return {\r\n    accept: accept,\r\n    'content-type': contentType,\r\n    'X-Ably-Version': protocolVersion.toString(),\r\n    'Ably-Agent': getAgentString(options),\r\n  };\r\n}\r\n\r\nexport default Defaults as CompleteDefaults;\r\n\r\nexport function getDefaults(platformDefaults: IDefaults) {\r\n  return Object.assign(Defaults, platformDefaults);\r\n}\r\n", "import { StandardCallback } from 'common/types/utils';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport Logger from './logger';\r\n\r\nexport interface MulticasterInstance<T> extends Function {\r\n  (err?: ErrorInfo | null, result?: T): void;\r\n  push: (fn: StandardCallback<T>) => void;\r\n  /**\r\n   * Creates a promise that will be resolved or rejected when this instance is called.\r\n   */\r\n  createPromise: () => Promise<T>;\r\n  /**\r\n   * Syntatic sugar for when working in a context that uses promises; equivalent to calling as a function with arguments (null, result).\r\n   */\r\n  resolveAll(result: T): void;\r\n  /**\r\n   * Syntatic sugar for when working in a context that uses promises; equivalent to calling as a function with arguments (err).\r\n   */\r\n  rejectAll(err: ErrorInfo): void;\r\n}\r\n\r\nclass Multicaster<T> {\r\n  members: Array<StandardCallback<T>>;\r\n\r\n  // Private constructor; use static Multicaster.create instead\r\n  private constructor(private readonly logger: Logger, members?: Array<StandardCallback<T> | undefined>) {\r\n    this.members = (members as Array<StandardCallback<T>>) || [];\r\n  }\r\n\r\n  private call(err?: ErrorInfo | null, result?: T): void {\r\n    for (const member of this.members) {\r\n      if (member) {\r\n        try {\r\n          member(err, result);\r\n        } catch (e) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_ERROR,\r\n            'Multicaster multiple callback handler',\r\n            'Unexpected exception: ' + e + '; stack = ' + (e as Error).stack,\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  push(...args: Array<StandardCallback<T>>): void {\r\n    this.members.push(...args);\r\n  }\r\n\r\n  createPromise(): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      this.push((err, result) => {\r\n        err ? reject(err) : resolve(result!);\r\n      });\r\n    });\r\n  }\r\n\r\n  resolveAll(result: T) {\r\n    this.call(null, result);\r\n  }\r\n\r\n  rejectAll(err: ErrorInfo) {\r\n    this.call(err);\r\n  }\r\n\r\n  static create<T>(logger: Logger, members?: Array<StandardCallback<T> | undefined>): MulticasterInstance<T> {\r\n    const instance = new Multicaster(logger, members);\r\n    return Object.assign((err?: ErrorInfo | null, result?: T) => instance.call(err, result), {\r\n      push: (fn: StandardCallback<T>) => instance.push(fn),\r\n      createPromise: () => instance.createPromise(),\r\n      resolveAll: (result: T) => instance.resolveAll(result),\r\n      rejectAll: (err: ErrorInfo) => instance.rejectAll(err),\r\n    });\r\n  }\r\n}\r\n\r\nexport default Multicaster;\r\n", "enum HttpMethods {\r\n  Get = 'get',\r\n  Delete = 'delete',\r\n  Post = 'post',\r\n  Put = 'put',\r\n  Patch = 'patch',\r\n}\r\n\r\nexport default HttpMethods;\r\n", "enum HttpStatusCodes {\r\n  Success = 200,\r\n  NoContent = 204,\r\n  BadRequest = 400,\r\n  Unauthorized = 401,\r\n  Forbidden = 403,\r\n  RequestTimeout = 408,\r\n  InternalServerError = 500,\r\n}\r\n\r\nexport function isSuccessCode(statusCode: number) {\r\n  return statusCode >= HttpStatusCodes.Success && statusCode < HttpStatusCodes.BadRequest;\r\n}\r\n\r\nexport default HttpStatusCodes;\r\n", "import Logger from '../util/logger';\r\nimport * as Utils from '../util/utils';\r\nimport Multicaster, { MulticasterInstance } from '../util/multicaster';\r\nimport ErrorInfo, { IPartialErrorInfo } from '../types/errorinfo';\r\nimport { RequestResultError, RequestParams, RequestResult } from '../../types/http';\r\nimport * as API from '../../../../ably';\r\nimport BaseClient from './baseclient';\r\nimport BaseRealtime from './baserealtime';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport HttpStatusCodes from 'common/constants/HttpStatusCodes';\r\nimport Platform, { Bufferlike } from '../../platform';\r\nimport Defaults from '../util/defaults';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\ntype TokenRevocationTargetSpecifier = API.TokenRevocationTargetSpecifier;\r\ntype TokenRevocationOptions = API.TokenRevocationOptions;\r\ntype TokenRevocationSuccessResult = API.TokenRevocationSuccessResult;\r\ntype TokenRevocationFailureResult = API.TokenRevocationFailureResult;\r\ntype TokenRevocationResult = BatchResult<TokenRevocationSuccessResult | TokenRevocationFailureResult>;\r\n\r\nconst MAX_TOKEN_LENGTH = Math.pow(2, 17);\r\nfunction random() {\r\n  return ('000000' + Math.floor(Math.random() * 1e16)).slice(-16);\r\n}\r\n\r\nfunction isRealtime(client: BaseClient): client is BaseRealtime {\r\n  return !!(client as BaseRealtime).connection;\r\n}\r\n\r\n/* A client auth callback may give errors in any number of formats; normalise to an ErrorInfo or PartialErrorInfo */\r\nfunction normaliseAuthcallbackError(err: any) {\r\n  if (!Utils.isErrorInfoOrPartialErrorInfo(err)) {\r\n    return new ErrorInfo(Utils.inspectError(err), err.code || 40170, err.statusCode || 401);\r\n  }\r\n  /* network errors will not have an inherent error code */\r\n  if (!err.code) {\r\n    if (err.statusCode === 403) {\r\n      err.code = 40300;\r\n    } else {\r\n      err.code = 40170;\r\n      /* normalise statusCode to 401 per RSA4e */\r\n      err.statusCode = 401;\r\n    }\r\n  }\r\n  return err;\r\n}\r\n\r\nlet hmac = (text: string, key: string): string => {\r\n  const bufferUtils = Platform.BufferUtils;\r\n\r\n  const textBuffer = bufferUtils.utf8Encode(text);\r\n  const keyBuffer = bufferUtils.utf8Encode(key);\r\n\r\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\r\n\r\n  return bufferUtils.base64Encode(digest);\r\n};\r\n\r\nfunction c14n(capability?: string | Record<string, Array<string>>) {\r\n  if (!capability) return '';\r\n\r\n  if (typeof capability == 'string') capability = JSON.parse(capability);\r\n\r\n  const c14nCapability: Record<string, Array<string>> = Object.create(null);\r\n  const keys = Utils.keysArray(capability as Record<string, Array<string>>, true);\r\n  if (!keys) return '';\r\n  keys.sort();\r\n  for (let i = 0; i < keys.length; i++) {\r\n    c14nCapability[keys[i]] = (capability as Record<string, Array<string>>)[keys[i]].sort();\r\n  }\r\n  return JSON.stringify(c14nCapability);\r\n}\r\n\r\nfunction logAndValidateTokenAuthMethod(authOptions: AuthOptions, logger: Logger) {\r\n  if (authOptions.authCallback) {\r\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with authCallback');\r\n  } else if (authOptions.authUrl) {\r\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with authUrl');\r\n  } else if (authOptions.key) {\r\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');\r\n  } else if (authOptions.tokenDetails) {\r\n    Logger.logAction(logger, Logger.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');\r\n  } else {\r\n    const msg = 'authOptions must include valid authentication parameters';\r\n    Logger.logAction(logger, Logger.LOG_ERROR, 'Auth()', msg);\r\n    throw new Error(msg);\r\n  }\r\n}\r\n\r\nfunction basicAuthForced(options: ClientOptions) {\r\n  return 'useTokenAuth' in options && !options.useTokenAuth;\r\n}\r\n\r\n/* RSA4 */\r\nexport function useTokenAuth(options: ClientOptions) {\r\n  return (\r\n    options.useTokenAuth ||\r\n    (!basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails))\r\n  );\r\n}\r\n\r\n/* RSA4a */\r\nfunction noWayToRenew(options: ClientOptions) {\r\n  return !options.key && !options.authCallback && !options.authUrl;\r\n}\r\n\r\nlet trId = 0;\r\nfunction getTokenRequestId() {\r\n  return trId++;\r\n}\r\n\r\n/**\r\n * Auth options used only for testing.\r\n */\r\ntype PrivateAuthOptions = {\r\n  requestHeaders?: Record<string, string>;\r\n  suppressMaxLengthCheck?: boolean;\r\n};\r\n\r\ntype AuthOptions = API.AuthOptions & PrivateAuthOptions;\r\n\r\nclass Auth {\r\n  client: BaseClient;\r\n  tokenParams: API.TokenParams;\r\n  currentTokenRequestId: number | null;\r\n  waitingForTokenRequest: MulticasterInstance<API.TokenDetails> | null;\r\n  // This initialization is always overwritten and only used to prevent a TypeScript compiler error\r\n  authOptions: AuthOptions = {} as AuthOptions;\r\n  tokenDetails?: API.TokenDetails | null;\r\n  method?: string;\r\n  key?: string;\r\n  basicKey?: string;\r\n  clientId?: string | null;\r\n\r\n  constructor(client: BaseClient, options: ClientOptions) {\r\n    this.client = client;\r\n    this.tokenParams = options.defaultTokenParams || {};\r\n    /* The id of the current token request if one is in progress, else null */\r\n    this.currentTokenRequestId = null;\r\n    this.waitingForTokenRequest = null;\r\n\r\n    if (useTokenAuth(options)) {\r\n      /* Token auth */\r\n      if (noWayToRenew(options)) {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_ERROR,\r\n          'Auth()',\r\n          'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help',\r\n        );\r\n      }\r\n      this._saveTokenOptions(options.defaultTokenParams as API.TokenDetails, options);\r\n      logAndValidateTokenAuthMethod(this.authOptions, this.logger);\r\n    } else {\r\n      /* Basic auth */\r\n      if (!options.key) {\r\n        const msg =\r\n          'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';\r\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth()', msg);\r\n        throw new ErrorInfo(msg, 40160, 401);\r\n      }\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');\r\n      this._saveBasicOptions(options);\r\n    }\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.client.logger;\r\n  }\r\n\r\n  /**\r\n   * Instructs the library to get a token immediately and ensures Token Auth\r\n   * is used for all future requests, storing the tokenParams and authOptions\r\n   * given as the new defaults for subsequent use.\r\n   */\r\n  async authorize(): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Instructs the library to get a token immediately and ensures Token Auth\r\n   * is used for all future requests, storing the tokenParams and authOptions\r\n   * given as the new defaults for subsequent use.\r\n   *\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   *\r\n   * - ttl:        (optional) the requested life of any new token in ms. If none\r\n   *               is specified a default of 1 hour is provided. The maximum lifetime\r\n   *               is 24hours; any request exceeding that lifetime will be rejected\r\n   *               with an error.\r\n   *\r\n   * - capability: (optional) the capability to associate with the access token.\r\n   *               If none is specified, a token will be requested with all of the\r\n   *               capabilities of the specified key.\r\n   *\r\n   * - clientId:   (optional) a client ID to associate with the token\r\n   *\r\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\r\n   *               the system will be queried for a time value to use.\r\n   */\r\n  async authorize(tokenParams: API.TokenParams | null): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Instructs the library to get a token immediately and ensures Token Auth\r\n   * is used for all future requests, storing the tokenParams and authOptions\r\n   * given as the new defaults for subsequent use.\r\n   *\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   *\r\n   * - ttl:        (optional) the requested life of any new token in ms. If none\r\n   *               is specified a default of 1 hour is provided. The maximum lifetime\r\n   *               is 24hours; any request exceeding that lifetime will be rejected\r\n   *               with an error.\r\n   *\r\n   * - capability: (optional) the capability to associate with the access token.\r\n   *               If none is specified, a token will be requested with all of the\r\n   *               capabilities of the specified key.\r\n   *\r\n   * - clientId:   (optional) a client ID to associate with the token\r\n   *\r\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\r\n   *               the system will be queried for a time value to use.\r\n   *\r\n   * @param authOptions\r\n   * an object containing auth options relevant to token auth:\r\n   *\r\n   * - queryTime   (optional) boolean indicating that the Ably system should be\r\n   *               queried for the current time when none is specified explicitly.\r\n   *\r\n   * - tokenDetails: (optional) object: An authenticated TokenDetails object.\r\n   *\r\n   * - token:        (optional) string: the `token` property of a tokenDetails object\r\n   *\r\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\r\n   *                  authCallback should be a function of (tokenParams, callback) that calls\r\n   *                  the callback with (err, result), where result is any of:\r\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\r\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\r\n   *                  - a token string\r\n   *\r\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\r\n   *                  params, to obtain a signed token request.\r\n   *\r\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\r\n   *                  made to the authUrl.\r\n   *\r\n   * - authParams:    (optional) a set of application-specific query params to be added to any\r\n   *                  request made to the authUrl.\r\n   *\r\n   *\r\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\r\n   *                  requestToken request\r\n   */\r\n  async authorize(tokenParams: API.TokenParams | null, authOptions: AuthOptions | null): Promise<API.TokenDetails>;\r\n\r\n  async authorize(\r\n    tokenParams?: Record<string, any> | null,\r\n    authOptions?: AuthOptions | null,\r\n  ): Promise<API.TokenDetails> {\r\n    /* RSA10a: authorize() call implies token auth. If a key is passed it, we\r\n     * just check if it doesn't clash and assume we're generating a token from it */\r\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\r\n      throw new ErrorInfo('Unable to update auth options with incompatible key', 40102, 401);\r\n    }\r\n\r\n    try {\r\n      let tokenDetails = await this._forceNewToken(tokenParams ?? null, authOptions ?? null);\r\n\r\n      /* RTC8\r\n       * - When authorize called by an end user and have a realtime connection,\r\n       * don't call back till new token has taken effect.\r\n       * - Use this.client.connection as a proxy for (this.client instanceof BaseRealtime),\r\n       * which doesn't work in node as BaseRealtime isn't part of the vm context for Rest clients */\r\n      if (isRealtime(this.client)) {\r\n        return new Promise((resolve, reject) => {\r\n          (this.client as BaseRealtime).connection.connectionManager.onAuthUpdated(\r\n            tokenDetails,\r\n            (err: unknown, tokenDetails?: API.TokenDetails) => (err ? reject(err) : resolve(tokenDetails!)),\r\n          );\r\n        });\r\n      } else {\r\n        return tokenDetails;\r\n      }\r\n    } catch (err) {\r\n      if ((this.client as BaseRealtime).connection && (err as ErrorInfo).statusCode === HttpStatusCodes.Forbidden) {\r\n        /* Per RSA4d & RSA4d1, if the auth server explicitly repudiates our right to\r\n         * stay connecticed by returning a 403, we actively disconnect the connection\r\n         * even though we may well still have time left in the old token. */\r\n        (this.client as BaseRealtime).connection.connectionManager.actOnErrorFromAuthorize(err as ErrorInfo);\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  /* For internal use, eg by connectionManager - useful when want to call back\r\n   * as soon as we have the new token, rather than waiting for it to take\r\n   * effect on the connection as #authorize does */\r\n  async _forceNewToken(\r\n    tokenParams: API.TokenParams | null,\r\n    authOptions: AuthOptions | null,\r\n  ): Promise<API.TokenDetails> {\r\n    /* get rid of current token even if still valid */\r\n    this.tokenDetails = null;\r\n\r\n    /* _save normalises the tokenParams and authOptions and updates the auth\r\n     * object. All subsequent operations should use the values on `this`,\r\n     * not the passed in ones. */\r\n    this._saveTokenOptions(tokenParams, authOptions);\r\n\r\n    logAndValidateTokenAuthMethod(this.authOptions, this.logger);\r\n\r\n    try {\r\n      return this._ensureValidAuthCredentials(true);\r\n    } finally {\r\n      /* RSA10g */\r\n      delete this.tokenParams.timestamp;\r\n      delete this.authOptions.queryTime;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Request an access token\r\n   */\r\n  async requestToken(): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Request an access token\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\r\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\r\n   *                  exceeding that lifetime will be rejected with an error.\r\n   *\r\n   * - capability:    (optional) the capability to associate with the access token.\r\n   *                  If none is specified, a token will be requested with all of the\r\n   *                  capabilities of the specified key.\r\n   *\r\n   * - clientId:      (optional) a client ID to associate with the token; if not\r\n   *                  specified, a clientId passed in constructing the Rest interface will be used\r\n   *\r\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\r\n   *                  the system will be queried for a time value to use.\r\n   */\r\n  async requestToken(tokenParams: API.TokenParams | null): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Request an access token\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\r\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\r\n   *                  exceeding that lifetime will be rejected with an error.\r\n   *\r\n   * - capability:    (optional) the capability to associate with the access token.\r\n   *                  If none is specified, a token will be requested with all of the\r\n   *                  capabilities of the specified key.\r\n   *\r\n   * - clientId:      (optional) a client ID to associate with the token; if not\r\n   *                  specified, a clientId passed in constructing the Rest interface will be used\r\n   *\r\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\r\n   *                  the system will be queried for a time value to use.\r\n   *\r\n   * @param authOptions\r\n   * an object containing the request options:\r\n   * - key:           the key to use.\r\n   *\r\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\r\n   *                  authCallback should be a function of (tokenParams, callback) that calls\r\n   *                  the callback with (err, result), where result is any of:\r\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\r\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\r\n   *                  - a token string\r\n   *\r\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\r\n   *                  params, to obtain a signed token request.\r\n   *\r\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\r\n   *                  made to the authUrl.\r\n   *\r\n   * - authParams:    (optional) a set of application-specific query params to be added to any\r\n   *                  request made to the authUrl.\r\n   *\r\n   * - queryTime      (optional) boolean indicating that the ably system should be\r\n   *                  queried for the current time when none is specified explicitly\r\n   *\r\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\r\n   *                  requestToken request\r\n   */\r\n  async requestToken(tokenParams: API.TokenParams | null, authOptions: AuthOptions): Promise<API.TokenDetails>;\r\n\r\n  async requestToken(tokenParams?: API.TokenParams | null, authOptions?: AuthOptions): Promise<API.TokenDetails> {\r\n    /* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */\r\n    const resolvedAuthOptions = authOptions || this.authOptions;\r\n    const resolvedTokenParams = tokenParams || Utils.copy(this.tokenParams);\r\n\r\n    /* first set up whatever callback will be used to get signed\r\n     * token requests */\r\n    let tokenRequestCallback: (\r\n        data: API.TokenParams,\r\n        callback: (\r\n          error: API.ErrorInfo | RequestResultError | string | null,\r\n          tokenRequestOrDetails: API.TokenDetails | API.TokenRequest | string | null,\r\n          contentType?: string,\r\n        ) => void,\r\n      ) => void,\r\n      client = this.client;\r\n\r\n    if (resolvedAuthOptions.authCallback) {\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');\r\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\r\n    } else if (resolvedAuthOptions.authUrl) {\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');\r\n      tokenRequestCallback = (params, cb) => {\r\n        const authHeaders = Utils.mixin(\r\n          { accept: 'application/json, text/plain' },\r\n          resolvedAuthOptions.authHeaders,\r\n        ) as Record<string, string>;\r\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === 'post';\r\n        let providedQsParams;\r\n        /* Combine authParams with any qs params given in the authUrl */\r\n        const queryIdx = resolvedAuthOptions.authUrl!.indexOf('?');\r\n        if (queryIdx > -1) {\r\n          providedQsParams = Utils.parseQueryString(resolvedAuthOptions.authUrl!.slice(queryIdx));\r\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl!.slice(0, queryIdx);\r\n          if (!usePost) {\r\n            /* In case of conflict, authParams take precedence over qs params in the authUrl */\r\n            resolvedAuthOptions.authParams = Utils.mixin(\r\n              providedQsParams,\r\n              resolvedAuthOptions.authParams,\r\n            ) as typeof resolvedAuthOptions.authParams;\r\n          }\r\n        }\r\n        /* RSA8c2 */\r\n        const authParams = Utils.mixin({}, resolvedAuthOptions.authParams || {}, params) as RequestParams;\r\n        const authUrlRequestCallback = (result: RequestResult) => {\r\n          let body = (result.body ?? null) as string | Bufferlike | API.TokenDetails | API.TokenRequest | null;\r\n\r\n          let contentType: string | null = null;\r\n          if (result.error) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MICRO,\r\n              'Auth.requestToken().tokenRequestCallback',\r\n              'Received Error: ' + Utils.inspectError(result.error),\r\n            );\r\n          } else {\r\n            const contentTypeHeaderOrHeaders = result.headers!['content-type'] ?? null;\r\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\r\n              // Combine multiple header values into a comma-separated list per https://datatracker.ietf.org/doc/html/rfc9110#section-5.2; see https://github.com/ably/ably-js/issues/1616 for doing this consistently across the codebase.\r\n              contentType = contentTypeHeaderOrHeaders.join(', ');\r\n            } else {\r\n              contentType = contentTypeHeaderOrHeaders;\r\n            }\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MICRO,\r\n              'Auth.requestToken().tokenRequestCallback',\r\n              'Received; content-type: ' + contentType + '; body: ' + Utils.inspectBody(body),\r\n            );\r\n          }\r\n          if (result.error) {\r\n            cb(result.error, null);\r\n            return;\r\n          }\r\n          if (result.unpacked) {\r\n            cb(null, body as Exclude<typeof body, Bufferlike>);\r\n            return;\r\n          }\r\n          if (Platform.BufferUtils.isBuffer(body)) body = body.toString();\r\n          if (!contentType) {\r\n            cb(new ErrorInfo('authUrl response is missing a content-type header', 40170, 401), null);\r\n            return;\r\n          }\r\n          const json = contentType.indexOf('application/json') > -1,\r\n            text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;\r\n          if (!json && !text) {\r\n            cb(\r\n              new ErrorInfo(\r\n                'authUrl responded with unacceptable content-type ' +\r\n                  contentType +\r\n                  ', should be either text/plain, application/jwt or application/json',\r\n                40170,\r\n                401,\r\n              ),\r\n              null,\r\n            );\r\n            return;\r\n          }\r\n          if (json) {\r\n            if ((body as string).length > MAX_TOKEN_LENGTH) {\r\n              cb(new ErrorInfo('authUrl response exceeded max permitted length', 40170, 401), null);\r\n              return;\r\n            }\r\n            try {\r\n              body = JSON.parse(body as string);\r\n            } catch (e) {\r\n              cb(\r\n                new ErrorInfo(\r\n                  'Unexpected error processing authURL response; err = ' + (e as Error).message,\r\n                  40170,\r\n                  401,\r\n                ),\r\n                null,\r\n              );\r\n              return;\r\n            }\r\n          }\r\n          cb(null, body as Exclude<typeof body, Bufferlike>, contentType);\r\n        };\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          'Auth.requestToken().tokenRequestCallback',\r\n          'Requesting token from ' +\r\n            resolvedAuthOptions.authUrl +\r\n            '; Params: ' +\r\n            JSON.stringify(authParams) +\r\n            '; method: ' +\r\n            (usePost ? 'POST' : 'GET'),\r\n        );\r\n        if (usePost) {\r\n          /* send body form-encoded */\r\n          const headers = authHeaders || {};\r\n          headers['content-type'] = 'application/x-www-form-urlencoded';\r\n          const body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */\r\n          Utils.whenPromiseSettles(\r\n            this.client.http.doUri(\r\n              HttpMethods.Post,\r\n              resolvedAuthOptions.authUrl!,\r\n              headers,\r\n              body,\r\n              providedQsParams as Record<string, string>,\r\n            ),\r\n            (err: any, result) =>\r\n              err\r\n                ? authUrlRequestCallback(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\r\n                : authUrlRequestCallback(result!),\r\n          );\r\n        } else {\r\n          Utils.whenPromiseSettles(\r\n            this.client.http.doUri(HttpMethods.Get, resolvedAuthOptions.authUrl!, authHeaders || {}, null, authParams),\r\n            (err: any, result) =>\r\n              err\r\n                ? authUrlRequestCallback(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\r\n                : authUrlRequestCallback(result!),\r\n          );\r\n        }\r\n      };\r\n    } else if (resolvedAuthOptions.key) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'Auth.requestToken()',\r\n        'using token auth with client-side signing',\r\n      );\r\n      tokenRequestCallback = (params, cb) => {\r\n        Utils.whenPromiseSettles(this.createTokenRequest(params, resolvedAuthOptions), (err, result) =>\r\n          cb(err as string | ErrorInfo | null, result ?? null),\r\n        );\r\n      };\r\n    } else {\r\n      const msg =\r\n        'Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)';\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'Auth()',\r\n        'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help',\r\n      );\r\n      throw new ErrorInfo(msg, 40171, 403);\r\n    }\r\n\r\n    /* normalise token params */\r\n    if ('capability' in (resolvedTokenParams as Record<string, any>))\r\n      (resolvedTokenParams as Record<string, any>).capability = c14n(\r\n        (resolvedTokenParams as Record<string, any>).capability,\r\n      );\r\n\r\n    const tokenRequest = (\r\n      signedTokenParams: Record<string, any>,\r\n      tokenCb: (err: RequestResultError | null, tokenResponse?: API.TokenDetails | string, unpacked?: boolean) => void,\r\n    ) => {\r\n      const keyName = signedTokenParams.keyName,\r\n        path = '/keys/' + keyName + '/requestToken',\r\n        tokenUri = function (host: string) {\r\n          return client.baseUri(host) + path;\r\n        };\r\n\r\n      const requestHeaders = Defaults.defaultPostHeaders(this.client.options);\r\n      if (resolvedAuthOptions.requestHeaders) Utils.mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'Auth.requestToken().requestToken',\r\n        'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams),\r\n      );\r\n      Utils.whenPromiseSettles(\r\n        this.client.http.do(HttpMethods.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\r\n        (err: any, result) =>\r\n          err\r\n            ? tokenCb(err) // doUri isn\u2019t meant to throw an error, but handle any just in case\r\n            : tokenCb(result!.error, result!.body as API.TokenDetails | string | undefined, result!.unpacked),\r\n      );\r\n    };\r\n\r\n    return new Promise((resolve, reject) => {\r\n      let tokenRequestCallbackTimeoutExpired = false,\r\n        timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,\r\n        tokenRequestCallbackTimeout = setTimeout(() => {\r\n          tokenRequestCallbackTimeoutExpired = true;\r\n          const msg = 'Token request callback timed out after ' + timeoutLength / 1000 + ' seconds';\r\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth.requestToken()', msg);\r\n          reject(new ErrorInfo(msg, 40170, 401));\r\n        }, timeoutLength);\r\n\r\n      tokenRequestCallback!(resolvedTokenParams, (err, tokenRequestOrDetails, contentType) => {\r\n        if (tokenRequestCallbackTimeoutExpired) return;\r\n        clearTimeout(tokenRequestCallbackTimeout);\r\n\r\n        if (err) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_ERROR,\r\n            'Auth.requestToken()',\r\n            'token request signing call returned error; err = ' + Utils.inspectError(err),\r\n          );\r\n          reject(normaliseAuthcallbackError(err));\r\n          return;\r\n        }\r\n        /* the response from the callback might be a token string, a signed request or a token details */\r\n        if (typeof tokenRequestOrDetails === 'string') {\r\n          if (tokenRequestOrDetails.length === 0) {\r\n            reject(new ErrorInfo('Token string is empty', 40170, 401));\r\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\r\n            reject(\r\n              new ErrorInfo(\r\n                'Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)',\r\n                40170,\r\n                401,\r\n              ),\r\n            );\r\n          } else if (tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {\r\n            /* common failure mode with poorly-implemented authCallbacks */\r\n            reject(new ErrorInfo('Token string was literal null/undefined', 40170, 401));\r\n          } else if (\r\n            tokenRequestOrDetails[0] === '{' &&\r\n            !(contentType && contentType.indexOf('application/jwt') > -1)\r\n          ) {\r\n            reject(\r\n              new ErrorInfo(\r\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\r\n                40170,\r\n                401,\r\n              ),\r\n            );\r\n          } else {\r\n            resolve({ token: tokenRequestOrDetails } as API.TokenDetails);\r\n          }\r\n          return;\r\n        }\r\n        if (typeof tokenRequestOrDetails !== 'object' || tokenRequestOrDetails === null) {\r\n          const msg =\r\n            'Expected token request callback to call back with a token string or token request/details object, but got a ' +\r\n            typeof tokenRequestOrDetails;\r\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth.requestToken()', msg);\r\n          reject(new ErrorInfo(msg, 40170, 401));\r\n          return;\r\n        }\r\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\r\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\r\n          reject(\r\n            new ErrorInfo(\r\n              'Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)',\r\n              40170,\r\n              401,\r\n            ),\r\n          );\r\n          return;\r\n        }\r\n        if ('issued' in tokenRequestOrDetails) {\r\n          /* a tokenDetails object */\r\n          resolve(tokenRequestOrDetails);\r\n          return;\r\n        }\r\n        if (!('keyName' in tokenRequestOrDetails)) {\r\n          const msg =\r\n            'Expected token request callback to call back with a token string, token request object, or token details object';\r\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth.requestToken()', msg);\r\n          reject(new ErrorInfo(msg, 40170, 401));\r\n          return;\r\n        }\r\n        /* it's a token request, so make the request */\r\n        tokenRequest(tokenRequestOrDetails, (err, tokenResponse, unpacked) => {\r\n          if (err) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_ERROR,\r\n              'Auth.requestToken()',\r\n              'token request API call returned error; err = ' + Utils.inspectError(err),\r\n            );\r\n            reject(normaliseAuthcallbackError(err));\r\n            return;\r\n          }\r\n          if (!unpacked) tokenResponse = JSON.parse(tokenResponse as string);\r\n          Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.getToken()', 'token received');\r\n          resolve(tokenResponse as API.TokenDetails);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create and sign a token request based on the given options.\r\n   * NOTE this can only be used when the key value is available locally.\r\n   * Otherwise, signed token requests must be obtained from the key\r\n   * owner (either using the token request callback or url).\r\n   *\r\n   * @param authOptions\r\n   * an object containing the request options:\r\n   * - key:           the key to use. If not specified, a key passed in constructing\r\n   *                  the Rest interface will be used\r\n   *\r\n   * - queryTime      (optional) boolean indicating that the ably system should be\r\n   *                  queried for the current time when none is specified explicitly\r\n   *\r\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\r\n   *                  requestToken request\r\n   *\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\r\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\r\n   *                  exceeding that lifetime will be rejected with an error.\r\n   *\r\n   * - capability:    (optional) the capability to associate with the access token.\r\n   *                  If none is specified, a token will be requested with all of the\r\n   *                  capabilities of the specified key.\r\n   *\r\n   * - clientId:      (optional) a client ID to associate with the token; if not\r\n   *                  specified, a clientId passed in constructing the Rest interface will be used\r\n   *\r\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\r\n   *                  the system will be queried for a time value to use.\r\n   */\r\n  async createTokenRequest(tokenParams: API.TokenParams | null, authOptions: any): Promise<API.TokenRequest> {\r\n    /* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */\r\n    authOptions = authOptions || this.authOptions;\r\n    tokenParams = tokenParams || Utils.copy<API.TokenParams>(this.tokenParams);\r\n\r\n    const key = authOptions.key;\r\n    if (!key) {\r\n      throw new ErrorInfo('No key specified', 40101, 403);\r\n    }\r\n    const keyParts = key.split(':'),\r\n      keyName = keyParts[0],\r\n      keySecret = keyParts[1];\r\n\r\n    if (!keySecret) {\r\n      throw new ErrorInfo('Invalid key specified', 40101, 403);\r\n    }\r\n\r\n    if (tokenParams.clientId === '') {\r\n      throw new ErrorInfo('clientId can\u2019t be an empty string', 40012, 400);\r\n    }\r\n\r\n    if ('capability' in tokenParams) {\r\n      tokenParams.capability = c14n(tokenParams.capability);\r\n    }\r\n\r\n    const request: Partial<API.TokenRequest> = Utils.mixin({ keyName: keyName }, tokenParams),\r\n      clientId = tokenParams.clientId || '',\r\n      ttl = tokenParams.ttl || '',\r\n      capability = tokenParams.capability || '';\r\n\r\n    if (!request.timestamp) {\r\n      request.timestamp = await this.getTimestamp(authOptions && authOptions.queryTime);\r\n    }\r\n\r\n    /* nonce */\r\n    /* NOTE: there is no expectation that the client\r\n     * specifies the nonce; this is done by the library\r\n     * However, this can be overridden by the client\r\n     * simply for testing purposes. */\r\n    const nonce = request.nonce || (request.nonce = random()),\r\n      timestamp = request.timestamp;\r\n\r\n    const signText =\r\n      request.keyName + '\\n' + ttl + '\\n' + capability + '\\n' + clientId + '\\n' + timestamp + '\\n' + nonce + '\\n';\r\n\r\n    /* mac */\r\n    /* NOTE: there is no expectation that the client\r\n     * specifies the mac; this is done by the library\r\n     * However, this can be overridden by the client\r\n     * simply for testing purposes. */\r\n    request.mac = request.mac || hmac(signText, keySecret);\r\n\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');\r\n\r\n    return request as API.TokenRequest;\r\n  }\r\n\r\n  /**\r\n   * Get the auth query params to use for a websocket connection,\r\n   * based on the current auth parameters\r\n   */\r\n  async getAuthParams(): Promise<Record<string, string>> {\r\n    if (this.method == 'basic') return { key: this.key! };\r\n    else {\r\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\r\n      if (!tokenDetails) {\r\n        throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\r\n      }\r\n      return { access_token: tokenDetails.token };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the authorization header to use for a REST or comet request,\r\n   * based on the current auth parameters\r\n   */\r\n  async getAuthHeaders(): Promise<Record<string, string>> {\r\n    if (this.method == 'basic') {\r\n      return { authorization: 'Basic ' + this.basicKey };\r\n    } else {\r\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\r\n      if (!tokenDetails) {\r\n        throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\r\n      }\r\n      return { authorization: 'Bearer ' + Utils.toBase64(tokenDetails.token) };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the current time based on the local clock,\r\n   * or if the option queryTime is true, return the server time.\r\n   * The server time offset from the local time is stored so that\r\n   * only one request to the server to get the time is ever needed\r\n   */\r\n  async getTimestamp(queryTime: boolean): Promise<number> {\r\n    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\r\n      return this.client.time();\r\n    } else {\r\n      return this.getTimestampUsingOffset();\r\n    }\r\n  }\r\n\r\n  getTimestampUsingOffset() {\r\n    return Date.now() + (this.client.serverTimeOffset || 0);\r\n  }\r\n\r\n  isTimeOffsetSet() {\r\n    return this.client.serverTimeOffset !== null;\r\n  }\r\n\r\n  _saveBasicOptions(authOptions: AuthOptions) {\r\n    this.method = 'basic';\r\n    this.key = authOptions.key;\r\n    this.basicKey = Utils.toBase64(authOptions.key as string);\r\n    this.authOptions = authOptions || {};\r\n    if ('clientId' in authOptions) {\r\n      this._userSetClientId(authOptions.clientId);\r\n    }\r\n  }\r\n\r\n  _saveTokenOptions(tokenParams: API.TokenParams | null, authOptions: AuthOptions | null) {\r\n    this.method = 'token';\r\n\r\n    if (tokenParams) {\r\n      /* We temporarily persist tokenParams.timestamp in case a new token needs\r\n       * to be requested, then null it out in the callback of\r\n       * _ensureValidAuthCredentials for RSA10g compliance */\r\n      this.tokenParams = tokenParams;\r\n    }\r\n\r\n    if (authOptions) {\r\n      /* normalise */\r\n      if (authOptions.token) {\r\n        /* options.token may contain a token string or, for convenience, a TokenDetails */\r\n        authOptions.tokenDetails =\r\n          typeof authOptions.token === 'string'\r\n            ? ({ token: authOptions.token } as API.TokenDetails)\r\n            : authOptions.token;\r\n      }\r\n\r\n      if (authOptions.tokenDetails) {\r\n        this.tokenDetails = authOptions.tokenDetails;\r\n      }\r\n\r\n      if ('clientId' in authOptions) {\r\n        this._userSetClientId(authOptions.clientId);\r\n      }\r\n\r\n      this.authOptions = authOptions;\r\n    }\r\n  }\r\n\r\n  /* @param forceSupersede: force a new token request even if there's one in\r\n   * progress, making all pending callbacks wait for the new one */\r\n  async _ensureValidAuthCredentials(forceSupersede: boolean): Promise<API.TokenDetails> {\r\n    const token = this.tokenDetails;\r\n\r\n    if (token) {\r\n      if (this._tokenClientIdMismatch(token.clientId)) {\r\n        /* 403 to trigger a permanently failed client - RSA15c */\r\n        throw new ErrorInfo(\r\n          'Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')',\r\n          40102,\r\n          403,\r\n        );\r\n      }\r\n      /* RSA4b1 -- if we have a server time offset set already, we can\r\n       * automatically remove expired tokens. Else just use the cached token. If it is\r\n       * expired Ably will tell us and we'll discard it then. */\r\n      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'Auth.getToken()',\r\n          'using cached token; expires = ' + token.expires,\r\n        );\r\n        return token;\r\n      }\r\n      /* expired, so remove and fallthrough to getting a new one */\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');\r\n      this.tokenDetails = null;\r\n    }\r\n\r\n    const promise = (\r\n      this.waitingForTokenRequest || (this.waitingForTokenRequest = Multicaster.create(this.logger))\r\n    ).createPromise();\r\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\r\n      return promise;\r\n    }\r\n\r\n    /* Request a new token */\r\n    const tokenRequestId = (this.currentTokenRequestId = getTokenRequestId());\r\n\r\n    let tokenResponse: API.TokenDetails,\r\n      caughtError: ErrorInfo | null = null;\r\n    try {\r\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\r\n    } catch (err) {\r\n      caughtError = err as ErrorInfo;\r\n    }\r\n\r\n    if ((this.currentTokenRequestId as number) > tokenRequestId) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'Auth._ensureValidAuthCredentials()',\r\n        'Discarding token request response; overtaken by newer one',\r\n      );\r\n      return promise;\r\n    }\r\n\r\n    this.currentTokenRequestId = null;\r\n    const multicaster = this.waitingForTokenRequest;\r\n    this.waitingForTokenRequest = null;\r\n    if (caughtError) {\r\n      multicaster?.rejectAll(caughtError);\r\n      return promise;\r\n    }\r\n    multicaster?.resolveAll((this.tokenDetails = tokenResponse!));\r\n\r\n    return promise;\r\n  }\r\n\r\n  /* User-set: check types, '*' is disallowed, throw any errors */\r\n  _userSetClientId(clientId: string | undefined) {\r\n    if (!(typeof clientId === 'string' || clientId === null)) {\r\n      throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\r\n    } else if (clientId === '*') {\r\n      throw new ErrorInfo(\r\n        'Can\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\r\n        40012,\r\n        400,\r\n      );\r\n    } else {\r\n      const err = this._uncheckedSetClientId(clientId);\r\n      if (err) throw err;\r\n    }\r\n  }\r\n\r\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\r\n  _uncheckedSetClientId(clientId: string | undefined) {\r\n    if (this._tokenClientIdMismatch(clientId)) {\r\n      /* Should never happen in normal circumstances as realtime should\r\n       * recognise mismatch and return an error */\r\n      const msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;\r\n      const err = new ErrorInfo(msg, 40102, 401);\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);\r\n      return err;\r\n    } else {\r\n      /* RSA7a4: if options.clientId is provided and is not\r\n       * null, it overrides defaultTokenParams.clientId */\r\n      this.clientId = this.tokenParams.clientId = clientId;\r\n      return null;\r\n    }\r\n  }\r\n\r\n  _tokenClientIdMismatch(tokenClientId?: string | null): boolean {\r\n    return !!(\r\n      this.clientId &&\r\n      this.clientId !== '*' &&\r\n      tokenClientId &&\r\n      tokenClientId !== '*' &&\r\n      this.clientId !== tokenClientId\r\n    );\r\n  }\r\n\r\n  static isTokenErr(error: IPartialErrorInfo) {\r\n    return error.code && error.code >= 40140 && error.code < 40150;\r\n  }\r\n\r\n  revokeTokens(\r\n    specifiers: TokenRevocationTargetSpecifier[],\r\n    options?: TokenRevocationOptions,\r\n  ): Promise<TokenRevocationResult> {\r\n    return this.client.rest.revokeTokens(specifiers, options);\r\n  }\r\n}\r\n\r\nexport default Auth;\r\n", "import Defaults from 'common/lib/util/defaults';\r\nimport Platform from 'common/platform';\r\nimport BaseRealtime from 'common/lib/client/baserealtime';\r\nimport HttpMethods from '../constants/HttpMethods';\r\nimport BaseClient from '../lib/client/baseclient';\r\nimport ErrorInfo, { IPartialErrorInfo } from '../lib/types/errorinfo';\r\nimport Logger from 'common/lib/util/logger';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\nexport type PathParameter = string | ((host: string) => string);\r\nexport type ResponseHeaders = Partial<Record<string, string | string[]>>;\r\nexport type RequestResultError = ErrnoException | IPartialErrorInfo;\r\n\r\n/**\r\n * The `body`, `headers`, `unpacked`, and `statusCode` properties of a `RequestResult` may be populated even if its `error` property is non-null.\r\n */\r\nexport type RequestResult = {\r\n  error: RequestResultError | null;\r\n  body?: unknown;\r\n  headers?: ResponseHeaders;\r\n  unpacked?: boolean;\r\n  statusCode?: number;\r\n};\r\n\r\nexport type RequestParams = Record<string, string> | null;\r\nexport type RequestBody =\r\n  | Buffer // only on Node\r\n  | ArrayBuffer // only on web\r\n  | string;\r\n\r\nexport interface IPlatformHttpStatic {\r\n  new (client?: BaseClient): IPlatformHttp;\r\n  methods: Array<HttpMethods>;\r\n  methodsWithBody: Array<HttpMethods>;\r\n  methodsWithoutBody: Array<HttpMethods>;\r\n}\r\n\r\nexport interface IPlatformHttp {\r\n  supportsAuthHeaders: boolean;\r\n  supportsLinkHeaders: boolean;\r\n\r\n  /**\r\n   * This method should not throw any errors; rather, it should communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult>;\r\n\r\n  checkConnectivity?: () => Promise<boolean>;\r\n\r\n  /**\r\n   * @param error An error from the {@link RequestResult.error} property of a result returned by {@link doUri}.\r\n   */\r\n  shouldFallback(error: RequestResultError): boolean;\r\n}\r\n\r\nexport function paramString(params: Record<string, any> | null) {\r\n  const paramPairs = [];\r\n  if (params) {\r\n    for (const needle in params) {\r\n      paramPairs.push(needle + '=' + params[needle]);\r\n    }\r\n  }\r\n  return paramPairs.join('&');\r\n}\r\n\r\nexport function appendingParams(uri: string, params: Record<string, any> | null) {\r\n  return uri + (params ? '?' : '') + paramString(params);\r\n}\r\n\r\nfunction logResult(\r\n  result: RequestResult,\r\n  method: HttpMethods,\r\n  uri: string,\r\n  params: Record<string, string> | null,\r\n  logger: Logger,\r\n) {\r\n  if (result.error) {\r\n    Logger.logActionNoStrip(\r\n      logger,\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Received Error; ' + appendingParams(uri, params) + '; Error: ' + Utils.inspectError(result.error),\r\n    );\r\n  } else {\r\n    Logger.logActionNoStrip(\r\n      logger,\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Received; ' +\r\n        appendingParams(uri, params) +\r\n        '; Headers: ' +\r\n        paramString(result.headers as Record<string, any>) +\r\n        '; StatusCode: ' +\r\n        result.statusCode +\r\n        '; Body' +\r\n        (Platform.BufferUtils.isBuffer(result.body)\r\n          ? ' (Base64): ' + Platform.BufferUtils.base64Encode(result.body)\r\n          : ': ' + result.body),\r\n    );\r\n  }\r\n}\r\n\r\nfunction logRequest(method: HttpMethods, uri: string, body: RequestBody | null, params: RequestParams, logger: Logger) {\r\n  if (logger.shouldLog(Logger.LOG_MICRO)) {\r\n    Logger.logActionNoStrip(\r\n      logger,\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Sending; ' +\r\n        appendingParams(uri, params) +\r\n        '; Body' +\r\n        (Platform.BufferUtils.isBuffer(body) ? ' (Base64): ' + Platform.BufferUtils.base64Encode(body) : ': ' + body),\r\n    );\r\n  }\r\n}\r\n\r\nexport class Http {\r\n  private readonly platformHttp: IPlatformHttp;\r\n  checkConnectivity?: () => Promise<boolean>;\r\n\r\n  constructor(private readonly client?: BaseClient) {\r\n    this.platformHttp = new Platform.Http(client);\r\n\r\n    this.checkConnectivity = this.platformHttp.checkConnectivity\r\n      ? () => this.platformHttp.checkConnectivity!()\r\n      : undefined;\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.client?.logger ?? Logger.defaultLogger;\r\n  }\r\n\r\n  get supportsAuthHeaders() {\r\n    return this.platformHttp.supportsAuthHeaders;\r\n  }\r\n\r\n  get supportsLinkHeaders() {\r\n    return this.platformHttp.supportsLinkHeaders;\r\n  }\r\n\r\n  _getHosts(client: BaseClient) {\r\n    /* If we're a connected realtime client, try the endpoint we're connected\r\n     * to first -- but still have fallbacks, being connected is not an absolute\r\n     * guarantee that a datacenter has free capacity to service REST requests. */\r\n    const connection = (client as BaseRealtime).connection,\r\n      connectionHost = connection && connection.connectionManager.host;\r\n\r\n    if (connectionHost) {\r\n      return [connectionHost].concat(Defaults.getFallbackHosts(client.options));\r\n    }\r\n\r\n    return Defaults.getHosts(client.options);\r\n  }\r\n\r\n  /**\r\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  async do(\r\n    method: HttpMethods,\r\n    path: PathParameter,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    try {\r\n      /* Unlike for doUri, the presence of `this.client` here is mandatory, as it's used to generate the hosts */\r\n      const client = this.client;\r\n      if (!client) {\r\n        return { error: new ErrorInfo('http.do called without client', 50000, 500) };\r\n      }\r\n\r\n      const uriFromHost =\r\n        typeof path === 'function'\r\n          ? path\r\n          : function (host: string) {\r\n              return client.baseUri(host) + path;\r\n            };\r\n\r\n      const currentFallback = client._currentFallback;\r\n      if (currentFallback) {\r\n        if (currentFallback.validUntil > Date.now()) {\r\n          /* Use stored fallback */\r\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\r\n          if (result.error && this.platformHttp.shouldFallback(result.error as ErrnoException)) {\r\n            /* unstore the fallback and start from the top with the default sequence */\r\n            client._currentFallback = null;\r\n            return this.do(method, path, headers, body, params);\r\n          }\r\n          return result;\r\n        } else {\r\n          /* Fallback expired; remove it and fallthrough to normal sequence */\r\n          client._currentFallback = null;\r\n        }\r\n      }\r\n\r\n      const hosts = this._getHosts(client);\r\n\r\n      /* see if we have one or more than one host */\r\n      if (hosts.length === 1) {\r\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\r\n      }\r\n\r\n      let tryAHostStartedAt: Date | null = null;\r\n      const tryAHost = async (candidateHosts: Array<string>, persistOnSuccess?: boolean): Promise<RequestResult> => {\r\n        const host = candidateHosts.shift();\r\n        tryAHostStartedAt = tryAHostStartedAt ?? new Date();\r\n        const result = await this.doUri(method, uriFromHost(host as string), headers, body, params);\r\n        if (result.error && this.platformHttp.shouldFallback(result.error as ErrnoException) && candidateHosts.length) {\r\n          // TO3l6\r\n          const elapsedTime = Date.now() - tryAHostStartedAt.getTime();\r\n          if (elapsedTime > client.options.timeouts.httpMaxRetryDuration) {\r\n            return {\r\n              error: new ErrorInfo(\r\n                `Timeout for trying fallback hosts retries. Total elapsed time exceeded the ${client.options.timeouts.httpMaxRetryDuration}ms limit`,\r\n                50003,\r\n                500,\r\n              ),\r\n            };\r\n          }\r\n\r\n          return tryAHost(candidateHosts, true);\r\n        }\r\n        if (persistOnSuccess) {\r\n          /* RSC15f */\r\n          client._currentFallback = {\r\n            host: host as string,\r\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout,\r\n          };\r\n        }\r\n        return result;\r\n      };\r\n      return tryAHost(hosts);\r\n    } catch (err) {\r\n      // Handle any unexpected error, to ensure we always meet our contract of not throwing any errors\r\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${Utils.inspectError(err)}`, 500, 50000) };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  async doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    try {\r\n      logRequest(method, uri, body, params, this.logger);\r\n\r\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\r\n\r\n      if (this.logger.shouldLog(Logger.LOG_MICRO)) {\r\n        logResult(result, method, uri, params, this.logger);\r\n      }\r\n\r\n      return result;\r\n    } catch (err) {\r\n      // Handle any unexpected error, to ensure we always meet our contract of not throwing any errors\r\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${Utils.inspectError(err)}`, 500, 50000) };\r\n    }\r\n  }\r\n}\r\n\r\nexport interface ErrnoException extends Error {\r\n  errno?: number;\r\n  code?: string;\r\n  path?: string;\r\n  syscall?: string;\r\n  stack?: string;\r\n  statusCode: number;\r\n}\r\n", "import Logger, { LoggerOptions } from '../util/logger';\r\nimport Defaults from '../util/defaults';\r\nimport Auth from './auth';\r\nimport { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Stats from '../types/stats';\r\nimport { Http, RequestParams } from '../../types/http';\r\nimport ClientOptions, { NormalisedClientOptions } from '../../types/ClientOptions';\r\nimport * as API from '../../../../ably';\r\n\r\nimport Platform from '../../platform';\r\nimport { Rest } from './rest';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { throwMissingPluginError } from '../util/utils';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { HTTPRequestImplementations } from 'platform/web/lib/http/http';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\ntype BatchPublishSpec = API.BatchPublishSpec;\r\ntype BatchPublishSuccessResult = API.BatchPublishSuccessResult;\r\ntype BatchPublishFailureResult = API.BatchPublishFailureResult;\r\ntype BatchPublishResult = BatchResult<BatchPublishSuccessResult | BatchPublishFailureResult>;\r\ntype BatchPresenceSuccessResult = API.BatchPresenceSuccessResult;\r\ntype BatchPresenceFailureResult = API.BatchPresenceFailureResult;\r\ntype BatchPresenceResult = BatchResult<BatchPresenceSuccessResult | BatchPresenceFailureResult>;\r\n\r\n/**\r\n `BaseClient` acts as the base class for all of the client classes exported by the SDK. It is an implementation detail and this class is not advertised publicly.\r\n */\r\nclass BaseClient {\r\n  options: NormalisedClientOptions;\r\n  _currentFallback: null | {\r\n    host: string;\r\n    validUntil: number;\r\n  };\r\n  serverTimeOffset: number | null;\r\n  http: Http;\r\n  auth: Auth;\r\n\r\n  private readonly _rest: Rest | null;\r\n  readonly _Crypto: IUntypedCryptoStatic | null;\r\n  readonly _MsgPack: MsgPack | null;\r\n  // Extra HTTP request implementations available to this client, in addition to those in web\u2019s Http.bundledRequestImplementations\r\n  readonly _additionalHTTPRequestImplementations: HTTPRequestImplementations | null;\r\n  private readonly __FilteredSubscriptions: typeof FilteredSubscriptions | null;\r\n  readonly logger: Logger;\r\n\r\n  constructor(options: ClientOptions) {\r\n    this._additionalHTTPRequestImplementations = options.plugins ?? null;\r\n\r\n    this.logger = new Logger();\r\n    this.logger.setLog(options.logLevel, options.logHandler);\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'BaseClient()',\r\n      'initialized with clientOptions ' + Platform.Config.inspect(options),\r\n    );\r\n\r\n    this._MsgPack = options.plugins?.MsgPack ?? null;\r\n    const normalOptions = (this.options = Defaults.normaliseOptions(options, this._MsgPack, this.logger));\r\n\r\n    /* process options */\r\n    if (normalOptions.key) {\r\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\r\n      if (!keyMatch) {\r\n        const msg = 'invalid key parameter';\r\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'BaseClient()', msg);\r\n        throw new ErrorInfo(msg, 40400, 404);\r\n      }\r\n      normalOptions.keyName = keyMatch[1];\r\n      normalOptions.keySecret = keyMatch[2];\r\n    }\r\n\r\n    if ('clientId' in normalOptions) {\r\n      if (!(typeof normalOptions.clientId === 'string' || normalOptions.clientId === null))\r\n        throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\r\n      else if (normalOptions.clientId === '*')\r\n        throw new ErrorInfo(\r\n          'Can\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\r\n          40012,\r\n          400,\r\n        );\r\n    }\r\n\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'BaseClient()', 'started; version = ' + Defaults.version);\r\n\r\n    this._currentFallback = null;\r\n\r\n    this.serverTimeOffset = null;\r\n    this.http = new Http(this);\r\n    this.auth = new Auth(this, normalOptions);\r\n\r\n    this._rest = options.plugins?.Rest ? new options.plugins.Rest(this) : null;\r\n    this._Crypto = options.plugins?.Crypto ?? null;\r\n    this.__FilteredSubscriptions = options.plugins?.MessageInteractions ?? null;\r\n  }\r\n\r\n  get rest(): Rest {\r\n    if (!this._rest) {\r\n      throwMissingPluginError('Rest');\r\n    }\r\n    return this._rest;\r\n  }\r\n\r\n  get _FilteredSubscriptions(): typeof FilteredSubscriptions {\r\n    if (!this.__FilteredSubscriptions) {\r\n      throwMissingPluginError('MessageInteractions');\r\n    }\r\n    return this.__FilteredSubscriptions;\r\n  }\r\n\r\n  get channels() {\r\n    return this.rest.channels;\r\n  }\r\n\r\n  get push() {\r\n    return this.rest.push;\r\n  }\r\n\r\n  baseUri(host: string) {\r\n    return Defaults.getHttpScheme(this.options) + host + ':' + Defaults.getPort(this.options, false);\r\n  }\r\n\r\n  async stats(params: RequestParams): Promise<PaginatedResult<Stats>> {\r\n    return this.rest.stats(params);\r\n  }\r\n\r\n  async time(params?: RequestParams): Promise<number> {\r\n    return this.rest.time(params);\r\n  }\r\n\r\n  async request(\r\n    method: string,\r\n    path: string,\r\n    version: number,\r\n    params: RequestParams,\r\n    body: unknown,\r\n    customHeaders: Record<string, string>,\r\n  ): Promise<HttpPaginatedResponse<unknown>> {\r\n    return this.rest.request(method, path, version, params, body, customHeaders);\r\n  }\r\n\r\n  batchPublish<T extends BatchPublishSpec | BatchPublishSpec[]>(\r\n    specOrSpecs: T,\r\n  ): Promise<T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[]> {\r\n    return this.rest.batchPublish(specOrSpecs);\r\n  }\r\n\r\n  batchPresence(channels: string[]): Promise<BatchPresenceResult> {\r\n    return this.rest.batchPresence(channels);\r\n  }\r\n\r\n  setLog(logOptions: LoggerOptions): void {\r\n    this.logger.setLog(logOptions.level, logOptions.handler);\r\n  }\r\n\r\n  static Platform = Platform;\r\n}\r\n\r\nexport default BaseClient;\r\n", "import { MsgPack } from 'common/types/msgpack';\r\nimport * as Utils from '../util/utils';\r\nimport ErrorInfo, { IConvertibleToErrorInfo } from './errorinfo';\r\n\r\nenum DeviceFormFactor {\r\n  Phone = 'phone',\r\n  Tablet = 'tablet',\r\n  Desktop = 'desktop',\r\n  TV = 'tv',\r\n  Watch = 'watch',\r\n  Car = 'car',\r\n  Embedded = 'embedded',\r\n  Other = 'other',\r\n}\r\n\r\nenum DevicePlatform {\r\n  Android = 'android',\r\n  IOS = 'ios',\r\n  Browser = 'browser',\r\n}\r\n\r\ntype DevicePushState = 'ACTIVE' | 'FAILING' | 'FAILED';\r\n\r\ntype DevicePushDetails = {\r\n  error?: ErrorInfo;\r\n  recipient?: string;\r\n  state?: DevicePushState;\r\n  metadata?: string;\r\n};\r\n\r\nclass DeviceDetails {\r\n  id?: string;\r\n  clientId?: string;\r\n  deviceSecret?: string;\r\n  formFactor?: DeviceFormFactor;\r\n  platform?: DevicePlatform;\r\n  push?: DevicePushDetails;\r\n  metadata?: string;\r\n  deviceIdentityToken?: string;\r\n\r\n  toJSON(): DeviceDetails {\r\n    return {\r\n      id: this.id,\r\n      deviceSecret: this.deviceSecret,\r\n      platform: this.platform,\r\n      formFactor: this.formFactor,\r\n      clientId: this.clientId,\r\n      metadata: this.metadata,\r\n      deviceIdentityToken: this.deviceIdentityToken,\r\n      push: {\r\n        recipient: this.push?.recipient,\r\n        state: this.push?.state,\r\n        error: this.push?.error,\r\n      },\r\n    } as DeviceDetails;\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[DeviceDetails';\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.platform) result += '; platform=' + this.platform;\r\n    if (this.formFactor) result += '; formFactor=' + this.formFactor;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.metadata) result += '; metadata=' + this.metadata;\r\n    if (this.deviceIdentityToken) result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);\r\n    if (this.push?.recipient) result += '; push.recipient=' + JSON.stringify(this.push.recipient);\r\n    if (this.push?.state) result += '; push.state=' + this.push.state;\r\n    if (this.push?.error) result += '; push.error=' + JSON.stringify(this.push.error);\r\n    if (this.push?.metadata) result += '; push.metadata=' + this.push.metadata;\r\n    result += ']';\r\n    return result;\r\n  }\r\n\r\n  static toRequestBody(body: unknown, MsgPack: MsgPack | null, format?: Utils.Format) {\r\n    return Utils.encodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  static fromResponseBody(\r\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\r\n    MsgPack: MsgPack | null,\r\n    format?: Utils.Format,\r\n  ): DeviceDetails | DeviceDetails[] {\r\n    if (format) {\r\n      body = Utils.decodeBody(body, MsgPack, format);\r\n    }\r\n\r\n    if (Array.isArray(body)) {\r\n      return DeviceDetails.fromValuesArray(body);\r\n    } else {\r\n      return DeviceDetails.fromValues(body);\r\n    }\r\n  }\r\n\r\n  static fromValues(values: Record<string, unknown>): DeviceDetails {\r\n    values.error = values.error && ErrorInfo.fromValues(values.error as IConvertibleToErrorInfo);\r\n    return Object.assign(new DeviceDetails(), values);\r\n  }\r\n\r\n  static fromValuesArray(values: Array<Record<string, unknown>>): DeviceDetails[] {\r\n    const count = values.length,\r\n      result = new Array(count);\r\n    for (let i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default DeviceDetails;\r\n", "import Platform from '../../platform';\r\nimport * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport Auth from './auth';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from '../types/errorinfo';\r\nimport BaseClient from './baseclient';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { RequestBody, ResponseHeaders, appendingParams as urlFromPathAndParams, paramString } from 'common/types/http';\r\nimport httpStatusCodes from '../../constants/HttpStatusCodes';\r\n\r\nasync function withAuthDetails<T>(\r\n  client: BaseClient,\r\n  headers: ResponseHeaders | undefined,\r\n  params: Record<string, any>,\r\n  opCallback: Function,\r\n): Promise<ResourceResult<T>> {\r\n  if (client.http.supportsAuthHeaders) {\r\n    const authHeaders = await client.auth.getAuthHeaders();\r\n    return opCallback(Utils.mixin(authHeaders!, headers), params);\r\n  } else {\r\n    const authParams = await client.auth.getAuthParams();\r\n    return opCallback(headers, Utils.mixin(authParams!, params));\r\n  }\r\n}\r\n\r\nfunction unenvelope<T>(\r\n  result: ResourceResult<T>,\r\n  MsgPack: MsgPack | null,\r\n  format: Utils.Format | null,\r\n): ResourceResult<T> {\r\n  if (result.err && !result.body) {\r\n    return { err: result.err };\r\n  }\r\n\r\n  if (result.statusCode === httpStatusCodes.NoContent) {\r\n    return { ...result, body: [] as any, unpacked: true };\r\n  }\r\n\r\n  let body = result.body;\r\n\r\n  if (!result.unpacked) {\r\n    try {\r\n      body = Utils.decodeBody(body, MsgPack, format);\r\n    } catch (e) {\r\n      if (Utils.isErrorInfoOrPartialErrorInfo(e)) {\r\n        return { err: e };\r\n      } else {\r\n        return { err: new PartialErrorInfo(Utils.inspectError(e), null) };\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!body) {\r\n    return { err: new PartialErrorInfo('unenvelope(): Response body is missing', null) };\r\n  }\r\n\r\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body as Record<string, any>;\r\n\r\n  if (wrappedStatusCode === undefined) {\r\n    /* Envelope already unwrapped by the transport */\r\n    return { ...result, body, unpacked: true };\r\n  }\r\n\r\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\r\n    /* handle wrapped errors */\r\n    let wrappedErr = (response && response.error) || result.err;\r\n    if (!wrappedErr) {\r\n      wrappedErr = new Error('Error in unenveloping ' + body);\r\n      wrappedErr.statusCode = wrappedStatusCode;\r\n    }\r\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\r\n  }\r\n\r\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\r\n}\r\n\r\nfunction logResult<T>(\r\n  result: ResourceResult<T>,\r\n  method: HttpMethods,\r\n  path: string,\r\n  params: Record<string, string>,\r\n  logger: Logger,\r\n) {\r\n  if (result.err) {\r\n    Logger.logAction(\r\n      logger,\r\n      Logger.LOG_MICRO,\r\n      'Resource.' + method + '()',\r\n      'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + Utils.inspectError(result.err),\r\n    );\r\n  } else {\r\n    Logger.logAction(\r\n      logger,\r\n      Logger.LOG_MICRO,\r\n      'Resource.' + method + '()',\r\n      'Received; ' +\r\n        urlFromPathAndParams(path, params) +\r\n        '; Headers: ' +\r\n        paramString(result.headers as Record<string, any>) +\r\n        '; StatusCode: ' +\r\n        result.statusCode +\r\n        '; Body: ' +\r\n        (Platform.BufferUtils.isBuffer(result.body)\r\n          ? ' (Base64): ' + Platform.BufferUtils.base64Encode(result.body)\r\n          : ': ' + Platform.Config.inspect(result.body)),\r\n    );\r\n  }\r\n}\r\n\r\nexport interface ResourceResponse<T> {\r\n  body?: T;\r\n  headers?: ResponseHeaders;\r\n  unpacked?: boolean;\r\n  statusCode?: number;\r\n}\r\n\r\nexport interface ResourceResult<T> extends ResourceResponse<T> {\r\n  /**\r\n   * Any error returned by the underlying HTTP client.\r\n   */\r\n  err: IPartialErrorInfo | null;\r\n}\r\n\r\nclass Resource {\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Get, client, path, null, headers, params, envelope, throwError ?? false);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Delete, client, path, null, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Post, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Patch, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Put, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  static async do<T>(\r\n    method: HttpMethods,\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    if (envelope) {\r\n      (params = params || {})['envelope'] = envelope;\r\n    }\r\n\r\n    const logger = client.logger;\r\n\r\n    async function doRequest(\r\n      this: any,\r\n      headers: Record<string, string>,\r\n      params: Record<string, any>,\r\n    ): Promise<ResourceResult<T>> {\r\n      if (logger.shouldLog(Logger.LOG_MICRO)) {\r\n        let decodedBody = body;\r\n        if (headers['content-type']?.indexOf('msgpack') > 0) {\r\n          try {\r\n            if (!client._MsgPack) {\r\n              Utils.throwMissingPluginError('MsgPack');\r\n            }\r\n            decodedBody = client._MsgPack.decode(body as Buffer);\r\n          } catch (decodeErr) {\r\n            Logger.logAction(\r\n              logger,\r\n              Logger.LOG_MICRO,\r\n              'Resource.' + method + '()',\r\n              'Sending MsgPack Decoding Error: ' + Utils.inspectError(decodeErr),\r\n            );\r\n          }\r\n        }\r\n        Logger.logAction(\r\n          logger,\r\n          Logger.LOG_MICRO,\r\n          'Resource.' + method + '()',\r\n          'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody,\r\n        );\r\n      }\r\n\r\n      const httpResult = await client.http.do(method, path, headers, body, params);\r\n\r\n      if (httpResult.error && Auth.isTokenErr(httpResult.error as ErrorInfo)) {\r\n        /* token has expired, so get a new one */\r\n        await client.auth.authorize(null, null);\r\n        /* retry ... */\r\n        return withAuthDetails(client, headers, params, doRequest);\r\n      }\r\n\r\n      return {\r\n        err: httpResult.error as ErrorInfo,\r\n        body: httpResult.body as T | undefined,\r\n        headers: httpResult.headers,\r\n        unpacked: httpResult.unpacked,\r\n        statusCode: httpResult.statusCode,\r\n      };\r\n    }\r\n\r\n    let result = await withAuthDetails<T>(client, headers, params, doRequest);\r\n\r\n    if (envelope) {\r\n      result = unenvelope(result, client._MsgPack, envelope);\r\n    }\r\n\r\n    if (logger.shouldLog(Logger.LOG_MICRO)) {\r\n      logResult(result, method, path, params, logger);\r\n    }\r\n\r\n    if (throwError) {\r\n      if (result.err) {\r\n        throw result.err;\r\n      } else {\r\n        const response: Omit<ResourceResult<T>, 'err'> & Pick<Partial<ResourceResult<T>>, 'err'> = { ...result };\r\n        delete response.err;\r\n        return response;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default Resource;\r\n", "import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport Resource, { ResourceResult } from './resource';\r\nimport { IPartialErrorInfo } from '../types/errorinfo';\r\nimport BaseClient from './baseclient';\r\nimport { RequestBody, ResponseHeaders } from 'common/types/http';\r\nimport HttpStatusCodes from '../../constants/HttpStatusCodes';\r\n\r\nexport type BodyHandler = (body: unknown, headers: ResponseHeaders, unpacked?: boolean) => Promise<any>;\r\n\r\nfunction getRelParams(linkUrl: string) {\r\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\r\n  return urlMatch && urlMatch[2] && Utils.parseQueryString(urlMatch[2]);\r\n}\r\n\r\nfunction parseRelLinks(linkHeader: string | Array<string>) {\r\n  if (typeof linkHeader == 'string') linkHeader = linkHeader.split(',');\r\n\r\n  const relParams: Record<string, Record<string, string>> = {};\r\n  for (let i = 0; i < linkHeader.length; i++) {\r\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\r\n    if (linkMatch) {\r\n      const params = getRelParams(linkMatch[1]);\r\n      if (params) relParams[linkMatch[2]] = params;\r\n    }\r\n  }\r\n  return relParams;\r\n}\r\n\r\nfunction returnErrOnly(err: IPartialErrorInfo, body: unknown, useHPR?: boolean) {\r\n  /* If using httpPaginatedResponse, errors from Ably are returned as part of\r\n   * the HPR, only throw `err` for network errors etc. which don't\r\n   * return a body and/or have no ably-originated error code (non-numeric\r\n   * error codes originate from node) */\r\n  return !(useHPR && (body || typeof err.code === 'number'));\r\n}\r\n\r\nclass PaginatedResource {\r\n  client: BaseClient;\r\n  path: string;\r\n  headers: Record<string, string>;\r\n  envelope: Utils.Format | null;\r\n  bodyHandler: BodyHandler;\r\n  useHttpPaginatedResponse: boolean;\r\n\r\n  constructor(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    envelope: Utils.Format | undefined,\r\n    bodyHandler: BodyHandler,\r\n    useHttpPaginatedResponse?: boolean,\r\n  ) {\r\n    this.client = client;\r\n    this.path = path;\r\n    this.headers = headers;\r\n    this.envelope = envelope ?? null;\r\n    this.bodyHandler = bodyHandler;\r\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.client.logger;\r\n  }\r\n\r\n  async get<T1, T2>(params: Record<string, T2>): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.get<T1>(this.client, this.path, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async delete<T1, T2>(params: Record<string, T2>): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.delete<T1>(this.client, this.path, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async post<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.post<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async put<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.put<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async patch<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.patch<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async handlePage<T>(result: ResourceResult<T>): Promise<PaginatedResult<T>> {\r\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'PaginatedResource.handlePage()',\r\n        'Unexpected error getting resource: err = ' + Utils.inspectError(result.err),\r\n      );\r\n      throw result.err;\r\n    }\r\n\r\n    let items, linkHeader, relParams;\r\n\r\n    try {\r\n      items =\r\n        result.statusCode == HttpStatusCodes.NoContent\r\n          ? []\r\n          : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\r\n    } catch (e) {\r\n      /* If we got an error, the failure to parse the body is almost certainly\r\n       * due to that, so throw that in preference over the parse error */\r\n      throw result.err || e;\r\n    }\r\n\r\n    if (result.headers && (linkHeader = result.headers['Link'] || result.headers['link'])) {\r\n      relParams = parseRelLinks(linkHeader);\r\n    }\r\n\r\n    if (this.useHttpPaginatedResponse) {\r\n      return new HttpPaginatedResponse(\r\n        this,\r\n        items,\r\n        result.headers || {},\r\n        result.statusCode as number,\r\n        relParams,\r\n        result.err,\r\n      );\r\n    } else {\r\n      return new PaginatedResult(this, items, relParams);\r\n    }\r\n  }\r\n}\r\n\r\nexport class PaginatedResult<T> {\r\n  resource: PaginatedResource;\r\n  items: T[];\r\n  first?: () => Promise<PaginatedResult<T>>;\r\n  next?: () => Promise<PaginatedResult<T> | null>;\r\n  current?: () => Promise<PaginatedResult<T>>;\r\n  hasNext?: () => boolean;\r\n  isLast?: () => boolean;\r\n\r\n  constructor(resource: PaginatedResource, items: T[], relParams?: Record<string, any>) {\r\n    this.resource = resource;\r\n    this.items = items;\r\n\r\n    const self = this;\r\n    if (relParams) {\r\n      if ('first' in relParams) {\r\n        this.first = async function () {\r\n          return self.get(relParams.first);\r\n        };\r\n      }\r\n      if ('current' in relParams) {\r\n        this.current = async function () {\r\n          return self.get(relParams.current);\r\n        };\r\n      }\r\n      this.next = async function () {\r\n        if ('next' in relParams) {\r\n          return self.get(relParams.next);\r\n        } else {\r\n          return null;\r\n        }\r\n      };\r\n\r\n      this.hasNext = function () {\r\n        return 'next' in relParams;\r\n      };\r\n      this.isLast = () => {\r\n        return !this.hasNext?.();\r\n      };\r\n    }\r\n  }\r\n\r\n  /* We assume that only the initial request can be a POST, and that accessing\r\n   * the rest of a multipage set of results can always be done with GET */\r\n  async get(params: any): Promise<PaginatedResult<T>> {\r\n    const res = this.resource;\r\n    const result = await Resource.get<T>(res.client, res.path, res.headers, params, res.envelope, false);\r\n    return res.handlePage(result);\r\n  }\r\n}\r\n\r\nexport class HttpPaginatedResponse<T> extends PaginatedResult<T> {\r\n  statusCode: number;\r\n  success: boolean;\r\n  headers: ResponseHeaders;\r\n  errorCode?: number | null;\r\n  errorMessage?: string | null;\r\n\r\n  constructor(\r\n    resource: PaginatedResource,\r\n    items: T[],\r\n    headers: ResponseHeaders,\r\n    statusCode: number,\r\n    relParams: any,\r\n    err: IPartialErrorInfo | null,\r\n  ) {\r\n    super(resource, items, relParams);\r\n    this.statusCode = statusCode;\r\n    this.success = statusCode < 300 && statusCode >= 200;\r\n    this.headers = headers;\r\n    this.errorCode = err && err.code;\r\n    this.errorMessage = err && err.message;\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      items: this.items,\r\n      statusCode: this.statusCode,\r\n      success: this.success,\r\n      headers: this.headers,\r\n      errorCode: this.errorCode,\r\n      errorMessage: this.errorMessage,\r\n    };\r\n  }\r\n}\r\n\r\nexport default PaginatedResource;\r\n", "import { MsgPack } from 'common/types/msgpack';\r\nimport * as Utils from '../util/utils';\r\n\r\ntype PushChannelSubscriptionObject = {\r\n  channel?: string;\r\n  deviceId?: string;\r\n  clientId?: string;\r\n};\r\n\r\nclass PushChannelSubscription {\r\n  channel?: string;\r\n  deviceId?: string;\r\n  clientId?: string;\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON(): PushChannelSubscriptionObject {\r\n    return {\r\n      channel: this.channel,\r\n      deviceId: this.deviceId,\r\n      clientId: this.clientId,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[PushChannelSubscription';\r\n    if (this.channel) result += '; channel=' + this.channel;\r\n    if (this.deviceId) result += '; deviceId=' + this.deviceId;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    result += ']';\r\n    return result;\r\n  }\r\n\r\n  static toRequestBody = Utils.encodeBody;\r\n\r\n  static fromResponseBody(\r\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\r\n    MsgPack: MsgPack | null,\r\n    format?: Utils.Format,\r\n  ): PushChannelSubscription | PushChannelSubscription[] {\r\n    if (format) {\r\n      body = Utils.decodeBody(body, MsgPack, format) as Record<string, unknown>;\r\n    }\r\n\r\n    if (Array.isArray(body)) {\r\n      return PushChannelSubscription.fromValuesArray(body);\r\n    } else {\r\n      return PushChannelSubscription.fromValues(body);\r\n    }\r\n  }\r\n\r\n  static fromValues(values: Record<string, unknown>): PushChannelSubscription {\r\n    return Object.assign(new PushChannelSubscription(), values);\r\n  }\r\n\r\n  static fromValuesArray(values: Array<Record<string, unknown>>): PushChannelSubscription[] {\r\n    const count = values.length,\r\n      result = new Array(count);\r\n    for (let i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PushChannelSubscription;\r\n", "import * as Utils from '../util/utils';\r\nimport DeviceDetails from '../types/devicedetails';\r\nimport Resource from './resource';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport PushChannelSubscription from '../types/pushchannelsubscription';\r\nimport BaseClient from './baseclient';\r\nimport Defaults from '../util/defaults';\r\n\r\nclass Push {\r\n  client: BaseClient;\r\n  admin: Admin;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.admin = new Admin(client);\r\n  }\r\n}\r\n\r\nclass Admin {\r\n  client: BaseClient;\r\n  deviceRegistrations: DeviceRegistrations;\r\n  channelSubscriptions: ChannelSubscriptions;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.deviceRegistrations = new DeviceRegistrations(client);\r\n    this.channelSubscriptions = new ChannelSubscriptions(client);\r\n  }\r\n\r\n  async publish(recipient: any, payload: any): Promise<void> {\r\n    const client = this.client;\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n    const body = Utils.mixin({ recipient: recipient }, payload);\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    await Resource.post(client, '/push/publish', requestBody, headers, params, null, true);\r\n  }\r\n}\r\n\r\nclass DeviceRegistrations {\r\n  client: BaseClient;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n  }\r\n\r\n  async save(device: any): Promise<DeviceDetails> {\r\n    const client = this.client;\r\n    const body = DeviceDetails.fromValues(device);\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    const response = await Resource.put(\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(device.id),\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return DeviceDetails.fromResponseBody(\r\n      response.body as Record<string, unknown>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as DeviceDetails;\r\n  }\r\n\r\n  async get(deviceIdOrDetails: any): Promise<DeviceDetails> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format }),\r\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\r\n\r\n    if (typeof deviceId !== 'string' || !deviceId.length) {\r\n      throw new ErrorInfo(\r\n        'First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails',\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const response = await Resource.get(\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\r\n      headers,\r\n      {},\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return DeviceDetails.fromResponseBody(\r\n      response.body as Record<string, unknown>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as DeviceDetails;\r\n  }\r\n\r\n  async list(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    return new PaginatedResource(client, '/push/deviceRegistrations', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return DeviceDetails.fromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n\r\n  async remove(deviceIdOrDetails: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format }),\r\n      params = {},\r\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\r\n\r\n    if (typeof deviceId !== 'string' || !deviceId.length) {\r\n      throw new ErrorInfo(\r\n        'First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails',\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n  }\r\n\r\n  async removeWhere(params: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](client, '/push/deviceRegistrations', headers, params, null, true);\r\n  }\r\n}\r\n\r\nclass ChannelSubscriptions {\r\n  client: BaseClient;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n  }\r\n\r\n  async save(subscription: Record<string, unknown>): Promise<PushChannelSubscription> {\r\n    const client = this.client;\r\n    const body = PushChannelSubscription.fromValues(subscription);\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    const response = await Resource.post(\r\n      client,\r\n      '/push/channelSubscriptions',\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return PushChannelSubscription.fromResponseBody(\r\n      response.body as Record<string, any>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as PushChannelSubscription;\r\n  }\r\n\r\n  async list(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    return new PaginatedResource(client, '/push/channelSubscriptions', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return PushChannelSubscription.fromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n\r\n  async removeWhere(params: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](client, '/push/channelSubscriptions', headers, params, null, true);\r\n  }\r\n\r\n  /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\r\n  remove = ChannelSubscriptions.prototype.removeWhere;\r\n\r\n  async listChannels(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    return new PaginatedResource(client, '/push/channels', headers, envelope, async function (body, headers, unpacked) {\r\n      const parsedBody = (\r\n        !unpacked && format ? Utils.decodeBody(body, client._MsgPack, format) : body\r\n      ) as Array<string>;\r\n\r\n      for (let i = 0; i < parsedBody.length; i++) {\r\n        parsedBody[i] = String(parsedBody[i]);\r\n      }\r\n      return parsedBody;\r\n    }).get(params);\r\n  }\r\n}\r\n\r\nexport default Push;\r\n", "import Platform from 'common/platform';\r\nimport Logger from '../util/logger';\r\nimport ErrorInfo from './errorinfo';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport PresenceMessage from './presencemessage';\r\nimport * as Utils from '../util/utils';\r\nimport { Bufferlike as BrowserBufferlike } from '../../../platform/web/lib/util/bufferutils';\r\nimport * as API from '../../../../ably';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { MsgPack } from 'common/types/msgpack';\r\n\r\nexport type CipherOptions = {\r\n  channelCipher: {\r\n    encrypt: Function;\r\n    algorithm: 'aes';\r\n  };\r\n  cipher?: {\r\n    channelCipher: {\r\n      encrypt: Function;\r\n      algorithm: 'aes';\r\n    };\r\n  };\r\n};\r\n\r\nexport type EncodingDecodingContext = {\r\n  channelOptions: ChannelOptions;\r\n  plugins: {\r\n    vcdiff?: {\r\n      decode: (delta: Uint8Array, source: Uint8Array) => Uint8Array;\r\n    };\r\n  };\r\n  baseEncodedPreviousPayload?: Buffer | BrowserBufferlike;\r\n};\r\n\r\nfunction normaliseContext(context: CipherOptions | EncodingDecodingContext | ChannelOptions): EncodingDecodingContext {\r\n  if (!context || !(context as EncodingDecodingContext).channelOptions) {\r\n    return {\r\n      channelOptions: context as ChannelOptions,\r\n      plugins: {},\r\n      baseEncodedPreviousPayload: undefined,\r\n    };\r\n  }\r\n  return context as EncodingDecodingContext;\r\n}\r\n\r\nfunction normalizeCipherOptions(\r\n  Crypto: IUntypedCryptoStatic | null,\r\n  logger: Logger,\r\n  options: API.ChannelOptions | null,\r\n): ChannelOptions {\r\n  if (options && options.cipher) {\r\n    if (!Crypto) Utils.throwMissingPluginError('Crypto');\r\n    const cipher = Crypto.getCipher(options.cipher, logger);\r\n    return {\r\n      cipher: cipher.cipherParams,\r\n      channelCipher: cipher.cipher,\r\n    };\r\n  }\r\n  return options ?? {};\r\n}\r\n\r\nfunction getMessageSize(msg: Message) {\r\n  let size = 0;\r\n  if (msg.name) {\r\n    size += msg.name.length;\r\n  }\r\n  if (msg.clientId) {\r\n    size += msg.clientId.length;\r\n  }\r\n  if (msg.extras) {\r\n    size += JSON.stringify(msg.extras).length;\r\n  }\r\n  if (msg.data) {\r\n    size += Utils.dataSizeBytes(msg.data);\r\n  }\r\n  return size;\r\n}\r\n\r\nexport async function fromEncoded(\r\n  logger: Logger,\r\n  Crypto: IUntypedCryptoStatic | null,\r\n  encoded: unknown,\r\n  inputOptions?: API.ChannelOptions,\r\n): Promise<Message> {\r\n  const msg = fromValues(encoded);\r\n  const options = normalizeCipherOptions(Crypto, logger, inputOptions ?? null);\r\n  /* if decoding fails at any point, catch and return the message decoded to\r\n   * the fullest extent possible */\r\n  try {\r\n    await decode(msg, options);\r\n  } catch (e) {\r\n    Logger.logAction(logger, Logger.LOG_ERROR, 'Message.fromEncoded()', (e as Error).toString());\r\n  }\r\n  return msg;\r\n}\r\n\r\nexport async function fromEncodedArray(\r\n  logger: Logger,\r\n  Crypto: IUntypedCryptoStatic | null,\r\n  encodedArray: Array<unknown>,\r\n  options?: API.ChannelOptions,\r\n): Promise<Message[]> {\r\n  return Promise.all(\r\n    encodedArray.map(function (encoded) {\r\n      return fromEncoded(logger, Crypto, encoded, options);\r\n    }),\r\n  );\r\n}\r\n\r\nasync function encrypt<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\r\n  let data = msg.data,\r\n    encoding = msg.encoding,\r\n    cipher = options.channelCipher;\r\n\r\n  encoding = encoding ? encoding + '/' : '';\r\n  if (!Platform.BufferUtils.isBuffer(data)) {\r\n    data = Platform.BufferUtils.utf8Encode(String(data));\r\n    encoding = encoding + 'utf-8/';\r\n  }\r\n  const ciphertext = await cipher.encrypt(data);\r\n  msg.data = ciphertext;\r\n  msg.encoding = encoding + 'cipher+' + cipher.algorithm;\r\n  return msg;\r\n}\r\n\r\nexport async function encode<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\r\n  const data = msg.data;\r\n  const nativeDataType =\r\n    typeof data == 'string' || Platform.BufferUtils.isBuffer(data) || data === null || data === undefined;\r\n\r\n  if (!nativeDataType) {\r\n    if (Utils.isObject(data) || Array.isArray(data)) {\r\n      msg.data = JSON.stringify(data);\r\n      msg.encoding = msg.encoding ? msg.encoding + '/json' : 'json';\r\n    } else {\r\n      throw new ErrorInfo('Data type is unsupported', 40013, 400);\r\n    }\r\n  }\r\n\r\n  if (options != null && options.cipher) {\r\n    return encrypt(msg, options);\r\n  } else {\r\n    return msg;\r\n  }\r\n}\r\n\r\nexport async function encodeArray(messages: Array<Message>, options: CipherOptions): Promise<Array<Message>> {\r\n  return Promise.all(messages.map((message) => encode(message, options)));\r\n}\r\n\r\nexport const serialize = Utils.encodeBody;\r\n\r\nexport async function decode(\r\n  message: Message | PresenceMessage,\r\n  inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\r\n): Promise<void> {\r\n  const context = normaliseContext(inputContext);\r\n\r\n  let lastPayload = message.data;\r\n  const encoding = message.encoding;\r\n  if (encoding) {\r\n    const xforms = encoding.split('/');\r\n    let lastProcessedEncodingIndex,\r\n      encodingsToProcess = xforms.length,\r\n      data = message.data;\r\n\r\n    let xform = '';\r\n    try {\r\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\r\n        // eslint-disable-next-line security/detect-unsafe-regex\r\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\r\n        if (!match) break;\r\n        xform = match[1];\r\n        switch (xform) {\r\n          case 'base64':\r\n            data = Platform.BufferUtils.base64Decode(String(data));\r\n            if (lastProcessedEncodingIndex == xforms.length) {\r\n              lastPayload = data;\r\n            }\r\n            continue;\r\n          case 'utf-8':\r\n            data = Platform.BufferUtils.utf8Decode(data);\r\n            continue;\r\n          case 'json':\r\n            data = JSON.parse(data);\r\n            continue;\r\n          case 'cipher':\r\n            if (\r\n              context.channelOptions != null &&\r\n              context.channelOptions.cipher &&\r\n              context.channelOptions.channelCipher\r\n            ) {\r\n              const xformAlgorithm = match[3],\r\n                cipher = context.channelOptions.channelCipher;\r\n              /* don't attempt to decrypt unless the cipher params are compatible */\r\n              if (xformAlgorithm != cipher.algorithm) {\r\n                throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');\r\n              }\r\n              data = await cipher.decrypt(data);\r\n              continue;\r\n            } else {\r\n              throw new Error('Unable to decrypt message; not an encrypted channel');\r\n            }\r\n          case 'vcdiff':\r\n            if (!context.plugins || !context.plugins.vcdiff) {\r\n              throw new ErrorInfo('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);\r\n            }\r\n            if (typeof Uint8Array === 'undefined') {\r\n              throw new ErrorInfo(\r\n                'Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)',\r\n                40020,\r\n                400,\r\n              );\r\n            }\r\n            try {\r\n              let deltaBase = context.baseEncodedPreviousPayload;\r\n              if (typeof deltaBase === 'string') {\r\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\r\n              }\r\n\r\n              // vcdiff expects Uint8Arrays, can't copy with ArrayBuffers.\r\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase as Buffer);\r\n              data = Platform.BufferUtils.toBuffer(data);\r\n\r\n              data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBaseBuffer));\r\n              lastPayload = data;\r\n            } catch (e) {\r\n              throw new ErrorInfo('Vcdiff delta decode failed with ' + e, 40018, 400);\r\n            }\r\n            continue;\r\n          default:\r\n            throw new Error('Unknown encoding');\r\n        }\r\n      }\r\n    } catch (e) {\r\n      const err = e as ErrorInfo;\r\n      throw new ErrorInfo(\r\n        'Error processing the ' + xform + ' encoding, decoder returned \u2018' + err.message + '\u2019',\r\n        err.code || 40013,\r\n        400,\r\n      );\r\n    } finally {\r\n      message.encoding =\r\n        (lastProcessedEncodingIndex as number) <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');\r\n      message.data = data;\r\n    }\r\n  }\r\n  context.baseEncodedPreviousPayload = lastPayload;\r\n}\r\n\r\nexport async function fromResponseBody(\r\n  body: Array<Message>,\r\n  options: ChannelOptions | EncodingDecodingContext,\r\n  logger: Logger,\r\n  MsgPack: MsgPack | null,\r\n  format?: Utils.Format,\r\n): Promise<Message[]> {\r\n  if (format) {\r\n    body = Utils.decodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  for (let i = 0; i < body.length; i++) {\r\n    const msg = (body[i] = fromValues(body[i]));\r\n    try {\r\n      await decode(msg, options);\r\n    } catch (e) {\r\n      Logger.logAction(logger, Logger.LOG_ERROR, 'Message.fromResponseBody()', (e as Error).toString());\r\n    }\r\n  }\r\n  return body;\r\n}\r\n\r\nexport function fromValues(values: unknown): Message {\r\n  return Object.assign(new Message(), values);\r\n}\r\n\r\nexport function fromValuesArray(values: unknown[]): Message[] {\r\n  const count = values.length,\r\n    result = new Array(count);\r\n  for (let i = 0; i < count; i++) result[i] = fromValues(values[i]);\r\n  return result;\r\n}\r\n\r\n/* This should be called on encode()d (and encrypt()d) Messages (as it\r\n * assumes the data is a string or buffer) */\r\nexport function getMessagesSize(messages: Message[]): number {\r\n  let msg,\r\n    total = 0;\r\n  for (let i = 0; i < messages.length; i++) {\r\n    msg = messages[i];\r\n    total += msg.size || (msg.size = getMessageSize(msg));\r\n  }\r\n  return total;\r\n}\r\n\r\nclass Message {\r\n  name?: string;\r\n  id?: string;\r\n  timestamp?: number;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n  connectionKey?: string;\r\n  data?: any;\r\n  encoding?: string | null;\r\n  extras?: any;\r\n  size?: number;\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON() {\r\n    /* encode data to base64 if present and we're returning real JSON;\r\n     * although msgpack calls toJSON(), we know it is a stringify()\r\n     * call if it has a non-empty arguments list */\r\n    let encoding = this.encoding;\r\n    let data = this.data;\r\n    if (data && Platform.BufferUtils.isBuffer(data)) {\r\n      if (arguments.length > 0) {\r\n        /* stringify call */\r\n        encoding = encoding ? encoding + '/base64' : 'base64';\r\n        data = Platform.BufferUtils.base64Encode(data);\r\n      } else {\r\n        /* Called by msgpack. toBuffer returns a datatype understandable by\r\n         * that platform's msgpack implementation (Buffer in node, Uint8Array\r\n         * in browsers) */\r\n        data = Platform.BufferUtils.toBuffer(data);\r\n      }\r\n    }\r\n    return {\r\n      name: this.name,\r\n      id: this.id,\r\n      clientId: this.clientId,\r\n      connectionId: this.connectionId,\r\n      connectionKey: this.connectionKey,\r\n      extras: this.extras,\r\n      encoding,\r\n      data,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[Message';\r\n    if (this.name) result += '; name=' + this.name;\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\r\n    if (this.encoding) result += '; encoding=' + this.encoding;\r\n    if (this.extras) result += '; extras =' + JSON.stringify(this.extras);\r\n    if (this.data) {\r\n      if (typeof this.data == 'string') result += '; data=' + this.data;\r\n      else if (Platform.BufferUtils.isBuffer(this.data))\r\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(this.data);\r\n      else result += '; data (json)=' + JSON.stringify(this.data);\r\n    }\r\n    if (this.extras) result += '; extras=' + JSON.stringify(this.extras);\r\n    result += ']';\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default Message;\r\n", "import Logger from '../util/logger';\r\nimport Platform from 'common/platform';\r\nimport { encode as encodeMessage, decode as decodeMessage, getMessagesSize, CipherOptions } from './message';\r\nimport * as Utils from '../util/utils';\r\nimport * as API from '../../../../ably';\r\nimport { MsgPack } from 'common/types/msgpack';\r\n\r\nconst actions = ['absent', 'present', 'enter', 'leave', 'update'];\r\n\r\nfunction toActionValue(actionString: string) {\r\n  return actions.indexOf(actionString);\r\n}\r\n\r\nexport async function fromEncoded(\r\n  logger: Logger,\r\n  encoded: unknown,\r\n  options?: API.ChannelOptions,\r\n): Promise<PresenceMessage> {\r\n  const msg = fromValues(encoded as PresenceMessage | Record<string, unknown>, true);\r\n  /* if decoding fails at any point, catch and return the message decoded to\r\n   * the fullest extent possible */\r\n  try {\r\n    await decode(msg, options ?? {});\r\n  } catch (e) {\r\n    Logger.logAction(logger, Logger.LOG_ERROR, 'PresenceMessage.fromEncoded()', (e as Error).toString());\r\n  }\r\n  return msg;\r\n}\r\n\r\nexport async function fromEncodedArray(\r\n  logger: Logger,\r\n  encodedArray: unknown[],\r\n  options?: API.ChannelOptions,\r\n): Promise<PresenceMessage[]> {\r\n  return Promise.all(\r\n    encodedArray.map(function (encoded) {\r\n      return fromEncoded(logger, encoded, options);\r\n    }),\r\n  );\r\n}\r\n\r\nexport function fromValues(\r\n  values: PresenceMessage | Record<string, unknown>,\r\n  stringifyAction?: boolean,\r\n): PresenceMessage {\r\n  if (stringifyAction) {\r\n    values.action = actions[values.action as number];\r\n  }\r\n  return Object.assign(new PresenceMessage(), values);\r\n}\r\n\r\nexport { encodeMessage as encode };\r\nexport const decode = decodeMessage;\r\n\r\nexport async function fromResponseBody(\r\n  body: Record<string, unknown>[],\r\n  options: CipherOptions,\r\n  logger: Logger,\r\n  MsgPack: MsgPack | null,\r\n  format?: Utils.Format,\r\n): Promise<PresenceMessage[]> {\r\n  const messages: PresenceMessage[] = [];\r\n  if (format) {\r\n    body = Utils.decodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  for (let i = 0; i < body.length; i++) {\r\n    const msg = (messages[i] = fromValues(body[i], true));\r\n    try {\r\n      await decode(msg, options);\r\n    } catch (e) {\r\n      Logger.logAction(logger, Logger.LOG_ERROR, 'PresenceMessage.fromResponseBody()', (e as Error).toString());\r\n    }\r\n  }\r\n  return messages;\r\n}\r\n\r\nexport function fromValuesArray(values: unknown[]): PresenceMessage[] {\r\n  const count = values.length,\r\n    result = new Array(count);\r\n  for (let i = 0; i < count; i++) result[i] = fromValues(values[i] as Record<string, unknown>);\r\n  return result;\r\n}\r\n\r\nexport function fromData(data: unknown): PresenceMessage {\r\n  if (data instanceof PresenceMessage) {\r\n    return data;\r\n  }\r\n  return fromValues({\r\n    data,\r\n  });\r\n}\r\n\r\nexport { getMessagesSize };\r\n\r\nclass PresenceMessage {\r\n  action?: string | number;\r\n  id?: string;\r\n  timestamp?: number;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n  data?: string | Buffer | Uint8Array;\r\n  encoding?: string;\r\n  extras?: any;\r\n  size?: number;\r\n\r\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\r\n   * sent by the connection (usually means a leave event sent 15s after a\r\n   * disconnection). This is useful because synthesized messages cannot be\r\n   * compared for newness by id lexicographically - RTP2b1\r\n   */\r\n  isSynthesized(): boolean {\r\n    if (!this.id || !this.connectionId) {\r\n      return true;\r\n    }\r\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\r\n  }\r\n\r\n  /* RTP2b2 */\r\n  parseId(): { connectionId: string; msgSerial: number; index: number } {\r\n    if (!this.id) throw new Error('parseId(): Presence message does not contain an id');\r\n    const parts = this.id.split(':');\r\n    return {\r\n      connectionId: parts[0],\r\n      msgSerial: parseInt(parts[1], 10),\r\n      index: parseInt(parts[2], 10),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON(): {\r\n    id?: string;\r\n    clientId?: string;\r\n    action: number;\r\n    data: string | Buffer | Uint8Array;\r\n    encoding?: string;\r\n    extras?: any;\r\n  } {\r\n    /* encode data to base64 if present and we're returning real JSON;\r\n     * although msgpack calls toJSON(), we know it is a stringify()\r\n     * call if it has a non-empty arguments list */\r\n    let data = this.data as string | Buffer | Uint8Array;\r\n    let encoding = this.encoding;\r\n    if (data && Platform.BufferUtils.isBuffer(data)) {\r\n      if (arguments.length > 0) {\r\n        /* stringify call */\r\n        encoding = encoding ? encoding + '/base64' : 'base64';\r\n        data = Platform.BufferUtils.base64Encode(data);\r\n      } else {\r\n        /* Called by msgpack. toBuffer returns a datatype understandable by\r\n         * that platform's msgpack implementation (Buffer in node, Uint8Array\r\n         * in browsers) */\r\n        data = Platform.BufferUtils.toBuffer(data);\r\n      }\r\n    }\r\n    return {\r\n      id: this.id,\r\n      clientId: this.clientId,\r\n      /* Convert presence action back to an int for sending to Ably */\r\n      action: toActionValue(this.action as string),\r\n      data: data,\r\n      encoding: encoding,\r\n      extras: this.extras,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[PresenceMessage';\r\n    result += '; action=' + this.action;\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\r\n    if (this.encoding) result += '; encoding=' + this.encoding;\r\n    if (this.data) {\r\n      if (typeof this.data == 'string') result += '; data=' + this.data;\r\n      else if (Platform.BufferUtils.isBuffer(this.data))\r\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(this.data);\r\n      else result += '; data (json)=' + JSON.stringify(this.data);\r\n    }\r\n    if (this.extras) {\r\n      result += '; extras=' + JSON.stringify(this.extras);\r\n    }\r\n    result += ']';\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PresenceMessage;\r\n", "import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport PresenceMessage, { fromResponseBody as presenceMessageFromResponseBody } from '../types/presencemessage';\r\nimport { CipherOptions } from '../types/message';\r\nimport RestChannel from './restchannel';\r\nimport Defaults from '../util/defaults';\r\n\r\nclass RestPresence {\r\n  channel: RestChannel;\r\n\r\n  constructor(channel: RestChannel) {\r\n    this.channel = channel;\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.channel.logger;\r\n  }\r\n\r\n  async get(params: any): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RestPresence.get()', 'channel = ' + this.channel.name);\r\n    const client = this.channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = this.channel.channelOptions;\r\n    return new PaginatedResource(\r\n      client,\r\n      this.channel.client.rest.presenceMixin.basePath(this),\r\n      headers,\r\n      envelope,\r\n      async (body, headers, unpacked) => {\r\n        return await presenceMessageFromResponseBody(\r\n          body as Record<string, unknown>[],\r\n          options as CipherOptions,\r\n          this.logger,\r\n          client._MsgPack,\r\n          unpacked ? undefined : format,\r\n        );\r\n      },\r\n    ).get(params);\r\n  }\r\n\r\n  async history(params: any): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RestPresence.history()', 'channel = ' + this.channel.name);\r\n    return this.channel.client.rest.presenceMixin.history(this, params);\r\n  }\r\n}\r\n\r\nexport default RestPresence;\r\n", "import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport RestPresence from './restpresence';\r\nimport Message, {\r\n  fromValues as messageFromValues,\r\n  fromValuesArray as messagesFromValuesArray,\r\n  encodeArray as encodeMessagesArray,\r\n  serialize as serializeMessage,\r\n  getMessagesSize,\r\n  CipherOptions,\r\n} from '../types/message';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport { PaginatedResult } from './paginatedresource';\r\nimport Resource from './resource';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport BaseRest from './baseclient';\r\nimport * as API from '../../../../ably';\r\nimport Defaults, { normaliseChannelOptions } from '../util/defaults';\r\nimport { RestHistoryParams } from './restchannelmixin';\r\nimport { RequestBody } from 'common/types/http';\r\n\r\nconst MSG_ID_ENTROPY_BYTES = 9;\r\n\r\nfunction allEmptyIds(messages: Array<Message>) {\r\n  return messages.every(function (message: Message) {\r\n    return !message.id;\r\n  });\r\n}\r\n\r\nclass RestChannel {\r\n  client: BaseRest;\r\n  name: string;\r\n  presence: RestPresence;\r\n  channelOptions: ChannelOptions;\r\n\r\n  constructor(client: BaseRest, name: string, channelOptions?: ChannelOptions) {\r\n    Logger.logAction(client.logger, Logger.LOG_MINOR, 'RestChannel()', 'started; name = ' + name);\r\n    this.name = name;\r\n    this.client = client;\r\n    this.presence = new RestPresence(this);\r\n    this.channelOptions = normaliseChannelOptions(client._Crypto ?? null, this.logger, channelOptions);\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.client.logger;\r\n  }\r\n\r\n  setOptions(options?: ChannelOptions): void {\r\n    this.channelOptions = normaliseChannelOptions(this.client._Crypto ?? null, this.logger, options);\r\n  }\r\n\r\n  async history(params: RestHistoryParams | null): Promise<PaginatedResult<Message>> {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RestChannel.history()', 'channel = ' + this.name);\r\n    return this.client.rest.channelMixin.history(this, params);\r\n  }\r\n\r\n  async publish(...args: any[]): Promise<void> {\r\n    const first = args[0],\r\n      second = args[1];\r\n    let messages: Array<Message>;\r\n    let params: any;\r\n\r\n    if (typeof first === 'string' || first === null) {\r\n      /* (name, data, ...) */\r\n      messages = [messageFromValues({ name: first, data: second })];\r\n      params = args[2];\r\n    } else if (Utils.isObject(first)) {\r\n      messages = [messageFromValues(first)];\r\n      params = args[1];\r\n    } else if (Array.isArray(first)) {\r\n      messages = messagesFromValuesArray(first);\r\n      params = args[1];\r\n    } else {\r\n      throw new ErrorInfo(\r\n        'The single-argument form of publish() expects a message object or an array of message objects',\r\n        40013,\r\n        400,\r\n      );\r\n    }\r\n\r\n    if (!params) {\r\n      /* No params supplied */\r\n      params = {};\r\n    }\r\n\r\n    const client = this.client,\r\n      options = client.options,\r\n      format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      idempotentRestPublishing = client.options.idempotentRestPublishing,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, options.headers);\r\n\r\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\r\n      const msgIdBase = await Utils.randomString(MSG_ID_ENTROPY_BYTES);\r\n      messages.forEach(function (message, index) {\r\n        message.id = msgIdBase + ':' + index.toString();\r\n      });\r\n    }\r\n\r\n    await encodeMessagesArray(messages, this.channelOptions as CipherOptions);\r\n\r\n    /* RSL1i */\r\n    const size = getMessagesSize(messages),\r\n      maxMessageSize = options.maxMessageSize;\r\n    if (size > maxMessageSize) {\r\n      throw new ErrorInfo(\r\n        'Maximum size of messages that can be published at once exceeded ( was ' +\r\n          size +\r\n          ' bytes; limit is ' +\r\n          maxMessageSize +\r\n          ' bytes)',\r\n        40009,\r\n        400,\r\n      );\r\n    }\r\n\r\n    await this._publish(serializeMessage(messages, client._MsgPack, format), headers, params);\r\n  }\r\n\r\n  async _publish(requestBody: RequestBody | null, headers: Record<string, string>, params: any): Promise<void> {\r\n    await Resource.post(\r\n      this.client,\r\n      this.client.rest.channelMixin.basePath(this) + '/messages',\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n  }\r\n\r\n  async status(): Promise<API.ChannelDetails> {\r\n    return this.client.rest.channelMixin.status(this);\r\n  }\r\n}\r\n\r\nexport default RestChannel;\r\n", "type StatsValues = {\r\n  entries?: Partial<Record<string, number>>;\r\n  schema?: string;\r\n  appId?: string;\r\n  inProgress?: never;\r\n  unit?: never;\r\n  intervalId?: never;\r\n};\r\n\r\nclass Stats {\r\n  entries?: Partial<Record<string, number>>;\r\n  schema?: string;\r\n  appId?: string;\r\n  inProgress?: never;\r\n  unit?: never;\r\n  intervalId?: never;\r\n\r\n  constructor(values?: StatsValues) {\r\n    this.entries = (values && values.entries) || undefined;\r\n    this.schema = (values && values.schema) || undefined;\r\n    this.appId = (values && values.appId) || undefined;\r\n    this.inProgress = (values && values.inProgress) || undefined;\r\n    this.unit = (values && values.unit) || undefined;\r\n    this.intervalId = (values && values.intervalId) || undefined;\r\n  }\r\n\r\n  static fromValues(values: StatsValues): Stats {\r\n    return new Stats(values);\r\n  }\r\n}\r\n\r\nexport default Stats;\r\n", "import * as API from '../../../../ably';\r\nimport RestChannel from './restchannel';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport * as Utils from '../util/utils';\r\nimport Message, { fromResponseBody as messageFromResponseBody } from '../types/message';\r\nimport Defaults from '../util/defaults';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport Resource from './resource';\r\n\r\nexport interface RestHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n}\r\n\r\nexport class RestChannelMixin {\r\n  static basePath(channel: RestChannel | RealtimeChannel) {\r\n    return '/channels/' + encodeURIComponent(channel.name);\r\n  }\r\n\r\n  static history(\r\n    channel: RestChannel | RealtimeChannel,\r\n    params: RestHistoryParams | null,\r\n  ): Promise<PaginatedResult<Message>> {\r\n    const client = channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = channel.channelOptions;\r\n    return new PaginatedResource(client, this.basePath(channel) + '/messages', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return await messageFromResponseBody(\r\n        body as Message[],\r\n        options,\r\n        channel.logger,\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params as Record<string, unknown>);\r\n  }\r\n\r\n  static async status(channel: RestChannel | RealtimeChannel): Promise<API.ChannelDetails> {\r\n    const format = channel.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\r\n    const headers = Defaults.defaultPostHeaders(channel.client.options, { format });\r\n\r\n    const response = await Resource.get<API.ChannelDetails>(\r\n      channel.client,\r\n      this.basePath(channel),\r\n      headers,\r\n      {},\r\n      format,\r\n      true,\r\n    );\r\n\r\n    return response.body!;\r\n  }\r\n}\r\n", "import RestPresence from './restpresence';\r\nimport RealtimePresence from './realtimepresence';\r\nimport * as Utils from '../util/utils';\r\nimport Defaults from '../util/defaults';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport PresenceMessage, { fromResponseBody as presenceMessageFromResponseBody } from '../types/presencemessage';\r\nimport { CipherOptions } from '../types/message';\r\nimport { RestChannelMixin } from './restchannelmixin';\r\n\r\nexport class RestPresenceMixin {\r\n  static basePath(presence: RestPresence | RealtimePresence) {\r\n    return RestChannelMixin.basePath(presence.channel) + '/presence';\r\n  }\r\n\r\n  static async history(\r\n    presence: RestPresence | RealtimePresence,\r\n    params: any,\r\n  ): Promise<PaginatedResult<PresenceMessage>> {\r\n    const client = presence.channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = presence.channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = presence.channel.channelOptions;\r\n    return new PaginatedResource(client, this.basePath(presence) + '/history', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return await presenceMessageFromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        options as CipherOptions,\r\n        presence.logger,\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n}\r\n", "import * as Utils from '../util/utils';\r\nimport Defaults from '../util/defaults';\r\nimport Push from './push';\r\nimport PaginatedResource, { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\r\nimport RestChannel from './restchannel';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Stats from '../types/stats';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport { RequestBody, RequestParams } from '../../types/http';\r\nimport * as API from '../../../../ably';\r\nimport Resource from './resource';\r\n\r\nimport Platform from '../../platform';\r\nimport BaseClient from './baseclient';\r\nimport { useTokenAuth } from './auth';\r\nimport { RestChannelMixin } from './restchannelmixin';\r\nimport { RestPresenceMixin } from './restpresencemixin';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\n\r\ntype BatchPublishSpec = API.BatchPublishSpec;\r\ntype BatchPublishSuccessResult = API.BatchPublishSuccessResult;\r\ntype BatchPublishFailureResult = API.BatchPublishFailureResult;\r\ntype BatchPublishResult = BatchResult<BatchPublishSuccessResult | BatchPublishFailureResult>;\r\ntype BatchPresenceSuccessResult = API.BatchPresenceSuccessResult;\r\ntype BatchPresenceFailureResult = API.BatchPresenceFailureResult;\r\ntype BatchPresenceResult = BatchResult<BatchPresenceSuccessResult | BatchPresenceFailureResult>;\r\n\r\ntype TokenRevocationTargetSpecifier = API.TokenRevocationTargetSpecifier;\r\ntype TokenRevocationOptions = API.TokenRevocationOptions;\r\ntype TokenRevocationSuccessResult = API.TokenRevocationSuccessResult;\r\ntype TokenRevocationFailureResult = API.TokenRevocationFailureResult;\r\ntype TokenRevocationResult = BatchResult<TokenRevocationSuccessResult | TokenRevocationFailureResult>;\r\n\r\nexport class Rest {\r\n  private readonly client: BaseClient;\r\n  readonly channels: Channels;\r\n  readonly push: Push;\r\n\r\n  readonly channelMixin = RestChannelMixin;\r\n  readonly presenceMixin = RestPresenceMixin;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.channels = new Channels(this.client);\r\n    this.push = new Push(this.client);\r\n  }\r\n\r\n  async stats(params: RequestParams): Promise<PaginatedResult<Stats>> {\r\n    const headers = Defaults.defaultGetHeaders(this.client.options),\r\n      format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format;\r\n\r\n    Utils.mixin(headers, this.client.options.headers);\r\n\r\n    return new PaginatedResource(this.client, '/stats', headers, envelope, function (body, headers, unpacked) {\r\n      const statsValues = unpacked ? body : JSON.parse(body as string);\r\n      for (let i = 0; i < statsValues.length; i++) statsValues[i] = Stats.fromValues(statsValues[i]);\r\n      return statsValues;\r\n    }).get(params as Record<string, string>);\r\n  }\r\n\r\n  async time(params?: RequestParams): Promise<number> {\r\n    const headers = Defaults.defaultGetHeaders(this.client.options);\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n    const timeUri = (host: string) => {\r\n      return this.client.baseUri(host) + '/time';\r\n    };\r\n\r\n    let { error, body, unpacked } = await this.client.http.do(\r\n      HttpMethods.Get,\r\n      timeUri,\r\n      headers,\r\n      null,\r\n      params as RequestParams,\r\n    );\r\n\r\n    if (error) {\r\n      throw error;\r\n    }\r\n    if (!unpacked) body = JSON.parse(body as string);\r\n    const time = (body as number[])[0];\r\n    if (!time) {\r\n      throw new ErrorInfo('Internal error (unexpected result type from GET /time)', 50000, 500);\r\n    }\r\n    /* calculate time offset only once for this device by adding to the prototype */\r\n    this.client.serverTimeOffset = time - Date.now();\r\n    return time;\r\n  }\r\n\r\n  async request(\r\n    method: string,\r\n    path: string,\r\n    version: number,\r\n    params: RequestParams,\r\n    body: unknown,\r\n    customHeaders: Record<string, string>,\r\n  ): Promise<HttpPaginatedResponse<unknown>> {\r\n    const [encoder, decoder, format] = (() => {\r\n      if (this.client.options.useBinaryProtocol) {\r\n        if (!this.client._MsgPack) {\r\n          Utils.throwMissingPluginError('MsgPack');\r\n        }\r\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, Utils.Format.msgpack];\r\n      } else {\r\n        return [JSON.stringify, JSON.parse, Utils.Format.json];\r\n      }\r\n    })();\r\n    const envelope = this.client.http.supportsLinkHeaders ? undefined : format;\r\n    params = params || {};\r\n    const _method = method.toLowerCase() as HttpMethods;\r\n    const headers =\r\n      _method == 'get'\r\n        ? Defaults.defaultGetHeaders(this.client.options, { format, protocolVersion: version })\r\n        : Defaults.defaultPostHeaders(this.client.options, { format, protocolVersion: version });\r\n\r\n    if (typeof body !== 'string') {\r\n      body = encoder(body) ?? null;\r\n    }\r\n    Utils.mixin(headers, this.client.options.headers);\r\n    if (customHeaders) {\r\n      Utils.mixin(headers, customHeaders);\r\n    }\r\n    const paginatedResource = new PaginatedResource(\r\n      this.client,\r\n      path,\r\n      headers,\r\n      envelope,\r\n      async function (resbody, headers, unpacked) {\r\n        return Utils.ensureArray(unpacked ? resbody : decoder(resbody as string & Buffer));\r\n      },\r\n      /* useHttpPaginatedResponse: */ true,\r\n    );\r\n\r\n    if (!Platform.Http.methods.includes(_method)) {\r\n      throw new ErrorInfo('Unsupported method ' + _method, 40500, 405);\r\n    }\r\n\r\n    if (Platform.Http.methodsWithBody.includes(_method)) {\r\n      return paginatedResource[_method as HttpMethods.Post](params, body as RequestBody) as Promise<\r\n        HttpPaginatedResponse<unknown>\r\n      >;\r\n    } else {\r\n      return paginatedResource[_method as HttpMethods.Get | HttpMethods.Delete](params) as Promise<\r\n        HttpPaginatedResponse<unknown>\r\n      >;\r\n    }\r\n  }\r\n\r\n  async batchPublish<T extends BatchPublishSpec | BatchPublishSpec[]>(\r\n    specOrSpecs: T,\r\n  ): Promise<T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[]> {\r\n    let requestBodyDTO: BatchPublishSpec[];\r\n    let singleSpecMode: boolean;\r\n    if (Array.isArray(specOrSpecs)) {\r\n      requestBodyDTO = specOrSpecs;\r\n      singleSpecMode = false;\r\n    } else {\r\n      requestBodyDTO = [specOrSpecs];\r\n      singleSpecMode = true;\r\n    }\r\n\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const requestBody = Utils.encodeBody(requestBodyDTO, this.client._MsgPack, format);\r\n\r\n    const response = await Resource.post(this.client, '/messages', requestBody, headers, {}, null, true);\r\n\r\n    const batchResults = (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as BatchPublishResult[];\r\n\r\n    // I don't love the below type assertions but not sure how to avoid them\r\n    if (singleSpecMode) {\r\n      return batchResults[0] as T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[];\r\n    } else {\r\n      return batchResults as T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[];\r\n    }\r\n  }\r\n\r\n  async batchPresence(channels: string[]): Promise<BatchPresenceResult> {\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const channelsParam = channels.join(',');\r\n\r\n    const response = await Resource.get(this.client, '/presence', headers, { channels: channelsParam }, null, true);\r\n\r\n    return (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as BatchPresenceResult;\r\n  }\r\n\r\n  async revokeTokens(\r\n    specifiers: TokenRevocationTargetSpecifier[],\r\n    options?: TokenRevocationOptions,\r\n  ): Promise<TokenRevocationResult> {\r\n    if (useTokenAuth(this.client.options)) {\r\n      throw new ErrorInfo('Cannot revoke tokens when using token auth', 40162, 401);\r\n    }\r\n\r\n    const keyName = this.client.options.keyName!;\r\n\r\n    let resolvedOptions = options ?? {};\r\n\r\n    const requestBodyDTO = {\r\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`),\r\n      ...resolvedOptions,\r\n    };\r\n\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const requestBody = Utils.encodeBody(requestBodyDTO, this.client._MsgPack, format);\r\n\r\n    const response = await Resource.post(\r\n      this.client,\r\n      `/keys/${keyName}/revokeTokens`,\r\n      requestBody,\r\n      headers,\r\n      {},\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as TokenRevocationResult;\r\n  }\r\n}\r\n\r\nclass Channels {\r\n  client: BaseClient;\r\n  all: Record<string, RestChannel>;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.all = Object.create(null);\r\n  }\r\n\r\n  get(name: string, channelOptions?: ChannelOptions) {\r\n    name = String(name);\r\n    let channel = this.all[name];\r\n    if (!channel) {\r\n      this.all[name] = channel = new RestChannel(this.client, name, channelOptions);\r\n    } else if (channelOptions) {\r\n      channel.setOptions(channelOptions);\r\n    }\r\n\r\n    return channel;\r\n  }\r\n\r\n  /* Included to support certain niche use-cases; most users should ignore this.\r\n   * Please do not use this unless you know what you're doing */\r\n  release(name: string) {\r\n    delete this.all[String(name)];\r\n  }\r\n}\r\n", "import BaseClient from './baseclient';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { Rest } from './rest';\r\nimport Defaults from '../util/defaults';\r\nimport Logger from '../util/logger';\r\n\r\n/**\r\n `BaseRest` is an export of the tree-shakable version of the SDK, and acts as the base class for the `DefaultRest` class exported by the non tree-shakable version.\r\n\r\n It always includes the `Rest` plugin.\r\n */\r\nexport class BaseRest extends BaseClient {\r\n  /*\r\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\r\n   *\r\n   * 1. passes a string (which is quite likely if they\u2019re e.g. migrating from the default variant to the modular variant)\r\n   * 2. passes no argument at all\r\n   *\r\n   * tell the compiler that these cases are possible so that it forces us to handle them.\r\n   */\r\n  constructor(options?: ClientOptions | string) {\r\n    super(Defaults.objectifyOptions(options, false, 'BaseRest', Logger.defaultLogger, { Rest }));\r\n  }\r\n}\r\n", "import { Rest } from './rest';\r\nimport { IUntypedCryptoStatic } from '../../types/ICryptoStatic';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport RealtimePresence from './realtimepresence';\r\nimport XHRRequest from 'platform/web/lib/http/request/xhrrequest';\r\nimport fetchRequest from 'platform/web/lib/http/request/fetchrequest';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\nimport {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from '../types/presencemessage';\r\nimport { TransportCtor } from '../transport/transport';\r\n\r\nexport interface PresenceMessagePlugin {\r\n  presenceMessageFromValues: typeof presenceMessageFromValues;\r\n  presenceMessagesFromValuesArray: typeof presenceMessagesFromValuesArray;\r\n}\r\n\r\nexport type RealtimePresencePlugin = PresenceMessagePlugin & {\r\n  RealtimePresence: typeof RealtimePresence;\r\n};\r\n\r\nexport interface ModularPlugins {\r\n  Rest?: typeof Rest;\r\n  Crypto?: IUntypedCryptoStatic;\r\n  MsgPack?: MsgPack;\r\n  RealtimePresence?: RealtimePresencePlugin;\r\n  WebSocketTransport?: TransportCtor;\r\n  XHRPolling?: TransportCtor;\r\n  XHRRequest?: typeof XHRRequest;\r\n  FetchRequest?: typeof fetchRequest;\r\n  MessageInteractions?: typeof FilteredSubscriptions;\r\n}\r\n\r\nexport const allCommonModularPlugins: ModularPlugins = { Rest };\r\n", "import Message, {\r\n  CipherOptions,\r\n  fromEncoded,\r\n  fromEncodedArray,\r\n  encode,\r\n  decode,\r\n  EncodingDecodingContext,\r\n} from './message';\r\nimport * as API from '../../../../ably';\r\nimport Platform from 'common/platform';\r\nimport PresenceMessage from './presencemessage';\r\nimport { ChannelOptions } from 'common/types/channel';\r\nimport Logger from '../util/logger';\r\n\r\n/**\r\n `DefaultMessage` is the class returned by `DefaultRest` and `DefaultRealtime`\u2019s `Message` static property. It introduces the static methods described in the `MessageStatic` interface of the public API of the non tree-shakable version of the library.\r\n */\r\nexport class DefaultMessage extends Message {\r\n  static async fromEncoded(encoded: unknown, inputOptions?: API.ChannelOptions): Promise<Message> {\r\n    return fromEncoded(Logger.defaultLogger, Platform.Crypto, encoded, inputOptions);\r\n  }\r\n\r\n  static async fromEncodedArray(encodedArray: Array<unknown>, options?: API.ChannelOptions): Promise<Message[]> {\r\n    return fromEncodedArray(Logger.defaultLogger, Platform.Crypto, encodedArray, options);\r\n  }\r\n\r\n  // Used by tests\r\n  static fromValues(values: unknown): Message {\r\n    return Object.assign(new Message(), values);\r\n  }\r\n\r\n  // Used by tests\r\n  static async encode<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\r\n    return encode(msg, options);\r\n  }\r\n\r\n  // Used by tests\r\n  static async decode(\r\n    message: Message | PresenceMessage,\r\n    inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\r\n  ): Promise<void> {\r\n    return decode(message, inputContext);\r\n  }\r\n}\r\n", "import * as API from '../../../../ably';\r\nimport Logger from '../util/logger';\r\nimport PresenceMessage, { fromEncoded, fromEncodedArray, fromValues } from './presencemessage';\r\n\r\n/**\r\n `DefaultPresenceMessage` is the class returned by `DefaultRest` and `DefaultRealtime`\u2019s `PresenceMessage` static property. It introduces the static methods described in the `PresenceMessageStatic` interface of the public API of the non tree-shakable version of the library.\r\n */\r\nexport class DefaultPresenceMessage extends PresenceMessage {\r\n  static async fromEncoded(encoded: unknown, inputOptions?: API.ChannelOptions): Promise<PresenceMessage> {\r\n    return fromEncoded(Logger.defaultLogger, encoded, inputOptions);\r\n  }\r\n\r\n  static async fromEncodedArray(\r\n    encodedArray: Array<unknown>,\r\n    options?: API.ChannelOptions,\r\n  ): Promise<PresenceMessage[]> {\r\n    return fromEncodedArray(Logger.defaultLogger, encodedArray, options);\r\n  }\r\n\r\n  static fromValues(values: PresenceMessage | Record<string, unknown>, stringifyAction?: boolean): PresenceMessage {\r\n    return fromValues(values, stringifyAction);\r\n  }\r\n}\r\n", "import { BaseRest } from './baserest';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { allCommonModularPlugins } from './modularplugins';\r\nimport Platform from 'common/platform';\r\nimport { DefaultMessage } from '../types/defaultmessage';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { DefaultPresenceMessage } from '../types/defaultpresencemessage';\r\nimport { Http } from 'common/types/http';\r\nimport Defaults from '../util/defaults';\r\nimport Logger from '../util/logger';\r\n\r\n/**\r\n `DefaultRest` is the class that the non tree-shakable version of the SDK exports as `Rest`. It ensures that this version of the SDK includes all of the functionality which is optionally available in the tree-shakable version.\r\n */\r\nexport class DefaultRest extends BaseRest {\r\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\r\n  constructor(options?: ClientOptions | string) {\r\n    const MsgPack = DefaultRest._MsgPack;\r\n    if (!MsgPack) {\r\n      throw new Error('Expected DefaultRest._MsgPack to have been set');\r\n    }\r\n\r\n    super(\r\n      Defaults.objectifyOptions(options, true, 'Rest', Logger.defaultLogger, {\r\n        ...allCommonModularPlugins,\r\n        Crypto: DefaultRest.Crypto ?? undefined,\r\n        MsgPack: DefaultRest._MsgPack ?? undefined,\r\n      }),\r\n    );\r\n  }\r\n\r\n  private static _Crypto: typeof Platform.Crypto = null;\r\n  static get Crypto() {\r\n    if (this._Crypto === null) {\r\n      throw new Error('Encryption not enabled; use ably.encryption.js instead');\r\n    }\r\n\r\n    return this._Crypto;\r\n  }\r\n  static set Crypto(newValue: typeof Platform.Crypto) {\r\n    this._Crypto = newValue;\r\n  }\r\n\r\n  static Message = DefaultMessage;\r\n  static PresenceMessage = DefaultPresenceMessage;\r\n\r\n  static _MsgPack: MsgPack | null = null;\r\n\r\n  // Used by tests\r\n  static _Http = Http;\r\n}\r\n", "import * as Utils from './utils';\r\nimport Logger from './logger';\r\nimport Platform from 'common/platform';\r\n\r\n/* Call the listener, catch any exceptions and log, but continue operation*/\r\nfunction callListener(logger: Logger, eventThis: { event: string }, listener: Function, args: unknown[]) {\r\n  try {\r\n    listener.apply(eventThis, args);\r\n  } catch (e) {\r\n    Logger.logAction(\r\n      logger,\r\n      Logger.LOG_ERROR,\r\n      'EventEmitter.emit()',\r\n      'Unexpected listener exception: ' + e + '; stack = ' + (e && (e as Error).stack),\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Remove listeners that match listener\r\n * @param targetListeners is an array of listener arrays or event objects with arrays of listeners\r\n * @param listener the listener callback to remove\r\n * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event\r\n */\r\nfunction removeListener(targetListeners: any, listener: Function, eventFilter?: string) {\r\n  let listeners: Record<string, unknown>;\r\n  let index;\r\n  let eventName;\r\n\r\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\r\n    listeners = targetListeners[targetListenersIndex];\r\n    if (eventFilter) {\r\n      listeners = listeners[eventFilter] as Record<string, unknown>;\r\n    }\r\n\r\n    if (Array.isArray(listeners)) {\r\n      while ((index = listeners.indexOf(listener)) !== -1) {\r\n        listeners.splice(index, 1);\r\n      }\r\n      /* If events object has an event name key with no listeners then\r\n\t\t\t\t\tremove the key to stop the list growing indefinitely */\r\n      if (eventFilter && listeners.length === 0) {\r\n        delete targetListeners[targetListenersIndex][eventFilter];\r\n      }\r\n    } else if (Utils.isObject(listeners)) {\r\n      /* events */\r\n      for (eventName in listeners) {\r\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\r\n          removeListener([listeners], listener, eventName);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass EventEmitter {\r\n  any: Array<Function>;\r\n  events: Record<string, Array<Function>>;\r\n  anyOnce: Array<Function>;\r\n  eventsOnce: Record<string, Array<Function>>;\r\n\r\n  constructor(readonly logger: Logger) {\r\n    this.any = [];\r\n    this.events = Object.create(null);\r\n    this.anyOnce = [];\r\n    this.eventsOnce = Object.create(null);\r\n  }\r\n\r\n  /**\r\n   * Add an event listener\r\n   * @param listener the listener to be called\r\n   */\r\n  on(listener: Function): void;\r\n\r\n  /**\r\n   * Add an event listener\r\n   * @param event (optional) the name of the event to listen to\r\n   * @param listener the listener to be called\r\n   */\r\n  on(event: null | string | string[], listener: Function): void;\r\n\r\n  on(...args: unknown[]) {\r\n    if (args.length === 1) {\r\n      const listener = args[0];\r\n      if (typeof listener === 'function') {\r\n        this.any.push(listener);\r\n      } else {\r\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n      }\r\n    }\r\n    if (args.length === 2) {\r\n      const [event, listener] = args;\r\n      if (typeof listener !== 'function') {\r\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n      }\r\n      if (Utils.isNil(event)) {\r\n        this.any.push(listener);\r\n      } else if (Array.isArray(event)) {\r\n        event.forEach((eventName) => {\r\n          this.on(eventName, listener);\r\n        });\r\n      } else {\r\n        if (typeof event !== 'string') {\r\n          throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n        }\r\n        const listeners = this.events[event] || (this.events[event] = []);\r\n        listeners.push(listener);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove one or more event listeners\r\n   * @param listener (optional) the listener to remove. If not\r\n   *        supplied, all listeners are removed.\r\n   */\r\n  off(listener?: Function): void;\r\n\r\n  /**\r\n   * Remove one or more event listeners\r\n   * @param event (optional) the name of the event whose listener\r\n   *        is to be removed. If not supplied, the listener is\r\n   *        treated as an 'any' listener\r\n   * @param listener (optional) the listener to remove. If not\r\n   *        supplied, all listeners are removed.\r\n   */\r\n  off(event: string | string[] | null, listener?: Function | null): void;\r\n\r\n  off(...args: unknown[]) {\r\n    if (args.length == 0 || (Utils.isNil(args[0]) && Utils.isNil(args[1]))) {\r\n      this.any = [];\r\n      this.events = Object.create(null);\r\n      this.anyOnce = [];\r\n      this.eventsOnce = Object.create(null);\r\n      return;\r\n    }\r\n    const [firstArg, secondArg] = args;\r\n    let listener: Function | null = null;\r\n    let event: unknown = null;\r\n    if (args.length === 1 || !secondArg) {\r\n      if (typeof firstArg === 'function') {\r\n        /* we take this to be the listener and treat the event as \"any\" .. */\r\n        listener = firstArg;\r\n      } else {\r\n        event = firstArg;\r\n      }\r\n      /* ... or we take event to be the actual event name and listener to be all */\r\n    } else {\r\n      if (typeof secondArg !== 'function') {\r\n        throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      [event, listener] = [firstArg, secondArg];\r\n    }\r\n\r\n    if (listener && Utils.isNil(event)) {\r\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\r\n      return;\r\n    }\r\n\r\n    if (Array.isArray(event)) {\r\n      event.forEach((eventName) => {\r\n        this.off(eventName, listener);\r\n      });\r\n      return;\r\n    }\r\n\r\n    /* \"normal\" case where event is an actual event */\r\n    if (typeof event !== 'string') {\r\n      throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\r\n    }\r\n    if (listener) {\r\n      removeListener([this.events, this.eventsOnce], listener, event);\r\n    } else {\r\n      delete this.events[event];\r\n      delete this.eventsOnce[event];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the array of listeners for a given event; excludes once events\r\n   * @param event (optional) the name of the event, or none for 'any'\r\n   * @return array of events, or null if none\r\n   */\r\n  listeners(event: string) {\r\n    if (event) {\r\n      const listeners = this.events[event] || [];\r\n      if (this.eventsOnce[event]) Array.prototype.push.apply(listeners, this.eventsOnce[event]);\r\n      return listeners.length ? listeners : null;\r\n    }\r\n    return this.any.length ? this.any : null;\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   * @param event the event name\r\n   * @param args the arguments to pass to the listener\r\n   */\r\n  emit(event: string, ...args: unknown[] /* , args... */) {\r\n    const eventThis = { event };\r\n    const listeners: Function[] = [];\r\n\r\n    if (this.anyOnce.length) {\r\n      Array.prototype.push.apply(listeners, this.anyOnce);\r\n      this.anyOnce = [];\r\n    }\r\n    if (this.any.length) {\r\n      Array.prototype.push.apply(listeners, this.any);\r\n    }\r\n    const eventsOnceListeners = this.eventsOnce[event];\r\n    if (eventsOnceListeners) {\r\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\r\n      delete this.eventsOnce[event];\r\n    }\r\n    const eventsListeners = this.events[event];\r\n    if (eventsListeners) {\r\n      Array.prototype.push.apply(listeners, eventsListeners);\r\n    }\r\n\r\n    listeners.forEach((listener) => {\r\n      callListener(this.logger, eventThis, listener, args);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Listen for a single occurrence of an event\r\n   * @param event the name of the event to listen to\r\n   */\r\n  once(event: string): Promise<void>;\r\n\r\n  /**\r\n   * Listen for a single occurrence of any event\r\n   * @param listener the listener to be called\r\n   */\r\n  once(listener: Function): void;\r\n\r\n  /**\r\n   * Listen for a single occurrence of an event\r\n   * @param event the name of the event to listen to\r\n   * @param listener the listener to be called\r\n   */\r\n  once(event?: string | string[] | null, listener?: Function): void;\r\n\r\n  once(...args: unknown[]): void | Promise<void> {\r\n    const argCount = args.length;\r\n    if (argCount === 0 || (argCount === 1 && typeof args[0] !== 'function')) {\r\n      const event = args[0];\r\n      return new Promise((resolve) => {\r\n        this.once(event as string | string[] | null, resolve);\r\n      });\r\n    }\r\n\r\n    const [firstArg, secondArg] = args;\r\n    if (args.length === 1 && typeof firstArg === 'function') {\r\n      this.anyOnce.push(firstArg);\r\n    } else if (Utils.isNil(firstArg)) {\r\n      if (typeof secondArg !== 'function') {\r\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      this.anyOnce.push(secondArg);\r\n    } else if (Array.isArray(firstArg)) {\r\n      const self = this;\r\n      const listenerWrapper = function (this: any) {\r\n        const innerArgs = Array.prototype.slice.call(arguments);\r\n        firstArg.forEach(function (eventName) {\r\n          self.off(eventName, listenerWrapper);\r\n        });\r\n        if (typeof secondArg !== 'function') {\r\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n        }\r\n        secondArg.apply(this, innerArgs);\r\n      };\r\n      firstArg.forEach(function (eventName) {\r\n        self.on(eventName, listenerWrapper);\r\n      });\r\n    } else {\r\n      if (typeof firstArg !== 'string') {\r\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\r\n      if (secondArg) {\r\n        if (typeof secondArg !== 'function') {\r\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n        }\r\n        listeners.push(secondArg);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\r\n   * @param targetState the name of the state event to listen to\r\n   * @param currentState the name of the current state of this object\r\n   */\r\n  async whenState(targetState: string, currentState: string) {\r\n    if (typeof targetState !== 'string' || typeof currentState !== 'string') {\r\n      throw new Error('whenState requires a valid state String argument');\r\n    }\r\n    if (targetState === currentState) {\r\n      return null;\r\n    } else {\r\n      return this.once(targetState);\r\n    }\r\n  }\r\n}\r\n\r\nexport default EventEmitter;\r\n", "import { MsgPack } from 'common/types/msgpack';\r\nimport * as API from '../../../../ably';\r\nimport { PresenceMessagePlugin } from '../client/modularplugins';\r\nimport * as Utils from '../util/utils';\r\nimport ErrorInfo from './errorinfo';\r\nimport Message, { fromValues as messageFromValues, fromValuesArray as messagesFromValuesArray } from './message';\r\nimport PresenceMessage, {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from './presencemessage';\r\n\r\nexport const actions = {\r\n  HEARTBEAT: 0,\r\n  ACK: 1,\r\n  NACK: 2,\r\n  CONNECT: 3,\r\n  CONNECTED: 4,\r\n  DISCONNECT: 5,\r\n  DISCONNECTED: 6,\r\n  CLOSE: 7,\r\n  CLOSED: 8,\r\n  ERROR: 9,\r\n  ATTACH: 10,\r\n  ATTACHED: 11,\r\n  DETACH: 12,\r\n  DETACHED: 13,\r\n  PRESENCE: 14,\r\n  MESSAGE: 15,\r\n  SYNC: 16,\r\n  AUTH: 17,\r\n  ACTIVATE: 18,\r\n};\r\n\r\nexport const ActionName: string[] = [];\r\nObject.keys(actions).forEach(function (name) {\r\n  ActionName[(actions as { [key: string]: number })[name]] = name;\r\n});\r\n\r\nconst flags: { [key: string]: number } = {\r\n  /* Channel attach state flags */\r\n  HAS_PRESENCE: 1 << 0,\r\n  HAS_BACKLOG: 1 << 1,\r\n  RESUMED: 1 << 2,\r\n  TRANSIENT: 1 << 4,\r\n  ATTACH_RESUME: 1 << 5,\r\n  /* Channel mode flags */\r\n  PRESENCE: 1 << 16,\r\n  PUBLISH: 1 << 17,\r\n  SUBSCRIBE: 1 << 18,\r\n  PRESENCE_SUBSCRIBE: 1 << 19,\r\n};\r\nconst flagNames = Object.keys(flags);\r\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;\r\n\r\nfunction toStringArray(array?: any[]): string {\r\n  const result = [];\r\n  if (array) {\r\n    for (let i = 0; i < array.length; i++) {\r\n      result.push(array[i].toString());\r\n    }\r\n  }\r\n  return '[ ' + result.join(', ') + ' ]';\r\n}\r\n\r\nexport const channelModes = ['PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE'];\r\n\r\nexport const serialize = Utils.encodeBody;\r\n\r\nexport function deserialize(\r\n  serialized: unknown,\r\n  MsgPack: MsgPack | null,\r\n  presenceMessagePlugin: PresenceMessagePlugin | null,\r\n  format?: Utils.Format,\r\n): ProtocolMessage {\r\n  const deserialized = Utils.decodeBody<Record<string, unknown>>(serialized, MsgPack, format);\r\n  return fromDeserialized(deserialized, presenceMessagePlugin);\r\n}\r\n\r\nexport function fromDeserialized(\r\n  deserialized: Record<string, unknown>,\r\n  presenceMessagePlugin: PresenceMessagePlugin | null,\r\n): ProtocolMessage {\r\n  const error = deserialized.error;\r\n  if (error) deserialized.error = ErrorInfo.fromValues(error as ErrorInfo);\r\n  const messages = deserialized.messages as Message[];\r\n  if (messages) for (let i = 0; i < messages.length; i++) messages[i] = messageFromValues(messages[i]);\r\n\r\n  const presence = presenceMessagePlugin ? (deserialized.presence as PresenceMessage[]) : undefined;\r\n  if (presenceMessagePlugin) {\r\n    if (presence && presenceMessagePlugin)\r\n      for (let i = 0; i < presence.length; i++)\r\n        presence[i] = presenceMessagePlugin.presenceMessageFromValues(presence[i], true);\r\n  }\r\n  return Object.assign(new ProtocolMessage(), { ...deserialized, presence });\r\n}\r\n\r\n/**\r\n * Used by the tests.\r\n */\r\nexport function fromDeserializedIncludingDependencies(deserialized: Record<string, unknown>): ProtocolMessage {\r\n  return fromDeserialized(deserialized, { presenceMessageFromValues, presenceMessagesFromValuesArray });\r\n}\r\n\r\nexport function fromValues(values: unknown): ProtocolMessage {\r\n  return Object.assign(new ProtocolMessage(), values);\r\n}\r\n\r\nexport function stringify(msg: any, presenceMessagePlugin: PresenceMessagePlugin | null): string {\r\n  let result = '[ProtocolMessage';\r\n  if (msg.action !== undefined) result += '; action=' + ActionName[msg.action] || msg.action;\r\n\r\n  const simpleAttributes = ['id', 'channel', 'channelSerial', 'connectionId', 'count', 'msgSerial', 'timestamp'];\r\n  let attribute;\r\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\r\n    attribute = simpleAttributes[attribIndex];\r\n    if (msg[attribute] !== undefined) result += '; ' + attribute + '=' + msg[attribute];\r\n  }\r\n\r\n  if (msg.messages) result += '; messages=' + toStringArray(messagesFromValuesArray(msg.messages));\r\n  if (msg.presence && presenceMessagePlugin)\r\n    result += '; presence=' + toStringArray(presenceMessagePlugin.presenceMessagesFromValuesArray(msg.presence));\r\n  if (msg.error) result += '; error=' + ErrorInfo.fromValues(msg.error).toString();\r\n  if (msg.auth && msg.auth.accessToken) result += '; token=' + msg.auth.accessToken;\r\n  if (msg.flags) result += '; flags=' + flagNames.filter(msg.hasFlag).join(',');\r\n  if (msg.params) {\r\n    let stringifiedParams = '';\r\n    Utils.forInOwnNonNullProperties(msg.params, function (prop: string) {\r\n      if (stringifiedParams.length > 0) {\r\n        stringifiedParams += '; ';\r\n      }\r\n      stringifiedParams += prop + '=' + msg.params[prop];\r\n    });\r\n    if (stringifiedParams.length > 0) {\r\n      result += '; params=[' + stringifiedParams + ']';\r\n    }\r\n  }\r\n  result += ']';\r\n  return result;\r\n}\r\n\r\nclass ProtocolMessage {\r\n  action?: number;\r\n  flags?: number;\r\n  id?: string;\r\n  timestamp?: number;\r\n  count?: number;\r\n  error?: ErrorInfo;\r\n  connectionId?: string;\r\n  channel?: string;\r\n  channelSerial?: string | null;\r\n  msgSerial?: number;\r\n  messages?: Message[];\r\n  // This will be undefined if we skipped decoding this property due to user not requesting presence functionality \u2014 see `fromDeserialized`\r\n  presence?: PresenceMessage[];\r\n  auth?: unknown;\r\n  connectionDetails?: Record<string, unknown>;\r\n\r\n  hasFlag = (flag: string): boolean => {\r\n    return ((this.flags as number) & flags[flag]) > 0;\r\n  };\r\n\r\n  setFlag(flag: API.ChannelMode): number {\r\n    return (this.flags = (this.flags as number) | flags[flag]);\r\n  }\r\n\r\n  getMode(): number | undefined {\r\n    return this.flags && this.flags & flags.MODE_ALL;\r\n  }\r\n\r\n  encodeModesToFlags(modes: API.ChannelMode[]): void {\r\n    modes.forEach((mode) => this.setFlag(mode));\r\n  }\r\n\r\n  decodeModesFromFlags(): string[] | undefined {\r\n    const modes: string[] = [];\r\n    channelModes.forEach((mode) => {\r\n      if (this.hasFlag(mode)) {\r\n        modes.push(mode);\r\n      }\r\n    });\r\n    return modes.length > 0 ? modes : undefined;\r\n  }\r\n}\r\n\r\nexport default ProtocolMessage;\r\n", "import ErrorInfo from '../types/errorinfo';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport { PendingMessage } from './protocol';\r\n\r\nclass MessageQueue extends EventEmitter {\r\n  messages: Array<PendingMessage>;\r\n\r\n  constructor(logger: Logger) {\r\n    super(logger);\r\n    this.messages = [];\r\n  }\r\n\r\n  count(): number {\r\n    return this.messages.length;\r\n  }\r\n\r\n  push(message: PendingMessage): void {\r\n    this.messages.push(message);\r\n  }\r\n\r\n  shift(): PendingMessage | undefined {\r\n    return this.messages.shift();\r\n  }\r\n\r\n  last(): PendingMessage {\r\n    return this.messages[this.messages.length - 1];\r\n  }\r\n\r\n  copyAll(): PendingMessage[] {\r\n    return this.messages.slice();\r\n  }\r\n\r\n  append(messages: Array<PendingMessage>): void {\r\n    this.messages.push.apply(this.messages, messages);\r\n  }\r\n\r\n  prepend(messages: Array<PendingMessage>): void {\r\n    this.messages.unshift.apply(this.messages, messages);\r\n  }\r\n\r\n  completeMessages(serial: number, count: number, err?: ErrorInfo | null): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'MessageQueue.completeMessages()',\r\n      'serial = ' + serial + '; count = ' + count,\r\n    );\r\n    err = err || null;\r\n    const messages = this.messages;\r\n    if (messages.length === 0) {\r\n      throw new Error('MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue');\r\n    }\r\n    const first = messages[0];\r\n    if (first) {\r\n      const startSerial = first.message.msgSerial as number;\r\n      const endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */\r\n      if (endSerial > startSerial) {\r\n        const completeMessages = messages.splice(0, endSerial - startSerial);\r\n        for (const message of completeMessages) {\r\n          (message.callback as Function)(err);\r\n        }\r\n      }\r\n      if (messages.length == 0) this.emit('idle');\r\n    }\r\n  }\r\n\r\n  completeAllMessages(err: ErrorInfo): void {\r\n    this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\r\n  }\r\n\r\n  resetSendAttempted(): void {\r\n    for (let msg of this.messages) {\r\n      msg.sendAttempted = false;\r\n    }\r\n  }\r\n\r\n  clear(): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'MessageQueue.clear()',\r\n      'clearing ' + this.messages.length + ' messages',\r\n    );\r\n    this.messages = [];\r\n    this.emit('idle');\r\n  }\r\n}\r\n\r\nexport default MessageQueue;\r\n", "import ProtocolMessage, { actions, stringify as stringifyProtocolMessage } from '../types/protocolmessage';\r\nimport * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport MessageQueue from './messagequeue';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Transport from './transport';\r\nimport { ErrCallback } from '../../types/utils';\r\n\r\nexport class PendingMessage {\r\n  message: ProtocolMessage;\r\n  callback?: ErrCallback;\r\n  merged: boolean;\r\n  sendAttempted: boolean;\r\n  ackRequired: boolean;\r\n\r\n  constructor(message: ProtocolMessage, callback?: ErrCallback) {\r\n    this.message = message;\r\n    this.callback = callback;\r\n    this.merged = false;\r\n    const action = message.action;\r\n    this.sendAttempted = false;\r\n    this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE;\r\n  }\r\n}\r\n\r\nclass Protocol extends EventEmitter {\r\n  transport: Transport;\r\n  messageQueue: MessageQueue;\r\n\r\n  constructor(transport: Transport) {\r\n    super(transport.logger);\r\n    this.transport = transport;\r\n    this.messageQueue = new MessageQueue(this.logger);\r\n    transport.on('ack', (serial: number, count: number) => {\r\n      this.onAck(serial, count);\r\n    });\r\n    transport.on('nack', (serial: number, count: number, err: ErrorInfo) => {\r\n      this.onNack(serial, count, err);\r\n    });\r\n  }\r\n\r\n  onAck(serial: number, count: number): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);\r\n    this.messageQueue.completeMessages(serial, count);\r\n  }\r\n\r\n  onNack(serial: number, count: number, err: ErrorInfo): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_ERROR,\r\n      'Protocol.onNack()',\r\n      'serial = ' + serial + '; count = ' + count + '; err = ' + Utils.inspectError(err),\r\n    );\r\n    if (!err) {\r\n      err = new ErrorInfo('Unable to send message; channel not responding', 50001, 500);\r\n    }\r\n    this.messageQueue.completeMessages(serial, count, err);\r\n  }\r\n\r\n  onceIdle(listener: ErrCallback): void {\r\n    const messageQueue = this.messageQueue;\r\n    if (messageQueue.count() === 0) {\r\n      listener();\r\n      return;\r\n    }\r\n    messageQueue.once('idle', listener);\r\n  }\r\n\r\n  send(pendingMessage: PendingMessage): void {\r\n    if (pendingMessage.ackRequired) {\r\n      this.messageQueue.push(pendingMessage);\r\n    }\r\n    if (this.logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logActionNoStrip(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'Protocol.send()',\r\n        'sending msg; ' +\r\n          stringifyProtocolMessage(pendingMessage.message, this.transport.connectionManager.realtime._RealtimePresence),\r\n      );\r\n    }\r\n    pendingMessage.sendAttempted = true;\r\n    this.transport.send(pendingMessage.message);\r\n  }\r\n\r\n  getTransport(): Transport {\r\n    return this.transport;\r\n  }\r\n\r\n  getPendingMessages(): PendingMessage[] {\r\n    return this.messageQueue.copyAll();\r\n  }\r\n\r\n  clearPendingMessages(): void {\r\n    return this.messageQueue.clear();\r\n  }\r\n\r\n  finish(): void {\r\n    const transport = this.transport;\r\n    this.onceIdle(function () {\r\n      transport.disconnect();\r\n    });\r\n  }\r\n}\r\n\r\nexport default Protocol;\r\n", "import { IPartialErrorInfo } from '../types/errorinfo';\r\n\r\nclass ConnectionStateChange {\r\n  previous?: string;\r\n  current?: string;\r\n  retryIn?: number;\r\n  reason?: IPartialErrorInfo;\r\n\r\n  constructor(previous?: string, current?: string, retryIn?: number | null, reason?: IPartialErrorInfo) {\r\n    this.previous = previous;\r\n    this.current = current;\r\n    if (retryIn) this.retryIn = retryIn;\r\n    if (reason) this.reason = reason;\r\n  }\r\n}\r\n\r\nexport default ConnectionStateChange;\r\n", "import ErrorInfo from '../types/errorinfo';\r\n\r\nconst ConnectionErrorCodes = {\r\n  DISCONNECTED: 80003,\r\n  SUSPENDED: 80002,\r\n  FAILED: 80000,\r\n  CLOSING: 80017,\r\n  CLOSED: 80017,\r\n  UNKNOWN_CONNECTION_ERR: 50002,\r\n  UNKNOWN_CHANNEL_ERR: 50001,\r\n};\r\n\r\nconst ConnectionErrors = {\r\n  disconnected: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 400,\r\n      code: ConnectionErrorCodes.DISCONNECTED,\r\n      message: 'Connection to server temporarily unavailable',\r\n    }),\r\n  suspended: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 400,\r\n      code: ConnectionErrorCodes.SUSPENDED,\r\n      message: 'Connection to server unavailable',\r\n    }),\r\n  failed: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 400,\r\n      code: ConnectionErrorCodes.FAILED,\r\n      message: 'Connection failed or disconnected by server',\r\n    }),\r\n  closing: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 400,\r\n      code: ConnectionErrorCodes.CLOSING,\r\n      message: 'Connection closing',\r\n    }),\r\n  closed: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 400,\r\n      code: ConnectionErrorCodes.CLOSED,\r\n      message: 'Connection closed',\r\n    }),\r\n  unknownConnectionErr: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 500,\r\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\r\n      message: 'Internal connection error',\r\n    }),\r\n  unknownChannelErr: () =>\r\n    ErrorInfo.fromValues({\r\n      statusCode: 500,\r\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\r\n      message: 'Internal channel error',\r\n    }),\r\n};\r\n\r\nexport function isRetriable(err: ErrorInfo) {\r\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\r\n    return true;\r\n  }\r\n  return Object.values(ConnectionErrorCodes).includes(err.code);\r\n}\r\n\r\nexport default ConnectionErrors;\r\n", "import ProtocolMessage, {\r\n  actions,\r\n  fromValues as protocolMessageFromValues,\r\n  stringify as stringifyProtocolMessage,\r\n} from '../types/protocolmessage';\r\nimport * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport ConnectionErrors from './connectionerrors';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Auth from '../client/auth';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport Platform from 'common/platform';\r\nimport TransportName from 'common/constants/TransportName';\r\n\r\nexport type TryConnectCallback = (\r\n  wrappedErr: { error: ErrorInfo; event: string } | null,\r\n  transport?: Transport,\r\n) => void;\r\n\r\nexport interface TransportCtor {\r\n  new (\r\n    connectionManager: ConnectionManager,\r\n    auth: Auth,\r\n    params: TransportParams,\r\n    forceJsonProtocol?: boolean,\r\n  ): Transport;\r\n\r\n  isAvailable(): boolean;\r\n}\r\n\r\nconst closeMessage = protocolMessageFromValues({ action: actions.CLOSE });\r\nconst disconnectMessage = protocolMessageFromValues({ action: actions.DISCONNECT });\r\n\r\n/*\r\n * Transport instances inherit from EventEmitter and emit the following events:\r\n *\r\n * event name       data\r\n * closed           error\r\n * failed           error\r\n * disposed\r\n * connected        null error, connectionSerial, connectionId, connectionDetails\r\n * event            channel message object\r\n */\r\n\r\nabstract class Transport extends EventEmitter {\r\n  connectionManager: ConnectionManager;\r\n  auth: Auth;\r\n  params: TransportParams;\r\n  timeouts: Record<string, number>;\r\n  format?: Utils.Format;\r\n  isConnected: boolean;\r\n  isFinished: boolean;\r\n  isDisposed: boolean;\r\n  maxIdleInterval: number | null;\r\n  idleTimer: NodeJS.Timeout | number | null;\r\n  lastActivity: number | null;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams, forceJsonProtocol?: boolean) {\r\n    super(connectionManager.logger);\r\n    if (forceJsonProtocol) {\r\n      params.format = undefined;\r\n      params.heartbeats = true;\r\n    }\r\n    this.connectionManager = connectionManager;\r\n    this.auth = auth;\r\n    this.params = params;\r\n    this.timeouts = params.options.timeouts;\r\n    this.format = params.format;\r\n    this.isConnected = false;\r\n    this.isFinished = false;\r\n    this.isDisposed = false;\r\n    this.maxIdleInterval = null;\r\n    this.idleTimer = null;\r\n    this.lastActivity = null;\r\n  }\r\n\r\n  abstract shortName: TransportName;\r\n  abstract send(message: ProtocolMessage): void;\r\n\r\n  connect(): void {}\r\n\r\n  close(): void {\r\n    if (this.isConnected) {\r\n      this.requestClose();\r\n    }\r\n    this.finish('closed', ConnectionErrors.closed());\r\n  }\r\n\r\n  disconnect(err?: Error | ErrorInfo): void {\r\n    /* Used for network/transport issues that need to result in the transport\r\n     * being disconnected, but should not transition the connection to 'failed' */\r\n    if (this.isConnected) {\r\n      this.requestDisconnect();\r\n    }\r\n    this.finish('disconnected', err || ConnectionErrors.disconnected());\r\n  }\r\n\r\n  fail(err: ErrorInfo): void {\r\n    /* Used for client-side-detected fatal connection issues */\r\n    if (this.isConnected) {\r\n      this.requestDisconnect();\r\n    }\r\n    this.finish('failed', err || ConnectionErrors.failed());\r\n  }\r\n\r\n  finish(event: string, err?: Error | ErrorInfo): void {\r\n    if (this.isFinished) {\r\n      return;\r\n    }\r\n\r\n    this.isFinished = true;\r\n    this.isConnected = false;\r\n    this.maxIdleInterval = null;\r\n    clearTimeout(this.idleTimer ?? undefined);\r\n    this.idleTimer = null;\r\n    this.emit(event, err);\r\n    this.dispose();\r\n  }\r\n\r\n  onProtocolMessage(message: ProtocolMessage): void {\r\n    if (this.logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logActionNoStrip(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'Transport.onProtocolMessage()',\r\n        'received on ' +\r\n          this.shortName +\r\n          ': ' +\r\n          stringifyProtocolMessage(message, this.connectionManager.realtime._RealtimePresence) +\r\n          '; connectionId = ' +\r\n          this.connectionManager.connectionId,\r\n      );\r\n    }\r\n    this.onActivity();\r\n\r\n    switch (message.action) {\r\n      case actions.HEARTBEAT:\r\n        Logger.logActionNoStrip(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          'Transport.onProtocolMessage()',\r\n          this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId,\r\n        );\r\n        this.emit('heartbeat', message.id);\r\n        break;\r\n      case actions.CONNECTED:\r\n        this.onConnect(message);\r\n        this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);\r\n        break;\r\n      case actions.CLOSED:\r\n        this.onClose(message);\r\n        break;\r\n      case actions.DISCONNECTED:\r\n        this.onDisconnect(message);\r\n        break;\r\n      case actions.ACK:\r\n        this.emit('ack', message.msgSerial, message.count);\r\n        break;\r\n      case actions.NACK:\r\n        this.emit('nack', message.msgSerial, message.count, message.error);\r\n        break;\r\n      case actions.SYNC:\r\n        this.connectionManager.onChannelMessage(message, this);\r\n        break;\r\n      case actions.ACTIVATE:\r\n        // Ignored.\r\n        break;\r\n      case actions.AUTH:\r\n        Utils.whenPromiseSettles(this.auth.authorize(), (err: ErrorInfo | null) => {\r\n          if (err) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_ERROR,\r\n              'Transport.onProtocolMessage()',\r\n              'Ably requested re-authentication, but unable to obtain a new token: ' + Utils.inspectError(err),\r\n            );\r\n          }\r\n        });\r\n        break;\r\n      case actions.ERROR:\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'Transport.onProtocolMessage()',\r\n          'received error action; connectionId = ' +\r\n            this.connectionManager.connectionId +\r\n            '; err = ' +\r\n            Platform.Config.inspect(message.error) +\r\n            (message.channel ? ', channel: ' + message.channel : ''),\r\n        );\r\n        if (message.channel === undefined) {\r\n          this.onFatalError(message);\r\n          break;\r\n        }\r\n        /* otherwise it's a channel-specific error, so handle it in the channel */\r\n        this.connectionManager.onChannelMessage(message, this);\r\n        break;\r\n      default:\r\n        /* all other actions are channel-specific */\r\n        this.connectionManager.onChannelMessage(message, this);\r\n    }\r\n  }\r\n\r\n  onConnect(message: ProtocolMessage): void {\r\n    this.isConnected = true;\r\n    if (!message.connectionDetails) {\r\n      throw new Error('Transport.onConnect(): Connect message recieved without connectionDetails');\r\n    }\r\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval as number;\r\n    if (maxPromisedIdle) {\r\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\r\n      this.onActivity();\r\n    }\r\n    /* else Realtime declines to guarantee any maximum idle interval - CD2h */\r\n  }\r\n\r\n  onDisconnect(message: ProtocolMessage): void {\r\n    /* Used for when the server has disconnected the client (usually with a\r\n     * DISCONNECTED action) */\r\n    const err = message && message.error;\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('disconnected', err);\r\n  }\r\n\r\n  onFatalError(message: ProtocolMessage): void {\r\n    /* On receipt of a fatal connection error, we can assume that the server\r\n     * will close the connection and the transport, and do not need to request\r\n     * a disconnection - RTN15i */\r\n    const err = message && message.error;\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.onFatalError()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('failed', err);\r\n  }\r\n\r\n  onClose(message: ProtocolMessage): void {\r\n    const err = message && message.error;\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.onClose()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('closed', err);\r\n  }\r\n\r\n  requestClose(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.requestClose()', '');\r\n    this.send(closeMessage);\r\n  }\r\n\r\n  requestDisconnect(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.requestDisconnect()', '');\r\n    this.send(disconnectMessage);\r\n  }\r\n\r\n  ping(id: string): void {\r\n    const msg: Record<string, number | string> = { action: actions.HEARTBEAT };\r\n    if (id) msg.id = id;\r\n    this.send(protocolMessageFromValues(msg));\r\n  }\r\n\r\n  dispose(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Transport.dispose()', '');\r\n    this.isDisposed = true;\r\n    this.off();\r\n  }\r\n\r\n  onActivity(): void {\r\n    if (!this.maxIdleInterval) {\r\n      return;\r\n    }\r\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\r\n    this.setIdleTimer(this.maxIdleInterval + 100);\r\n  }\r\n\r\n  setIdleTimer(timeout: number): void {\r\n    if (!this.idleTimer) {\r\n      this.idleTimer = setTimeout(() => {\r\n        this.onIdleTimerExpire();\r\n      }, timeout);\r\n    }\r\n  }\r\n\r\n  onIdleTimerExpire(): void {\r\n    if (!this.lastActivity || !this.maxIdleInterval) {\r\n      throw new Error('Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set');\r\n    }\r\n    this.idleTimer = null;\r\n    const sinceLast = Date.now() - this.lastActivity;\r\n    const timeRemaining = this.maxIdleInterval - sinceLast;\r\n    if (timeRemaining <= 0) {\r\n      const msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);\r\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\r\n    } else {\r\n      this.setIdleTimer(timeRemaining + 100);\r\n    }\r\n  }\r\n\r\n  static tryConnect(\r\n    transportCtor: TransportCtor,\r\n    connectionManager: ConnectionManager,\r\n    auth: Auth,\r\n    transportParams: TransportParams,\r\n    callback: TryConnectCallback,\r\n  ): Transport {\r\n    const transport = new transportCtor(connectionManager, auth, transportParams);\r\n\r\n    let transportAttemptTimer: NodeJS.Timeout | number;\r\n\r\n    const errorCb = function (this: { event: string }, err: ErrorInfo) {\r\n      clearTimeout(transportAttemptTimer);\r\n      callback({ event: this.event, error: err });\r\n    };\r\n\r\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\r\n    transportAttemptTimer = setTimeout(() => {\r\n      transport.off(['preconnect', 'disconnected', 'failed']);\r\n      transport.dispose();\r\n      errorCb.call(\r\n        { event: 'disconnected' },\r\n        new ErrorInfo('Timeout waiting for transport to indicate itself viable', 50000, 500),\r\n      );\r\n    }, realtimeRequestTimeout);\r\n\r\n    transport.on(['failed', 'disconnected'], errorCb);\r\n    transport.on('preconnect', function () {\r\n      Logger.logAction(\r\n        connectionManager.logger,\r\n        Logger.LOG_MINOR,\r\n        'Transport.tryConnect()',\r\n        'viable transport ' + transport,\r\n      );\r\n      clearTimeout(transportAttemptTimer);\r\n      transport.off(['failed', 'disconnected'], errorCb);\r\n      callback(null, transport);\r\n    });\r\n    transport.connect();\r\n    return transport;\r\n  }\r\n\r\n  onAuthUpdated?: (tokenDetails: API.TokenDetails) => void;\r\n\r\n  static isAvailable(): boolean {\r\n    throw new ErrorInfo('isAvailable not implemented for transport', 50000, 500);\r\n  }\r\n}\r\n\r\nexport default Transport;\r\n", "export namespace TransportNames {\r\n  export const WebSocket = 'web_socket' as const;\r\n  export const Comet = 'comet' as const;\r\n  export const XhrPolling = 'xhr_polling' as const;\r\n}\r\n\r\ntype TransportName = typeof TransportNames.WebSocket | typeof TransportNames.Comet | typeof TransportNames.XhrPolling;\r\n\r\nexport default TransportName;\r\n", "import ProtocolMessage, {\r\n  actions,\r\n  stringify as stringifyProtocolMessage,\r\n  fromValues as protocolMessageFromValues,\r\n} from 'common/lib/types/protocolmessage';\r\nimport * as Utils from 'common/lib/util/utils';\r\nimport Protocol, { PendingMessage } from './protocol';\r\nimport Defaults, { getAgentString } from 'common/lib/util/defaults';\r\nimport Platform, { TransportImplementations } from 'common/platform';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport MessageQueue from './messagequeue';\r\nimport Logger from '../util/logger';\r\nimport ConnectionStateChange from 'common/lib/client/connectionstatechange';\r\nimport ConnectionErrors, { isRetriable } from './connectionerrors';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport Auth from 'common/lib/client/auth';\r\nimport Message, { getMessagesSize } from 'common/lib/types/message';\r\nimport Multicaster, { MulticasterInstance } from 'common/lib/util/multicaster';\r\nimport Transport, { TransportCtor } from './transport';\r\nimport * as API from '../../../../ably';\r\nimport { ErrCallback } from 'common/types/utils';\r\nimport HttpStatusCodes from 'common/constants/HttpStatusCodes';\r\nimport BaseRealtime from '../client/baserealtime';\r\nimport { NormalisedClientOptions } from 'common/types/ClientOptions';\r\nimport TransportName, { TransportNames } from 'common/constants/TransportName';\r\n\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nconst haveWebStorage = () => typeof Platform.WebStorage !== 'undefined' && Platform.WebStorage?.localSupported;\r\nconst haveSessionStorage = () => typeof Platform.WebStorage !== 'undefined' && Platform.WebStorage?.sessionSupported;\r\nconst noop = function () {};\r\nconst transportPreferenceName = 'ably-transport-preference';\r\n\r\nfunction bundleWith(dest: ProtocolMessage, src: ProtocolMessage, maxSize: number) {\r\n  let action;\r\n  if (dest.channel !== src.channel) {\r\n    /* RTL6d3 */\r\n    return false;\r\n  }\r\n  if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {\r\n    /* RTL6d - can only bundle messages or presence */\r\n    return false;\r\n  }\r\n  if (action !== src.action) {\r\n    /* RTL6d4 */\r\n    return false;\r\n  }\r\n  const kind = action === actions.PRESENCE ? 'presence' : 'messages',\r\n    proposed = (dest as Record<string, any>)[kind].concat((src as Record<string, any>)[kind]),\r\n    size = getMessagesSize(proposed);\r\n  if (size > maxSize) {\r\n    /* RTL6d1 */\r\n    return false;\r\n  }\r\n  if (!Utils.allSame(proposed, 'clientId')) {\r\n    /* RTL6d2 */\r\n    return false;\r\n  }\r\n  if (\r\n    !proposed.every(function (msg: Message) {\r\n      return !msg.id;\r\n    })\r\n  ) {\r\n    /* RTL6d7 */\r\n    return false;\r\n  }\r\n  /* we're good to go! */\r\n  (dest as Record<string, any>)[kind] = proposed;\r\n  return true;\r\n}\r\n\r\ntype RecoveryContext = {\r\n  connectionKey: string;\r\n  msgSerial: number;\r\n  channelSerials: { [name: string]: string };\r\n};\r\n\r\nfunction decodeRecoveryKey(recoveryKey: NormalisedClientOptions['recover']): RecoveryContext | null {\r\n  try {\r\n    return JSON.parse(recoveryKey as string);\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport class TransportParams {\r\n  options: NormalisedClientOptions;\r\n  host: string | null;\r\n  mode: string;\r\n  format?: Utils.Format;\r\n  connectionKey?: string;\r\n  stream?: any;\r\n  heartbeats?: boolean;\r\n\r\n  constructor(options: NormalisedClientOptions, host: string | null, mode: string, connectionKey?: string) {\r\n    this.options = options;\r\n    this.host = host;\r\n    this.mode = mode;\r\n    this.connectionKey = connectionKey;\r\n    this.format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\r\n  }\r\n\r\n  getConnectParams(authParams: Record<string, unknown>): Record<string, string> {\r\n    const params = authParams ? Utils.copy(authParams) : {};\r\n    const options = this.options;\r\n    switch (this.mode) {\r\n      case 'resume':\r\n        params.resume = this.connectionKey as string;\r\n        break;\r\n      case 'recover': {\r\n        const recoveryContext = decodeRecoveryKey(options.recover);\r\n        if (recoveryContext) {\r\n          params.recover = recoveryContext.connectionKey;\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n    }\r\n    if (options.clientId !== undefined) {\r\n      params.clientId = options.clientId;\r\n    }\r\n    if (options.echoMessages === false) {\r\n      params.echo = 'false';\r\n    }\r\n    if (this.format !== undefined) {\r\n      params.format = this.format;\r\n    }\r\n    if (this.stream !== undefined) {\r\n      params.stream = this.stream;\r\n    }\r\n    if (this.heartbeats !== undefined) {\r\n      params.heartbeats = this.heartbeats;\r\n    }\r\n    params.v = Defaults.protocolVersion;\r\n    params.agent = getAgentString(this.options);\r\n    if (options.transportParams !== undefined) {\r\n      Utils.mixin(params, options.transportParams);\r\n    }\r\n    return params as Record<string, string>;\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[mode=' + this.mode;\r\n    if (this.host) {\r\n      result += ',host=' + this.host;\r\n    }\r\n    if (this.connectionKey) {\r\n      result += ',connectionKey=' + this.connectionKey;\r\n    }\r\n    if (this.format) {\r\n      result += ',format=' + this.format;\r\n    }\r\n    result += ']';\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\ntype ConnectionState = {\r\n  state: string;\r\n  terminal?: boolean;\r\n  queueEvents?: boolean;\r\n  sendEvents?: boolean;\r\n  failState?: string;\r\n  retryDelay?: number;\r\n  retryImmediately?: boolean;\r\n  error?: IPartialErrorInfo;\r\n};\r\n\r\nclass ConnectionManager extends EventEmitter {\r\n  supportedTransports: Partial<Record<TransportName, TransportCtor>> = {};\r\n  realtime: BaseRealtime;\r\n  options: NormalisedClientOptions;\r\n  states: Record<string, ConnectionState>;\r\n  state: ConnectionState;\r\n  errorReason: IPartialErrorInfo | null;\r\n  queuedMessages: MessageQueue;\r\n  msgSerial: number;\r\n  connectionDetails?: Record<string, any>;\r\n  connectionId?: string;\r\n  connectionKey?: string;\r\n  connectionStateTtl: number;\r\n  maxIdleInterval: number | null;\r\n  transports: TransportName[];\r\n  baseTransport?: TransportName;\r\n  webSocketTransportAvailable?: true;\r\n  transportPreference: string | null;\r\n  httpHosts: string[];\r\n  wsHosts: string[];\r\n  activeProtocol: null | Protocol;\r\n  pendingTransport?: Transport;\r\n  proposedTransport?: Transport;\r\n  host: string | null;\r\n  lastAutoReconnectAttempt: number | null;\r\n  lastActivity: number | null;\r\n  forceFallbackHost: boolean;\r\n  transitionTimer?: number | NodeJS.Timeout | null;\r\n  suspendTimer?: number | NodeJS.Timeout | null;\r\n  retryTimer?: number | NodeJS.Timeout | null;\r\n  disconnectedRetryCount: number = 0;\r\n  pendingChannelMessagesState: {\r\n    // Whether a message is currently being processed\r\n    isProcessing: boolean;\r\n    // The messages remaining to be processed (excluding any message currently being processed)\r\n    queue: { message: ProtocolMessage; transport: Transport }[];\r\n  } = { isProcessing: false, queue: [] };\r\n  webSocketSlowTimer: NodeJS.Timeout | null;\r\n  wsCheckResult: boolean | null;\r\n  webSocketGiveUpTimer: NodeJS.Timeout | null;\r\n  abandonedWebSocket: boolean;\r\n  connectCounter: number;\r\n\r\n  constructor(realtime: BaseRealtime, options: NormalisedClientOptions) {\r\n    super(realtime.logger);\r\n    this.realtime = realtime;\r\n    this.initTransports();\r\n    this.options = options;\r\n    const timeouts = options.timeouts;\r\n    /* connectingTimeout: leave webSocketConnectTimeout (~6s) to try the\r\n     * websocket transport, then realtimeRequestTimeout (~10s) to establish\r\n     * the base transport in case that fails */\r\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\r\n    this.states = {\r\n      initialized: {\r\n        state: 'initialized',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        failState: 'disconnected',\r\n      },\r\n      connecting: {\r\n        state: 'connecting',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        retryDelay: connectingTimeout,\r\n        failState: 'disconnected',\r\n      },\r\n      connected: {\r\n        state: 'connected',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: true,\r\n        failState: 'disconnected',\r\n      },\r\n      disconnected: {\r\n        state: 'disconnected',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.disconnectedRetryTimeout,\r\n        failState: 'disconnected',\r\n      },\r\n      suspended: {\r\n        state: 'suspended',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.suspendedRetryTimeout,\r\n        failState: 'suspended',\r\n      },\r\n      closing: {\r\n        state: 'closing',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.realtimeRequestTimeout,\r\n        failState: 'closed',\r\n      },\r\n      closed: { state: 'closed', terminal: true, queueEvents: false, sendEvents: false, failState: 'closed' },\r\n      failed: { state: 'failed', terminal: true, queueEvents: false, sendEvents: false, failState: 'failed' },\r\n    };\r\n    this.state = this.states.initialized;\r\n    this.errorReason = null;\r\n\r\n    this.queuedMessages = new MessageQueue(this.logger);\r\n    this.msgSerial = 0;\r\n    this.connectionDetails = undefined;\r\n    this.connectionId = undefined;\r\n    this.connectionKey = undefined;\r\n    this.connectionStateTtl = timeouts.connectionStateTtl;\r\n    this.maxIdleInterval = null;\r\n\r\n    this.transports = Utils.intersect(options.transports || Defaults.defaultTransports, this.supportedTransports);\r\n    this.transportPreference = null;\r\n\r\n    if (this.transports.includes(TransportNames.WebSocket)) {\r\n      this.webSocketTransportAvailable = true;\r\n    }\r\n    if (this.transports.includes(TransportNames.XhrPolling)) {\r\n      this.baseTransport = TransportNames.XhrPolling;\r\n    } else if (this.transports.includes(TransportNames.Comet)) {\r\n      this.baseTransport = TransportNames.Comet;\r\n    }\r\n\r\n    this.httpHosts = Defaults.getHosts(options);\r\n    this.wsHosts = Defaults.getHosts(options, true);\r\n    this.activeProtocol = null;\r\n    this.host = null;\r\n    this.lastAutoReconnectAttempt = null;\r\n    this.lastActivity = null;\r\n    this.forceFallbackHost = false;\r\n    this.connectCounter = 0;\r\n    this.wsCheckResult = null;\r\n    this.webSocketSlowTimer = null;\r\n    this.webSocketGiveUpTimer = null;\r\n    this.abandonedWebSocket = false;\r\n\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime.ConnectionManager()', 'started');\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'Realtime.ConnectionManager()',\r\n      'requested transports = [' + (options.transports || Defaults.defaultTransports) + ']',\r\n    );\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'Realtime.ConnectionManager()',\r\n      'available transports = [' + this.transports + ']',\r\n    );\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'Realtime.ConnectionManager()',\r\n      'http hosts = [' + this.httpHosts + ']',\r\n    );\r\n\r\n    if (!this.transports.length) {\r\n      const msg = 'no requested transports available';\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'realtime.ConnectionManager()', msg);\r\n      throw new Error(msg);\r\n    }\r\n\r\n    const addEventListener = Platform.Config.addEventListener;\r\n    if (addEventListener) {\r\n      /* intercept close event in browser to persist connection id if requested */\r\n      if (haveSessionStorage() && typeof options.recover === 'function') {\r\n        addEventListener('beforeunload', this.persistConnection.bind(this));\r\n      }\r\n\r\n      if (options.closeOnUnload === true) {\r\n        addEventListener('beforeunload', () => {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MAJOR,\r\n            'Realtime.ConnectionManager()',\r\n            'beforeunload event has triggered the connection to close as closeOnUnload is true',\r\n          );\r\n          this.requestState({ state: 'closing' });\r\n        });\r\n      }\r\n\r\n      /* Listen for online and offline events */\r\n      addEventListener('online', () => {\r\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager caught browser \u2018online\u2019 event',\r\n            'reattempting connection',\r\n          );\r\n          this.requestState({ state: 'connecting' });\r\n        } else if (this.state == this.states.connecting) {\r\n          // RTN20c: if 'online' event recieved while CONNECTING, abandon connection attempt and retry\r\n          this.pendingTransport?.off();\r\n          this.disconnectAllTransports();\r\n\r\n          this.startConnect();\r\n        }\r\n      });\r\n\r\n      addEventListener('offline', () => {\r\n        if (this.state == this.states.connected) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager caught browser \u2018offline\u2019 event',\r\n            'disconnecting active transport',\r\n          );\r\n          // Not sufficient to just go to the 'disconnected' state, want to\r\n          // force all transports to reattempt the connection. Will immediately\r\n          // retry.\r\n          this.disconnectAllTransports();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /*********************\r\n   * transport management\r\n   *********************/\r\n\r\n  // Used by tests\r\n  static supportedTransports(additionalImplementations: TransportImplementations) {\r\n    const storage: TransportStorage = { supportedTransports: {} };\r\n    this.initTransports(additionalImplementations, storage);\r\n    return storage.supportedTransports;\r\n  }\r\n\r\n  private static initTransports(additionalImplementations: TransportImplementations, storage: TransportStorage) {\r\n    const implementations = { ...Platform.Transports.bundledImplementations, ...additionalImplementations };\r\n\r\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\r\n      const transport = implementations[transportName];\r\n      if (transport && transport.isAvailable()) {\r\n        storage.supportedTransports[transportName] = transport;\r\n      }\r\n    });\r\n  }\r\n\r\n  initTransports() {\r\n    ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\r\n  }\r\n\r\n  createTransportParams(host: string | null, mode: string): TransportParams {\r\n    return new TransportParams(this.options, host, mode, this.connectionKey);\r\n  }\r\n\r\n  getTransportParams(callback: Function): void {\r\n    const decideMode = (modeCb: Function) => {\r\n      if (this.connectionKey) {\r\n        modeCb('resume');\r\n        return;\r\n      }\r\n\r\n      if (typeof this.options.recover === 'string') {\r\n        modeCb('recover');\r\n        return;\r\n      }\r\n\r\n      const recoverFn = this.options.recover,\r\n        lastSessionData = this.getSessionRecoverData(),\r\n        sessionRecoveryName = this.sessionRecoveryName();\r\n      if (lastSessionData && typeof recoverFn === 'function') {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Calling clientOptions-provided recover function with last session data (recovery scope: ' +\r\n            sessionRecoveryName +\r\n            ')',\r\n        );\r\n        recoverFn(lastSessionData, (shouldRecover?: boolean) => {\r\n          if (shouldRecover) {\r\n            this.options.recover = lastSessionData.recoveryKey;\r\n            modeCb('recover');\r\n          } else {\r\n            modeCb('clean');\r\n          }\r\n        });\r\n        return;\r\n      }\r\n      modeCb('clean');\r\n    };\r\n\r\n    decideMode((mode: string) => {\r\n      const transportParams = this.createTransportParams(null, mode);\r\n      if (mode === 'recover') {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Transport recovery mode = recover; recoveryKey = ' + this.options.recover,\r\n        );\r\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\r\n        if (recoveryContext) {\r\n          this.msgSerial = recoveryContext.msgSerial;\r\n        }\r\n      } else {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Transport params = ' + transportParams.toString(),\r\n        );\r\n      }\r\n      callback(transportParams);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Attempt to connect using a given transport\r\n   * @param transportParams\r\n   * @param candidate, the transport to try\r\n   * @param callback\r\n   */\r\n  tryATransport(transportParams: TransportParams, candidate: TransportName, callback: Function): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);\r\n\r\n    this.proposedTransport = Transport.tryConnect(\r\n      this.supportedTransports[candidate]!,\r\n      this,\r\n      this.realtime.auth,\r\n      transportParams,\r\n      (wrappedErr: { error: ErrorInfo; event: string } | null, transport?: Transport) => {\r\n        const state = this.state;\r\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\r\n          if (transport) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager.tryATransport()',\r\n              'connection ' + state.state + ' while we were attempting the transport; closing ' + transport,\r\n            );\r\n            transport.close();\r\n          }\r\n          callback(true);\r\n          return;\r\n        }\r\n\r\n        if (wrappedErr) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager.tryATransport()',\r\n            'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString(),\r\n          );\r\n\r\n          /* Comet transport onconnect token errors can be dealt with here.\r\n           * Websocket ones only happen after the transport claims to be viable,\r\n           * so are dealt with as non-onconnect token errors */\r\n          if (\r\n            Auth.isTokenErr(wrappedErr.error) &&\r\n            !(this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo))\r\n          ) {\r\n            this.errorReason = wrappedErr.error;\r\n            /* re-get a token and try again */\r\n            Utils.whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err: ErrorInfo | null) => {\r\n              if (err) {\r\n                this.actOnErrorFromAuthorize(err);\r\n                return;\r\n              }\r\n              this.tryATransport(transportParams, candidate, callback);\r\n            });\r\n          } else if (wrappedErr.event === 'failed') {\r\n            /* Error that's fatal to the connection */\r\n            this.notifyState({ state: 'failed', error: wrappedErr.error });\r\n            callback(true);\r\n          } else if (wrappedErr.event === 'disconnected') {\r\n            if (!isRetriable(wrappedErr.error)) {\r\n              /* Error received from the server that does not call for trying a fallback host, eg a rate limit */\r\n              this.notifyState({ state: this.states.connecting.failState as string, error: wrappedErr.error });\r\n              callback(true);\r\n            } else {\r\n              /* Error with that transport only; continue trying other fallback hosts */\r\n              callback(false);\r\n            }\r\n          }\r\n          return;\r\n        }\r\n\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.tryATransport()',\r\n          'viable transport ' + candidate + '; setting pending',\r\n        );\r\n        this.setTransportPending(transport as Transport, transportParams);\r\n        callback(null, transport);\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is indicated to be viable, and the ConnectionManager\r\n   * expects to activate this transport as soon as it is connected.\r\n   * @param transport\r\n   * @param transportParams\r\n   */\r\n  setTransportPending(transport: Transport, transportParams: TransportParams): void {\r\n    const mode = transportParams.mode;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.setTransportPending()',\r\n      'transport = ' + transport + '; mode = ' + mode,\r\n    );\r\n\r\n    this.pendingTransport = transport;\r\n\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n\r\n    transport.once('connected', (error: ErrorInfo, connectionId: string, connectionDetails: Record<string, any>) => {\r\n      this.activateTransport(error, transport, connectionId, connectionDetails);\r\n\r\n      if (mode === 'recover' && this.options.recover) {\r\n        /* After a successful recovery, we unpersist, as a recovery key cannot\r\n         * be used more than once */\r\n        delete this.options.recover;\r\n        this.unpersistConnection();\r\n      }\r\n    });\r\n\r\n    const self = this;\r\n    transport.on(['disconnected', 'closed', 'failed'], function (this: { event: string }, error: ErrorInfo) {\r\n      self.deactivateTransport(transport, this.event, error);\r\n    });\r\n\r\n    this.emit('transport.pending', transport);\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is connected, and the connectionmanager decides that\r\n   * it will now be the active transport. Returns whether or not it activated\r\n   * the transport (if the connection is closing/closed it will choose not to).\r\n   * @param transport the transport instance\r\n   * @param connectionId the id of the new active connection\r\n   * @param connectionDetails the details of the new active connection\r\n   */\r\n  activateTransport(\r\n    error: ErrorInfo,\r\n    transport: Transport,\r\n    connectionId: string,\r\n    connectionDetails: Record<string, any>,\r\n  ): boolean {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.activateTransport()',\r\n      'transport = ' + transport,\r\n    );\r\n    if (error) {\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);\r\n    }\r\n    if (connectionId) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.activateTransport()',\r\n        'connectionId =  ' + connectionId,\r\n      );\r\n    }\r\n    if (connectionDetails) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.activateTransport()',\r\n        'connectionDetails =  ' + JSON.stringify(connectionDetails),\r\n      );\r\n    }\r\n\r\n    this.persistTransportPreference(transport);\r\n\r\n    /* if the connectionmanager moved to the closing/closed state before this\r\n     * connection event, then we won't activate this transport */\r\n    const existingState = this.state,\r\n      connectedState = this.states.connected.state;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.activateTransport()',\r\n      'current state = ' + existingState.state,\r\n    );\r\n    if (\r\n      existingState.state == this.states.closing.state ||\r\n      existingState.state == this.states.closed.state ||\r\n      existingState.state == this.states.failed.state\r\n    ) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.activateTransport()',\r\n        'Disconnecting transport and abandoning',\r\n      );\r\n      transport.disconnect();\r\n      return false;\r\n    }\r\n\r\n    delete this.pendingTransport;\r\n\r\n    /* if the transport is not connected then don't activate it */\r\n    if (!transport.isConnected) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.activateTransport()',\r\n        'Declining to activate transport ' + transport + ' since it appears to no longer be connected',\r\n      );\r\n      return false;\r\n    }\r\n\r\n    /* the given transport is connected; this will immediately\r\n     * take over as the active transport */\r\n    const existingActiveProtocol = this.activeProtocol;\r\n    this.activeProtocol = new Protocol(transport);\r\n    this.host = transport.params.host;\r\n\r\n    const connectionKey = connectionDetails.connectionKey;\r\n    if (connectionKey && this.connectionKey != connectionKey) {\r\n      this.setConnection(connectionId, connectionDetails, !!error);\r\n    }\r\n\r\n    /* Rebroadcast any new connectionDetails from the active transport, which\r\n     * can come at any time (eg following a reauth), and emit an RTN24 UPDATE\r\n     * event. (Listener added on nextTick because we're in a transport.on('connected')\r\n     * callback at the moment; if we add it now we'll be adding it to the end\r\n     * of the listeners array and it'll be called immediately) */\r\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\r\n    Platform.Config.nextTick(() => {\r\n      transport.on(\r\n        'connected',\r\n        (connectedErr: ErrorInfo, _connectionId: string, connectionDetails: Record<string, any>) => {\r\n          this.onConnectionDetailsUpdate(connectionDetails, transport);\r\n          this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, connectedErr));\r\n        },\r\n      );\r\n    });\r\n\r\n    /* If previously not connected, notify the state change (including any\r\n     * error). */\r\n    if (existingState.state === this.states.connected.state) {\r\n      if (error) {\r\n        this.errorReason = this.realtime.connection.errorReason = error;\r\n        this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, error));\r\n      }\r\n    } else {\r\n      this.notifyState({ state: 'connected', error: error });\r\n      this.errorReason = this.realtime.connection.errorReason = error || null;\r\n    }\r\n\r\n    /* Send after the connection state update, as Channels hooks into this to\r\n     * resend attaches on a new transport if necessary */\r\n    this.emit('transport.active', transport);\r\n\r\n    /* Gracefully terminate existing protocol */\r\n    if (existingActiveProtocol) {\r\n      if (existingActiveProtocol.messageQueue.count() > 0) {\r\n        /* We could just requeue pending messages on the new transport, but\r\n         * actually this should never happen: transports should only take over\r\n         * from other active transports when upgrading, and upgrading waits for\r\n         * the old transport to be idle. So log an error. */\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_ERROR,\r\n          'ConnectionManager.activateTransport()',\r\n          'Previous active protocol (for transport ' +\r\n            existingActiveProtocol.transport.shortName +\r\n            ', new one is ' +\r\n            transport.shortName +\r\n            ') finishing with ' +\r\n            existingActiveProtocol.messageQueue.count() +\r\n            ' messages still pending',\r\n        );\r\n      }\r\n      if (existingActiveProtocol.transport === transport) {\r\n        const msg =\r\n          'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' +\r\n          transport.shortName +\r\n          '; stack = ' +\r\n          new Error().stack;\r\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);\r\n      } else {\r\n        existingActiveProtocol.finish();\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is no longer the active transport. This can occur\r\n   * in any transport connection state.\r\n   * @param transport\r\n   */\r\n  deactivateTransport(transport: Transport, state: string, error: ErrorInfo): void {\r\n    const currentProtocol = this.activeProtocol,\r\n      wasActive = currentProtocol && currentProtocol.getTransport() === transport,\r\n      wasPending = transport === this.pendingTransport,\r\n      noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\r\n\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.deactivateTransport()',\r\n      'transport = ' + transport,\r\n    );\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.deactivateTransport()',\r\n      'state = ' +\r\n        state +\r\n        (wasActive ? '; was active' : wasPending ? '; was pending' : '') +\r\n        (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'),\r\n    );\r\n    if (error && error.message)\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.deactivateTransport()',\r\n        'reason =  ' + error.message,\r\n      );\r\n\r\n    if (wasActive) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.deactivateTransport()',\r\n        'Getting, clearing, and requeuing ' +\r\n          (this.activeProtocol as Protocol).messageQueue.count() +\r\n          ' pending messages',\r\n      );\r\n      this.queuePendingMessages((currentProtocol as Protocol).getPendingMessages());\r\n      /* Clear any messages we requeue to allow the protocol to become idle.*/\r\n      (currentProtocol as Protocol).clearPendingMessages();\r\n      this.activeProtocol = this.host = null;\r\n    }\r\n\r\n    this.emit('transport.inactive', transport);\r\n\r\n    /* this transport state change is a state change for the connectionmanager if\r\n     * - the transport was the active transport and there are no transports\r\n     *   which are connected and scheduled for activation, just waiting for the\r\n     *   active transport to finish what its doing; or\r\n     * - the transport was the active transport and the error was fatal (so\r\n     *   unhealable by another transport); or\r\n     * - there is no active transport, and this is the last remaining\r\n     *   pending transport (so we were in the connecting state)\r\n     */\r\n    if (\r\n      (wasActive && noTransportsScheduledForActivation) ||\r\n      (wasActive && state === 'failed') ||\r\n      state === 'closed' ||\r\n      (currentProtocol === null && wasPending)\r\n    ) {\r\n      /* If we're disconnected with a 5xx we need to try fallback hosts\r\n       * (RTN14d), but (a) due to how the upgrade sequence works, the\r\n       * host/transport selection sequence only cares about getting to\r\n       * `preconnect` (eg establishing a websocket) getting a `disconnected`\r\n       * protocol message afterwards is too late; and (b) host retry only\r\n       * applies to connectBase unless the stored preference transport doesn't\r\n       * work. We solve this by unpersisting the transport preference and\r\n       * setting an instance variable to force fallback hosts to be used (if\r\n       * any) here. Bit of a kludge, but no real better alternatives without\r\n       * rewriting the entire thing */\r\n      if (state === 'disconnected' && error && (error.statusCode as number) > 500 && this.httpHosts.length > 1) {\r\n        this.unpersistTransportPreference();\r\n        this.forceFallbackHost = true;\r\n        /* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */\r\n        this.notifyState({ state: state, error: error, retryImmediately: true });\r\n        return;\r\n      }\r\n\r\n      /* TODO remove below line once realtime sends token errors as DISCONNECTEDs */\r\n      const newConnectionState = state === 'failed' && Auth.isTokenErr(error) ? 'disconnected' : state;\r\n      this.notifyState({ state: newConnectionState, error: error });\r\n      return;\r\n    }\r\n  }\r\n\r\n  /* Helper that returns true if there are no transports which are pending,\r\n   * have been connected, and are just waiting for onceNoPending to fire before\r\n   * being activated */\r\n  noTransportsScheduledForActivation(): boolean {\r\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\r\n  }\r\n\r\n  setConnection(connectionId: string, connectionDetails: Record<string, any>, hasConnectionError?: boolean): void {\r\n    /* if connectionKey changes but connectionId stays the same, then just a\r\n     * transport change on the same connection. If connectionId changes, we're\r\n     * on a new connection, with implications for msgSerial and channel state */\r\n    /* If no previous connectionId, don't reset the msgSerial as it may have\r\n     * been set by recover data (unless the recover failed) */\r\n    const prevConnId = this.connectionId,\r\n      connIdChanged = prevConnId && prevConnId !== connectionId,\r\n      recoverFailure = !prevConnId && hasConnectionError;\r\n    if (connIdChanged || recoverFailure) {\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');\r\n      this.msgSerial = 0;\r\n      // RTN19a2: In the event of a new connectionId, previous msgSerials are\r\n      // meaningless.\r\n      this.queuedMessages.resetSendAttempted();\r\n    }\r\n    if (this.connectionId !== connectionId) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.setConnection()',\r\n        'New connectionId; reattaching any attached channels',\r\n      );\r\n    }\r\n    this.realtime.connection.id = this.connectionId = connectionId;\r\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\r\n  }\r\n\r\n  clearConnection(): void {\r\n    this.realtime.connection.id = this.connectionId = undefined;\r\n    this.realtime.connection.key = this.connectionKey = undefined;\r\n    this.msgSerial = 0;\r\n    this.unpersistConnection();\r\n  }\r\n\r\n  createRecoveryKey(): string | null {\r\n    // RTN16g2.\r\n    if (!this.connectionKey) {\r\n      return null;\r\n    }\r\n\r\n    return JSON.stringify({\r\n      connectionKey: this.connectionKey,\r\n      msgSerial: this.msgSerial,\r\n      channelSerials: this.realtime.channels.channelSerials(),\r\n    });\r\n  }\r\n\r\n  checkConnectionStateFreshness(): void {\r\n    if (!this.lastActivity || !this.connectionId) {\r\n      return;\r\n    }\r\n\r\n    const sinceLast = Date.now() - this.lastActivity;\r\n    if (sinceLast > this.connectionStateTtl + (this.maxIdleInterval as number)) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.checkConnectionStateFreshness()',\r\n        'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state',\r\n      );\r\n      this.clearConnection();\r\n      this.states.connecting.failState = 'suspended';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the connectionmanager wants to persist transport\r\n   * state for later recovery. Only applicable in the browser context.\r\n   */\r\n  persistConnection(): void {\r\n    if (haveSessionStorage()) {\r\n      const recoveryKey = this.createRecoveryKey();\r\n      if (recoveryKey) {\r\n        this.setSessionRecoverData({\r\n          recoveryKey: recoveryKey,\r\n          disconnectedAt: Date.now(),\r\n          location: globalObject.location,\r\n          clientId: this.realtime.auth.clientId,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the connectionmanager wants to persist transport\r\n   * state for later recovery. Only applicable in the browser context.\r\n   */\r\n  unpersistConnection(): void {\r\n    this.clearSessionRecoverData();\r\n  }\r\n\r\n  /*********************\r\n   * state management\r\n   *********************/\r\n\r\n  getError(): IPartialErrorInfo | string {\r\n    if (this.errorReason) {\r\n      // create new PartialErrorInfo so it has the correct stack trace\r\n      // which points to the place which caused us to return this error.\r\n      const newError = PartialErrorInfo.fromValues(this.errorReason);\r\n      newError.cause = this.errorReason;\r\n      return newError;\r\n    }\r\n\r\n    return this.getStateError();\r\n  }\r\n\r\n  getStateError(): ErrorInfo {\r\n    return (ConnectionErrors as Record<string, () => ErrorInfo>)[this.state.state]?.();\r\n  }\r\n\r\n  activeState(): boolean | void {\r\n    return this.state.queueEvents || this.state.sendEvents;\r\n  }\r\n\r\n  enactStateChange(stateChange: ConnectionStateChange): void {\r\n    const action = 'Connection state';\r\n    const message = stateChange.current + (stateChange.reason ? '; reason: ' + stateChange.reason : '');\r\n    if (stateChange.current === 'failed') {\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, action, message);\r\n    } else {\r\n      Logger.logAction(this.logger, Logger.LOG_MAJOR, action, message);\r\n    }\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.enactStateChange',\r\n      'setting new state: ' +\r\n        stateChange.current +\r\n        '; reason = ' +\r\n        (stateChange.reason && (stateChange.reason as ErrorInfo).message),\r\n    );\r\n    const newState = (this.state = this.states[stateChange.current as string]);\r\n    if (stateChange.reason) {\r\n      this.errorReason = stateChange.reason;\r\n      // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405\r\n      this.realtime.connection.errorReason = stateChange.reason as ErrorInfo;\r\n    }\r\n    if (newState.terminal || newState.state === 'suspended') {\r\n      /* suspended is nonterminal, but once in the suspended state, realtime\r\n       * will have discarded our connection state, so futher connection\r\n       * attempts should start from scratch */\r\n      this.clearConnection();\r\n    }\r\n    this.emit('connectionstate', stateChange);\r\n  }\r\n\r\n  /****************************************\r\n   * ConnectionManager connection lifecycle\r\n   ****************************************/\r\n\r\n  startTransitionTimer(transitionState: ConnectionState): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.startTransitionTimer()',\r\n      'transitionState: ' + transitionState.state,\r\n    );\r\n\r\n    if (this.transitionTimer) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.startTransitionTimer()',\r\n        'clearing already-running timer',\r\n      );\r\n      clearTimeout(this.transitionTimer as number);\r\n    }\r\n\r\n    this.transitionTimer = setTimeout(() => {\r\n      if (this.transitionTimer) {\r\n        this.transitionTimer = null;\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager ' + transitionState.state + ' timer expired',\r\n          'requesting new state: ' + transitionState.failState,\r\n        );\r\n        this.notifyState({ state: transitionState.failState as string });\r\n      }\r\n    }, transitionState.retryDelay);\r\n  }\r\n\r\n  cancelTransitionTimer(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');\r\n    if (this.transitionTimer) {\r\n      clearTimeout(this.transitionTimer as number);\r\n      this.transitionTimer = null;\r\n    }\r\n  }\r\n\r\n  startSuspendTimer(): void {\r\n    if (this.suspendTimer) return;\r\n    this.suspendTimer = setTimeout(() => {\r\n      if (this.suspendTimer) {\r\n        this.suspendTimer = null;\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager suspend timer expired',\r\n          'requesting new state: suspended',\r\n        );\r\n        this.states.connecting.failState = 'suspended';\r\n        this.notifyState({ state: 'suspended' });\r\n      }\r\n    }, this.connectionStateTtl);\r\n  }\r\n\r\n  checkSuspendTimer(state: string): void {\r\n    if (state !== 'disconnected' && state !== 'suspended' && state !== 'connecting') this.cancelSuspendTimer();\r\n  }\r\n\r\n  cancelSuspendTimer(): void {\r\n    this.states.connecting.failState = 'disconnected';\r\n    if (this.suspendTimer) {\r\n      clearTimeout(this.suspendTimer as number);\r\n      this.suspendTimer = null;\r\n    }\r\n  }\r\n\r\n  startRetryTimer(interval: number): void {\r\n    this.retryTimer = setTimeout(() => {\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');\r\n      this.retryTimer = null;\r\n      this.requestState({ state: 'connecting' });\r\n    }, interval);\r\n  }\r\n\r\n  cancelRetryTimer(): void {\r\n    if (this.retryTimer) {\r\n      clearTimeout(this.retryTimer as NodeJS.Timeout);\r\n      this.retryTimer = null;\r\n    }\r\n  }\r\n\r\n  startWebSocketSlowTimer() {\r\n    this.webSocketSlowTimer = setTimeout(() => {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager WebSocket slow timer',\r\n        'checking connectivity',\r\n      );\r\n      if (this.wsCheckResult === null) {\r\n        this.checkWsConnectivity()\r\n          .then(() => {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'ws connectivity check succeeded',\r\n            );\r\n            this.wsCheckResult = true;\r\n          })\r\n          .catch(() => {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MAJOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'ws connectivity check failed',\r\n            );\r\n            this.wsCheckResult = false;\r\n          });\r\n      }\r\n      if (this.realtime.http.checkConnectivity) {\r\n        Utils.whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\r\n          if (err || !connectivity) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MAJOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'http connectivity check failed',\r\n            );\r\n            this.cancelWebSocketGiveUpTimer();\r\n            this.notifyState({\r\n              state: 'disconnected',\r\n              error: new ErrorInfo('Unable to connect (network unreachable)', 80003, 404),\r\n            });\r\n          } else {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'http connectivity check succeeded',\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }, this.options.timeouts.webSocketSlowTimeout);\r\n  }\r\n\r\n  cancelWebSocketSlowTimer() {\r\n    if (this.webSocketSlowTimer) {\r\n      clearTimeout(this.webSocketSlowTimer);\r\n      this.webSocketSlowTimer = null;\r\n    }\r\n  }\r\n\r\n  startWebSocketGiveUpTimer(transportParams: TransportParams) {\r\n    this.webSocketGiveUpTimer = setTimeout(() => {\r\n      if (!this.wsCheckResult) {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager WebSocket give up timer',\r\n          'websocket connection took more than 10s; ' + (this.baseTransport ? 'trying base transport' : ''),\r\n        );\r\n        if (this.baseTransport) {\r\n          this.abandonedWebSocket = true;\r\n          this.proposedTransport?.dispose();\r\n          this.pendingTransport?.dispose();\r\n          this.connectBase(transportParams, ++this.connectCounter);\r\n        } else {\r\n          // if we don't have a base transport to fallback to, just let the websocket connection attempt time out\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MAJOR,\r\n            'ConnectionManager WebSocket give up timer',\r\n            'websocket connectivity appears to be unavailable but no other transports to try',\r\n          );\r\n        }\r\n      }\r\n    }, this.options.timeouts.webSocketConnectTimeout);\r\n  }\r\n\r\n  cancelWebSocketGiveUpTimer() {\r\n    if (this.webSocketGiveUpTimer) {\r\n      clearTimeout(this.webSocketGiveUpTimer);\r\n      this.webSocketGiveUpTimer = null;\r\n    }\r\n  }\r\n\r\n  notifyState(indicated: ConnectionState): void {\r\n    const state = indicated.state;\r\n\r\n    /* We retry immediately if:\r\n     * - something disconnects us while we're connected, or\r\n     * - a viable (but not yet active) transport fails due to a token error (so\r\n     *   this.errorReason will be set, and startConnect will do a forced\r\n     *   authorize). If this.errorReason is already set (to a token error),\r\n     *   then there has been at least one previous attempt to connect that also\r\n     *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait\r\n     *   before trying again */\r\n    const retryImmediately =\r\n      state === 'disconnected' &&\r\n      (this.state === this.states.connected ||\r\n        indicated.retryImmediately ||\r\n        (this.state === this.states.connecting &&\r\n          indicated.error &&\r\n          Auth.isTokenErr(indicated.error) &&\r\n          !(this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo))));\r\n\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.notifyState()',\r\n      'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''),\r\n    );\r\n    /* do nothing if we're already in the indicated state */\r\n    if (state == this.state.state) return;\r\n\r\n    /* kill timers (possibly excepting suspend timer depending on the notified\r\n     * state), as these are superseded by this notification */\r\n    this.cancelTransitionTimer();\r\n    this.cancelRetryTimer();\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n    this.checkSuspendTimer(indicated.state);\r\n\r\n    if (state === 'suspended' || state === 'connected') {\r\n      this.disconnectedRetryCount = 0;\r\n    }\r\n\r\n    /* do nothing if we're unable to move from the current state */\r\n    if (this.state.terminal) return;\r\n\r\n    /* process new state */\r\n    const newState = this.states[indicated.state];\r\n\r\n    let retryDelay = newState.retryDelay;\r\n    if (newState.state === 'disconnected') {\r\n      this.disconnectedRetryCount++;\r\n      retryDelay = Utils.getRetryTime(newState.retryDelay as number, this.disconnectedRetryCount);\r\n    }\r\n\r\n    const change = new ConnectionStateChange(\r\n      this.state.state,\r\n      newState.state,\r\n      retryDelay,\r\n      indicated.error || (ConnectionErrors as Partial<Record<string, () => ErrorInfo>>)[newState.state]?.(),\r\n    );\r\n\r\n    if (retryImmediately) {\r\n      const autoReconnect = () => {\r\n        if (this.state === this.states.disconnected) {\r\n          this.lastAutoReconnectAttempt = Date.now();\r\n          this.requestState({ state: 'connecting' });\r\n        }\r\n      };\r\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\r\n      if (sinceLast && sinceLast < 1000) {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.notifyState()',\r\n          'Last reconnect attempt was only ' +\r\n            sinceLast +\r\n            'ms ago, waiting another ' +\r\n            (1000 - sinceLast) +\r\n            'ms before trying again',\r\n        );\r\n        setTimeout(autoReconnect, 1000 - sinceLast);\r\n      } else {\r\n        Platform.Config.nextTick(autoReconnect);\r\n      }\r\n    } else if (state === 'disconnected' || state === 'suspended') {\r\n      this.startRetryTimer(retryDelay as number);\r\n    }\r\n\r\n    /* If going into disconnect/suspended (and not retrying immediately), or a\r\n     * terminal state, ensure there are no orphaned transports hanging around. */\r\n    if ((state === 'disconnected' && !retryImmediately) || state === 'suspended' || newState.terminal) {\r\n      /* Wait till the next tick so the connection state change is enacted,\r\n       * so aborting transports doesn't trigger redundant state changes */\r\n      Platform.Config.nextTick(() => {\r\n        this.disconnectAllTransports();\r\n      });\r\n    }\r\n\r\n    if (state == 'connected' && !this.activeProtocol) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.notifyState()',\r\n        'Broken invariant: attempted to go into connected state, but there is no active protocol',\r\n      );\r\n    }\r\n\r\n    /* implement the change and notify */\r\n    this.enactStateChange(change);\r\n    if (this.state.sendEvents) {\r\n      this.sendQueuedMessages();\r\n    } else if (!this.state.queueEvents) {\r\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\r\n      this.failQueuedMessages(change.reason as ErrorInfo); // RTN7c\r\n    }\r\n  }\r\n\r\n  requestState(request: any): void {\r\n    const state = request.state;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.requestState()',\r\n      'requested state: ' + state + '; current state: ' + this.state.state,\r\n    );\r\n    if (state == this.state.state) return; /* silently do nothing */\r\n\r\n    /* kill running timers, as this request supersedes them */\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n    this.cancelTransitionTimer();\r\n    this.cancelRetryTimer();\r\n    /* for suspend timer check rather than cancel -- eg requesting a connecting\r\n     * state should not reset the suspend timer */\r\n    this.checkSuspendTimer(state);\r\n\r\n    if (state == 'connecting' && this.state.state == 'connected') return;\r\n    if (state == 'closing' && this.state.state == 'closed') return;\r\n\r\n    const newState = this.states[state],\r\n      change = new ConnectionStateChange(\r\n        this.state.state,\r\n        newState.state,\r\n        null,\r\n        request.error || (ConnectionErrors as Partial<Record<string, () => ErrorInfo>>)[newState.state]?.(),\r\n      );\r\n\r\n    this.enactStateChange(change);\r\n\r\n    if (state == 'connecting') {\r\n      Platform.Config.nextTick(() => {\r\n        this.startConnect();\r\n      });\r\n    }\r\n    if (state == 'closing') {\r\n      this.closeImpl();\r\n    }\r\n  }\r\n\r\n  startConnect(): void {\r\n    if (this.state !== this.states.connecting) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.startConnect()',\r\n        'Must be in connecting state to connect, but was ' + this.state.state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    const auth = this.realtime.auth;\r\n\r\n    /* The point of the connectCounter mechanism is to ensure that the\r\n     * connection procedure can be cancelled. We want disconnectAllTransports\r\n     * to be able to stop any in-progress connection, even before it gets to\r\n     * the stage of having a pending (or even a proposed) transport that it can\r\n     * dispose() of. So we check that it's still current after any async stage,\r\n     * up until the stage that is synchronous with instantiating a transport */\r\n    const connectCount = ++this.connectCounter;\r\n\r\n    const connect = () => {\r\n      this.checkConnectionStateFreshness();\r\n      this.getTransportParams((transportParams: TransportParams) => {\r\n        if (transportParams.mode === 'recover' && transportParams.options.recover) {\r\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\r\n          if (recoveryContext) {\r\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\r\n          }\r\n        }\r\n\r\n        if (connectCount !== this.connectCounter) {\r\n          return;\r\n        }\r\n        this.connectImpl(transportParams, connectCount);\r\n      });\r\n    };\r\n\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');\r\n    this.startSuspendTimer();\r\n    this.startTransitionTimer(this.states.connecting);\r\n\r\n    if (auth.method === 'basic') {\r\n      connect();\r\n    } else {\r\n      const authCb = (err: ErrorInfo | null) => {\r\n        if (connectCount !== this.connectCounter) {\r\n          return;\r\n        }\r\n        if (err) {\r\n          this.actOnErrorFromAuthorize(err);\r\n        } else {\r\n          connect();\r\n        }\r\n      };\r\n      if (this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo)) {\r\n        /* Force a refetch of a new token */\r\n        Utils.whenPromiseSettles(auth._forceNewToken(null, null), authCb);\r\n      } else {\r\n        Utils.whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n   * there are, at most, two transports available with which a connection may\r\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\r\n   * comet in nodejs). web_socket is always preferred, and the base transport is\r\n   * only used in case web_socket connectivity appears to be unavailable.\r\n   *\r\n   * connectImpl begins the transport selection process by checking which transports\r\n   * are available, and if there is a cached preference. It then defers to the\r\n   * transport-specific connect methods: connectWs and connectBase.\r\n   *\r\n   * It is also responsible for invalidating the cache in the case that a base\r\n   * transport preference is stored but web socket connectivity is now available.\r\n   *\r\n   * handling of the case where we need to failover from web_socket to the base\r\n   * transport is implemented in the connectWs method.\r\n   */\r\n  connectImpl(transportParams: TransportParams, connectCount: number): void {\r\n    const state = this.state.state;\r\n    if (state !== this.states.connecting.state) {\r\n      /* Only keep trying as long as in the 'connecting' state (or 'connected'\r\n       * for upgrading). Any operation can put us into 'disconnected' to cancel\r\n       * connection attempts and wait before retrying, or 'failed' to fail. */\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.connectImpl()',\r\n        'Must be in connecting state to connect, but was ' + state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    const transportPreference = this.getTransportPreference();\r\n\r\n    // If transport preference is for a non-ws transport but websocket is now available, unpersist the preference for next time\r\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\r\n      this.checkWsConnectivity()\r\n        .then(() => {\r\n          this.wsCheckResult = true;\r\n          this.abandonedWebSocket = false;\r\n          this.unpersistTransportPreference();\r\n          if (this.state === this.states.connecting) {\r\n            Logger.logAction(\r\n              this.logger,\r\n\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager.connectImpl():',\r\n              'web socket connectivity available, cancelling connection attempt with ' + this.baseTransport,\r\n            );\r\n            this.disconnectAllTransports();\r\n            this.connectWs(transportParams, ++this.connectCounter);\r\n          }\r\n        })\r\n        .catch(noop);\r\n    }\r\n\r\n    if (\r\n      (transportPreference && transportPreference === this.baseTransport) ||\r\n      (this.baseTransport && !this.webSocketTransportAvailable)\r\n    ) {\r\n      this.connectBase(transportParams, connectCount);\r\n    } else {\r\n      this.connectWs(transportParams, connectCount);\r\n    }\r\n  }\r\n\r\n  /*\r\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\r\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\r\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\r\n   *   connectivity check fails, we give up the connection sequence entirely and\r\n   *   transition to disconnected. if the websocket connectivity check fails then\r\n   *   we assume no ws connectivity and failover to base transport. in the case that\r\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\r\n   *   and, if unsuccessful, ultimately transition to disconnected.\r\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\r\n   *   connectivity check is still pending then we assume that there is an issue\r\n   *   with the transport and fallback to base transport.\r\n   */\r\n  connectWs(transportParams: TransportParams, connectCount: number) {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.connectWs()');\r\n    this.startWebSocketSlowTimer();\r\n    this.startWebSocketGiveUpTimer(transportParams);\r\n\r\n    this.tryTransportWithFallbacks('web_socket', transportParams, true, connectCount, () => {\r\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\r\n    });\r\n  }\r\n\r\n  connectBase(transportParams: TransportParams, connectCount: number) {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.connectBase()');\r\n    if (this.baseTransport) {\r\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\r\n    } else {\r\n      this.notifyState({\r\n        state: 'disconnected',\r\n        error: new ErrorInfo('No transports left to try', 80000, 404),\r\n      });\r\n    }\r\n  }\r\n\r\n  tryTransportWithFallbacks(\r\n    transportName: TransportName,\r\n    transportParams: TransportParams,\r\n    ws: boolean,\r\n    connectCount: number,\r\n    shouldContinue: () => boolean,\r\n  ): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n\r\n      Logger.LOG_MICRO,\r\n      'ConnectionManager.tryTransportWithFallbacks()',\r\n      transportName,\r\n    );\r\n    const giveUp = (err: IPartialErrorInfo) => {\r\n      this.notifyState({ state: this.states.connecting.failState as string, error: err });\r\n    };\r\n\r\n    const candidateHosts = ws ? this.wsHosts.slice() : this.httpHosts.slice();\r\n\r\n    const hostAttemptCb = (fatal: boolean, transport: Transport) => {\r\n      if (connectCount !== this.connectCounter) {\r\n        return;\r\n      }\r\n      if (!shouldContinue()) {\r\n        if (transport) {\r\n          transport.dispose();\r\n        }\r\n        return;\r\n      }\r\n      if (!transport && !fatal) {\r\n        tryFallbackHosts();\r\n      }\r\n    };\r\n\r\n    /* first try to establish a connection with the priority host with http transport */\r\n    const host = candidateHosts.shift();\r\n    if (!host) {\r\n      giveUp(new ErrorInfo('Unable to connect (no available host)', 80003, 404));\r\n      return;\r\n    }\r\n    transportParams.host = host;\r\n\r\n    /* this is what we'll be doing if the attempt for the main host fails */\r\n    const tryFallbackHosts = () => {\r\n      /* if there aren't any fallback hosts, fail */\r\n      if (!candidateHosts.length) {\r\n        giveUp(new ErrorInfo('Unable to connect (and no more fallback hosts to try)', 80003, 404));\r\n        return;\r\n      }\r\n      /* before trying any fallback (or any remaining fallback) we decide if\r\n       * there is a problem with the ably host, or there is a general connectivity\r\n       * problem */\r\n      if (!this.realtime.http.checkConnectivity) {\r\n        giveUp(new PartialErrorInfo('Internal error: Http.checkConnectivity not set', null, 500));\r\n        return;\r\n      }\r\n      Utils.whenPromiseSettles(\r\n        this.realtime.http.checkConnectivity(),\r\n        (err?: ErrorInfo | null, connectivity?: boolean) => {\r\n          if (connectCount !== this.connectCounter) {\r\n            return;\r\n          }\r\n          if (!shouldContinue()) {\r\n            return;\r\n          }\r\n          /* we know err won't happen but handle it here anyway */\r\n          if (err) {\r\n            giveUp(err);\r\n            return;\r\n          }\r\n          if (!connectivity) {\r\n            /* the internet isn't reachable, so don't try the fallback hosts */\r\n            giveUp(new ErrorInfo('Unable to connect (network unreachable)', 80003, 404));\r\n            return;\r\n          }\r\n          /* the network is there, so there's a problem with the main host, or\r\n           * its dns. Try the fallback hosts. We could try them simultaneously but\r\n           * that would potentially cause a huge spike in load on the load balancer */\r\n          transportParams.host = Utils.arrPopRandomElement(candidateHosts);\r\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\r\n        },\r\n      );\r\n    };\r\n\r\n    if (this.forceFallbackHost && candidateHosts.length) {\r\n      this.forceFallbackHost = false;\r\n      tryFallbackHosts();\r\n      return;\r\n    }\r\n\r\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\r\n  }\r\n\r\n  closeImpl(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');\r\n    this.cancelSuspendTimer();\r\n    this.startTransitionTimer(this.states.closing);\r\n\r\n    if (this.pendingTransport) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.closeImpl()',\r\n        'Closing pending transport: ' + this.pendingTransport,\r\n      );\r\n      this.pendingTransport.close();\r\n    }\r\n\r\n    if (this.activeProtocol) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.closeImpl()',\r\n        'Closing active transport: ' + this.activeProtocol.getTransport(),\r\n      );\r\n      this.activeProtocol.getTransport().close();\r\n    }\r\n\r\n    /* If there was an active transport, this will probably be\r\n     * preempted by the notifyState call in deactivateTransport */\r\n    this.notifyState({ state: 'closed' });\r\n  }\r\n\r\n  onAuthUpdated(tokenDetails: API.TokenDetails, callback: Function): void {\r\n    switch (this.state.state) {\r\n      case 'connected': {\r\n        Logger.logAction(\r\n          this.logger,\r\n\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Sending AUTH message on active transport',\r\n        );\r\n\r\n        /* Do any transport-specific new-token action */\r\n        const activeTransport = this.activeProtocol?.getTransport();\r\n        if (activeTransport && activeTransport.onAuthUpdated) {\r\n          activeTransport.onAuthUpdated(tokenDetails);\r\n        }\r\n\r\n        const authMsg = protocolMessageFromValues({\r\n          action: actions.AUTH,\r\n          auth: {\r\n            accessToken: tokenDetails.token,\r\n          },\r\n        });\r\n        this.send(authMsg);\r\n\r\n        /* The answer will come back as either a connectiondetails event\r\n         * (realtime sends a CONNECTED to acknowledge the reauth) or a\r\n         * statechange to failed */\r\n        const successListener = () => {\r\n          this.off(failureListener);\r\n          callback(null, tokenDetails);\r\n        };\r\n        const failureListener = (stateChange: ConnectionStateChange) => {\r\n          if (stateChange.current === 'failed') {\r\n            this.off(successListener);\r\n            this.off(failureListener);\r\n            callback(stateChange.reason || this.getStateError());\r\n          }\r\n        };\r\n        this.once('connectiondetails', successListener);\r\n        this.on('connectionstate', failureListener);\r\n        break;\r\n      }\r\n\r\n      case 'connecting':\r\n        Logger.logAction(\r\n          this.logger,\r\n\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Aborting current connection attempts in order to start again with the new auth details',\r\n        );\r\n        this.disconnectAllTransports();\r\n      /* fallthrough to add statechange listener */\r\n\r\n      default: {\r\n        Logger.logAction(\r\n          this.logger,\r\n\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Connection state is ' + this.state.state + '; waiting until either connected or failed',\r\n        );\r\n        const listener = (stateChange: ConnectionStateChange) => {\r\n          switch (stateChange.current) {\r\n            case 'connected':\r\n              this.off(listener);\r\n              callback(null, tokenDetails);\r\n              break;\r\n            case 'failed':\r\n            case 'closed':\r\n            case 'suspended':\r\n              this.off(listener);\r\n              callback(stateChange.reason || this.getStateError());\r\n              break;\r\n            default:\r\n              /* ignore till we get either connected or failed */\r\n              break;\r\n          }\r\n        };\r\n        this.on('connectionstate', listener);\r\n        if (this.state.state === 'connecting') {\r\n          /* can happen if in the connecting state but no transport was pending\r\n           * yet, so disconnectAllTransports did not trigger a disconnected state */\r\n          this.startConnect();\r\n        } else {\r\n          this.requestState({ state: 'connecting' });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  disconnectAllTransports(): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.disconnectAllTransports()',\r\n      'Disconnecting all transports',\r\n    );\r\n\r\n    /* This will prevent any connection procedure in an async part of one of its early stages from continuing */\r\n    this.connectCounter++;\r\n\r\n    if (this.pendingTransport) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting pending transport: ' + this.pendingTransport,\r\n      );\r\n      this.pendingTransport.disconnect();\r\n    }\r\n    delete this.pendingTransport;\r\n\r\n    if (this.proposedTransport) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting proposed transport: ' + this.pendingTransport,\r\n      );\r\n      this.proposedTransport.disconnect();\r\n    }\r\n    delete this.pendingTransport;\r\n\r\n    if (this.activeProtocol) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting active transport: ' + this.activeProtocol.getTransport(),\r\n      );\r\n      this.activeProtocol.getTransport().disconnect();\r\n    }\r\n    /* No need to notify state disconnected; disconnecting the active transport\r\n     * will have that effect */\r\n  }\r\n\r\n  /******************\r\n   * event queueing\r\n   ******************/\r\n\r\n  send(msg: ProtocolMessage, queueEvent?: boolean, callback?: ErrCallback): void {\r\n    callback = callback || noop;\r\n    const state = this.state;\r\n\r\n    if (state.sendEvents) {\r\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.send()', 'sending event');\r\n      this.sendImpl(new PendingMessage(msg, callback));\r\n      return;\r\n    }\r\n    const shouldQueue = queueEvent && state.queueEvents;\r\n    if (!shouldQueue) {\r\n      const err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;\r\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.send()', err);\r\n      callback(this.errorReason || new ErrorInfo(err, 90000, 400));\r\n      return;\r\n    }\r\n    if (this.logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.send()',\r\n        'queueing msg; ' + stringifyProtocolMessage(msg, this.realtime._RealtimePresence),\r\n      );\r\n    }\r\n    this.queue(msg, callback);\r\n  }\r\n\r\n  sendImpl(pendingMessage: PendingMessage): void {\r\n    const msg = pendingMessage.message;\r\n    /* If have already attempted to send this, resend with the same msgSerial,\r\n     * so Ably can dedup if the previous send succeeded */\r\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\r\n      msg.msgSerial = this.msgSerial++;\r\n    }\r\n    try {\r\n      (this.activeProtocol as Protocol).send(pendingMessage);\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.sendImpl()',\r\n        'Unexpected exception in transport.send(): ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  queue(msg: ProtocolMessage, callback: ErrCallback): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');\r\n    const lastQueued = this.queuedMessages.last();\r\n    const maxSize = this.options.maxMessageSize;\r\n    /* If have already attempted to send a message, don't merge more messages\r\n     * into it, as if the previous send actually succeeded and realtime ignores\r\n     * the dup, they'll be lost */\r\n    if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\r\n      if (!lastQueued.merged) {\r\n        lastQueued.callback = Multicaster.create(this.logger, [lastQueued.callback]);\r\n        lastQueued.merged = true;\r\n      }\r\n      (lastQueued.callback as MulticasterInstance<void>).push(callback);\r\n    } else {\r\n      this.queuedMessages.push(new PendingMessage(msg, callback));\r\n    }\r\n  }\r\n\r\n  sendQueuedMessages(): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n\r\n      Logger.LOG_MICRO,\r\n      'ConnectionManager.sendQueuedMessages()',\r\n      'sending ' + this.queuedMessages.count() + ' queued messages',\r\n    );\r\n    let pendingMessage;\r\n    while ((pendingMessage = this.queuedMessages.shift())) this.sendImpl(pendingMessage);\r\n  }\r\n\r\n  queuePendingMessages(pendingMessages: Array<PendingMessage>): void {\r\n    if (pendingMessages && pendingMessages.length) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.queuePendingMessages()',\r\n        'queueing ' + pendingMessages.length + ' pending messages',\r\n      );\r\n      this.queuedMessages.prepend(pendingMessages);\r\n    }\r\n  }\r\n\r\n  failQueuedMessages(err: ErrorInfo): void {\r\n    const numQueued = this.queuedMessages.count();\r\n    if (numQueued > 0) {\r\n      Logger.logAction(\r\n        this.logger,\r\n\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.failQueuedMessages()',\r\n        'failing ' + numQueued + ' queued messages, err = ' + Utils.inspectError(err),\r\n      );\r\n      this.queuedMessages.completeAllMessages(err);\r\n    }\r\n  }\r\n\r\n  onChannelMessage(message: ProtocolMessage, transport: Transport): void {\r\n    this.pendingChannelMessagesState.queue.push({ message, transport });\r\n\r\n    if (!this.pendingChannelMessagesState.isProcessing) {\r\n      this.processNextPendingChannelMessage();\r\n    }\r\n  }\r\n\r\n  private processNextPendingChannelMessage() {\r\n    if (this.pendingChannelMessagesState.queue.length > 0) {\r\n      this.pendingChannelMessagesState.isProcessing = true;\r\n\r\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift()!;\r\n      this.processChannelMessage(pendingChannelMessage.message)\r\n        .catch((err) => {\r\n          Logger.logAction(\r\n            this.logger,\r\n\r\n            Logger.LOG_ERROR,\r\n            'ConnectionManager.processNextPendingChannelMessage() received error ',\r\n            err,\r\n          );\r\n        })\r\n        .finally(() => {\r\n          this.pendingChannelMessagesState.isProcessing = false;\r\n          this.processNextPendingChannelMessage();\r\n        });\r\n    }\r\n  }\r\n\r\n  private async processChannelMessage(message: ProtocolMessage) {\r\n    await this.realtime.channels.processChannelMessage(message);\r\n  }\r\n\r\n  async ping(): Promise<number> {\r\n    if (this.state.state !== 'connected') {\r\n      throw new ErrorInfo('Unable to ping service; not connected', 40000, 400);\r\n    }\r\n\r\n    const transport = this.activeProtocol?.getTransport();\r\n    if (!transport) {\r\n      throw this.getStateError();\r\n    }\r\n\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);\r\n\r\n    const pingStart = Date.now();\r\n    const id = Utils.cheapRandStr();\r\n\r\n    return Utils.withTimeoutAsync<number>(\r\n      new Promise((resolve) => {\r\n        const onHeartbeat = (responseId: string) => {\r\n          if (responseId === id) {\r\n            transport.off('heartbeat', onHeartbeat);\r\n            resolve(Date.now() - pingStart);\r\n          }\r\n        };\r\n        transport.on('heartbeat', onHeartbeat);\r\n        transport.ping(id);\r\n      }),\r\n      this.options.timeouts.realtimeRequestTimeout,\r\n      'Timeout waiting for heartbeat response',\r\n    );\r\n  }\r\n\r\n  abort(error: ErrorInfo): void {\r\n    (this.activeProtocol as Protocol).getTransport().fail(error);\r\n  }\r\n\r\n  getTransportPreference(): TransportName {\r\n    return this.transportPreference || (haveWebStorage() && Platform.WebStorage?.get?.(transportPreferenceName));\r\n  }\r\n\r\n  persistTransportPreference(transport: Transport): void {\r\n    this.transportPreference = transport.shortName;\r\n    if (haveWebStorage()) {\r\n      Platform.WebStorage?.set?.(transportPreferenceName, transport.shortName);\r\n    }\r\n  }\r\n\r\n  unpersistTransportPreference(): void {\r\n    this.transportPreference = null;\r\n    if (haveWebStorage()) {\r\n      Platform.WebStorage?.remove?.(transportPreferenceName);\r\n    }\r\n  }\r\n\r\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\r\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\r\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\r\n   * server returns 403. */\r\n  actOnErrorFromAuthorize(err: ErrorInfo): void {\r\n    if (err.code === 40171) {\r\n      /* No way to reauth */\r\n      this.notifyState({ state: 'failed', error: err });\r\n    } else if (err.code === 40102) {\r\n      this.notifyState({ state: 'failed', error: err });\r\n    } else if (err.statusCode === HttpStatusCodes.Forbidden) {\r\n      const msg = 'Client configured authentication provider returned 403; failing the connection';\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);\r\n      this.notifyState({ state: 'failed', error: new ErrorInfo(msg, 80019, 403, err) });\r\n    } else {\r\n      const msg = 'Client configured authentication provider request failed';\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);\r\n      this.notifyState({ state: this.state.failState as string, error: new ErrorInfo(msg, 80019, 401, err) });\r\n    }\r\n  }\r\n\r\n  onConnectionDetailsUpdate(connectionDetails: Record<string, any>, transport: Transport): void {\r\n    if (!connectionDetails) {\r\n      return;\r\n    }\r\n    this.connectionDetails = connectionDetails;\r\n    if (connectionDetails.maxMessageSize) {\r\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\r\n    }\r\n    const clientId = connectionDetails.clientId;\r\n    if (clientId) {\r\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\r\n      if (err) {\r\n        Logger.logAction(this.logger, Logger.LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);\r\n        /* Errors setting the clientId are fatal to the connection */\r\n        transport.fail(err);\r\n        return;\r\n      }\r\n    }\r\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\r\n    if (connectionStateTtl) {\r\n      this.connectionStateTtl = connectionStateTtl;\r\n    }\r\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\r\n    this.emit('connectiondetails', connectionDetails);\r\n  }\r\n\r\n  checkWsConnectivity() {\r\n    const ws = new Platform.Config.WebSocket(Defaults.wsConnectivityUrl);\r\n    return new Promise<void>((resolve, reject) => {\r\n      let finished = false;\r\n      ws.onopen = () => {\r\n        if (!finished) {\r\n          finished = true;\r\n          resolve();\r\n          ws.close();\r\n        }\r\n      };\r\n\r\n      ws.onclose = ws.onerror = () => {\r\n        if (!finished) {\r\n          finished = true;\r\n          reject();\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  sessionRecoveryName() {\r\n    return this.options.recoveryKeyStorageName || 'ably-connection-recovery';\r\n  }\r\n\r\n  getSessionRecoverData() {\r\n    return haveSessionStorage() && Platform.WebStorage?.getSession?.(this.sessionRecoveryName());\r\n  }\r\n  setSessionRecoverData(value: any) {\r\n    return haveSessionStorage() && Platform.WebStorage?.setSession?.(this.sessionRecoveryName(), value);\r\n  }\r\n  clearSessionRecoverData() {\r\n    return haveSessionStorage() && Platform.WebStorage?.removeSession?.(this.sessionRecoveryName());\r\n  }\r\n}\r\n\r\nexport default ConnectionManager;\r\n\r\nexport interface TransportStorage {\r\n  supportedTransports: Partial<Record<TransportName, TransportCtor>>;\r\n}\r\n", "import EventEmitter from '../util/eventemitter';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport Logger from '../util/logger';\r\nimport ConnectionStateChange from './connectionstatechange';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport { NormalisedClientOptions } from '../../types/ClientOptions';\r\nimport BaseRealtime from './baserealtime';\r\nimport Platform from 'common/platform';\r\n\r\nclass Connection extends EventEmitter {\r\n  ably: BaseRealtime;\r\n  connectionManager: ConnectionManager;\r\n  state: string;\r\n  key?: string;\r\n  id?: string;\r\n  errorReason: ErrorInfo | null;\r\n\r\n  constructor(ably: BaseRealtime, options: NormalisedClientOptions) {\r\n    super(ably.logger);\r\n    this.ably = ably;\r\n    this.connectionManager = new ConnectionManager(ably, options);\r\n    this.state = this.connectionManager.state.state;\r\n    this.key = undefined;\r\n    this.id = undefined;\r\n    this.errorReason = null;\r\n\r\n    this.connectionManager.on('connectionstate', (stateChange: ConnectionStateChange) => {\r\n      const state = (this.state = stateChange.current as string);\r\n      Platform.Config.nextTick(() => {\r\n        this.emit(state, stateChange);\r\n      });\r\n    });\r\n    this.connectionManager.on('update', (stateChange: ConnectionStateChange) => {\r\n      Platform.Config.nextTick(() => {\r\n        this.emit('update', stateChange);\r\n      });\r\n    });\r\n  }\r\n\r\n  whenState = ((state: string) => {\r\n    return EventEmitter.prototype.whenState.call(this, state, this.state);\r\n  }) as any;\r\n\r\n  connect(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Connection.connect()', '');\r\n    this.connectionManager.requestState({ state: 'connecting' });\r\n  }\r\n\r\n  async ping(): Promise<number> {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Connection.ping()', '');\r\n    return this.connectionManager.ping();\r\n  }\r\n\r\n  close(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);\r\n    this.connectionManager.requestState({ state: 'closing' });\r\n  }\r\n\r\n  get recoveryKey(): string | null {\r\n    this.logger.deprecationWarning(\r\n      'The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.',\r\n    );\r\n    return this.createRecoveryKey();\r\n  }\r\n\r\n  createRecoveryKey(): string | null {\r\n    return this.connectionManager.createRecoveryKey();\r\n  }\r\n}\r\n\r\nexport default Connection;\r\n", "import ErrorInfo from '../types/errorinfo';\r\n\r\nclass ChannelStateChange {\r\n  previous: string;\r\n  current: string;\r\n  resumed?: boolean;\r\n  reason?: string | Error | ErrorInfo;\r\n  hasBacklog?: boolean;\r\n\r\n  constructor(\r\n    previous: string,\r\n    current: string,\r\n    resumed?: boolean,\r\n    hasBacklog?: boolean,\r\n    reason?: string | Error | ErrorInfo | null,\r\n  ) {\r\n    this.previous = previous;\r\n    this.current = current;\r\n    if (current === 'attached') {\r\n      this.resumed = resumed;\r\n      this.hasBacklog = hasBacklog;\r\n    }\r\n    if (reason) this.reason = reason;\r\n  }\r\n}\r\n\r\nexport default ChannelStateChange;\r\n", "import ProtocolMessage, {\r\n  actions,\r\n  channelModes,\r\n  fromValues as protocolMessageFromValues,\r\n} from '../types/protocolmessage';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport RealtimePresence from './realtimepresence';\r\nimport Message, {\r\n  fromValues as messageFromValues,\r\n  fromValuesArray as messagesFromValuesArray,\r\n  encodeArray as encodeMessagesArray,\r\n  decode as decodeMessage,\r\n  getMessagesSize,\r\n  CipherOptions,\r\n  EncodingDecodingContext,\r\n} from '../types/message';\r\nimport ChannelStateChange from './channelstatechange';\r\nimport ErrorInfo, { PartialErrorInfo } from '../types/errorinfo';\r\nimport PresenceMessage, { decode as decodePresenceMessage } from '../types/presencemessage';\r\nimport ConnectionErrors from '../transport/connectionerrors';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport ConnectionStateChange from './connectionstatechange';\r\nimport { ErrCallback, StandardCallback } from '../../types/utils';\r\nimport BaseRealtime from './baserealtime';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport { normaliseChannelOptions } from '../util/defaults';\r\nimport { PaginatedResult } from './paginatedresource';\r\n\r\ninterface RealtimeHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n  untilAttach?: boolean;\r\n  from_serial?: string;\r\n}\r\n\r\nconst noop = function () {};\r\n\r\nfunction validateChannelOptions(options?: API.ChannelOptions) {\r\n  if (options && 'params' in options && !Utils.isObject(options.params)) {\r\n    return new ErrorInfo('options.params must be an object', 40000, 400);\r\n  }\r\n  if (options && 'modes' in options) {\r\n    if (!Array.isArray(options.modes)) {\r\n      return new ErrorInfo('options.modes must be an array', 40000, 400);\r\n    }\r\n    for (let i = 0; i < options.modes.length; i++) {\r\n      const currentMode = options.modes[i];\r\n      if (\r\n        !currentMode ||\r\n        typeof currentMode !== 'string' ||\r\n        !channelModes.includes(String.prototype.toUpperCase.call(currentMode))\r\n      ) {\r\n        return new ErrorInfo('Invalid channel mode: ' + currentMode, 40000, 400);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass RealtimeChannel extends EventEmitter {\r\n  name: string;\r\n  channelOptions: ChannelOptions;\r\n  client: BaseRealtime;\r\n  private _presence: RealtimePresence | null;\r\n  get presence(): RealtimePresence {\r\n    if (!this._presence) {\r\n      Utils.throwMissingPluginError('RealtimePresence');\r\n    }\r\n    return this._presence;\r\n  }\r\n  connectionManager: ConnectionManager;\r\n  state: API.ChannelState;\r\n  subscriptions: EventEmitter;\r\n  filteredSubscriptions?: Map<API.messageCallback<Message>, Map<API.MessageFilter, API.messageCallback<Message>[]>>;\r\n  syncChannelSerial?: string | null;\r\n  properties: {\r\n    attachSerial: string | null | undefined;\r\n    channelSerial: string | null | undefined;\r\n  };\r\n  errorReason: ErrorInfo | string | null;\r\n  _requestedFlags: Array<API.ChannelMode> | null;\r\n  _mode?: null | number;\r\n  _attachResume: boolean;\r\n  _decodingContext: EncodingDecodingContext;\r\n  _lastPayload: {\r\n    messageId?: string | null;\r\n    protocolMessageChannelSerial?: string | null;\r\n    decodeFailureRecoveryInProgress: null | boolean;\r\n  };\r\n  _allChannelChanges: EventEmitter;\r\n  params?: Record<string, any>;\r\n  modes: string[] | undefined;\r\n  stateTimer?: number | NodeJS.Timeout | null;\r\n  retryTimer?: number | NodeJS.Timeout | null;\r\n  retryCount: number = 0;\r\n\r\n  constructor(client: BaseRealtime, name: string, options?: API.ChannelOptions) {\r\n    super(client.logger);\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);\r\n    this.name = name;\r\n    this.channelOptions = normaliseChannelOptions(client._Crypto ?? null, this.logger, options);\r\n    this.client = client;\r\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\r\n    this.connectionManager = client.connection.connectionManager;\r\n    this.state = 'initialized';\r\n    this.subscriptions = new EventEmitter(this.logger);\r\n    this.syncChannelSerial = undefined;\r\n    this.properties = {\r\n      attachSerial: undefined,\r\n      channelSerial: undefined,\r\n    };\r\n    this.setOptions(options);\r\n    this.errorReason = null;\r\n    this._requestedFlags = null;\r\n    this._mode = null;\r\n    this._attachResume = false;\r\n    this._decodingContext = {\r\n      channelOptions: this.channelOptions,\r\n      plugins: client.options.plugins || {},\r\n      baseEncodedPreviousPayload: undefined,\r\n    };\r\n    this._lastPayload = {\r\n      messageId: null,\r\n      protocolMessageChannelSerial: null,\r\n      decodeFailureRecoveryInProgress: null,\r\n    };\r\n    /* Only differences between this and the public event emitter is that this emits an\r\n     * update event for all ATTACHEDs, whether resumed or not */\r\n    this._allChannelChanges = new EventEmitter(this.logger);\r\n  }\r\n\r\n  invalidStateError(): ErrorInfo {\r\n    return new ErrorInfo(\r\n      'Channel operation failed as channel state is ' + this.state,\r\n      90001,\r\n      400,\r\n      this.errorReason || undefined,\r\n    );\r\n  }\r\n\r\n  static processListenerArgs(args: unknown[]): any[] {\r\n    /* [event], listener */\r\n    args = Array.prototype.slice.call(args);\r\n    if (typeof args[0] === 'function') {\r\n      args.unshift(null);\r\n    }\r\n    return args;\r\n  }\r\n\r\n  async setOptions(options?: API.ChannelOptions): Promise<void> {\r\n    const previousChannelOptions = this.channelOptions;\r\n    const err = validateChannelOptions(options);\r\n    if (err) {\r\n      throw err;\r\n    }\r\n    this.channelOptions = normaliseChannelOptions(this.client._Crypto ?? null, this.logger, options);\r\n    if (this._decodingContext) this._decodingContext.channelOptions = this.channelOptions;\r\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\r\n      /* This does not just do _attach(true, null, callback) because that would put us\r\n       * into the 'attaching' state until we receive the new attached, which is\r\n       * conceptually incorrect: we are still attached, we just have a pending request to\r\n       * change some channel params. Per RTL17 going into the attaching state would mean\r\n       * rejecting messages until we have confirmation that the options have changed,\r\n       * which would unnecessarily lose message continuity. */\r\n      this.attachImpl();\r\n      return new Promise((resolve, reject) => {\r\n        // Ignore 'attaching' -- could be just due to to a resume & reattach, should not\r\n        // call back setOptions until we're definitely attached with the new options (or\r\n        // else in a terminal state)\r\n        this._allChannelChanges.once(\r\n          ['attached', 'update', 'detached', 'failed'],\r\n          function (this: { event: string }, stateChange: ConnectionStateChange) {\r\n            switch (this.event) {\r\n              case 'update':\r\n              case 'attached':\r\n                resolve();\r\n                break;\r\n              default:\r\n                reject(stateChange.reason);\r\n            }\r\n          },\r\n        );\r\n      });\r\n    }\r\n  }\r\n\r\n  _shouldReattachToSetOptions(options: API.ChannelOptions | undefined, prevOptions: API.ChannelOptions) {\r\n    if (!(this.state === 'attached' || this.state === 'attaching')) {\r\n      return false;\r\n    }\r\n    if (options?.params) {\r\n      // Don't check against the `agent` param - it isn't returned in the ATTACHED message\r\n      const requestedParams = omitAgent(options.params);\r\n      const existingParams = omitAgent(prevOptions.params);\r\n\r\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\r\n        return true;\r\n      }\r\n\r\n      if (!Utils.shallowEquals(existingParams, requestedParams)) {\r\n        return true;\r\n      }\r\n    }\r\n    if (options?.modes) {\r\n      if (!prevOptions.modes || !Utils.arrEquals(options.modes, prevOptions.modes)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async publish(...args: any[]): Promise<void> {\r\n    let messages = args[0];\r\n    let argCount = args.length;\r\n\r\n    if (!this.connectionManager.activeState()) {\r\n      throw this.connectionManager.getError();\r\n    }\r\n    if (argCount == 1) {\r\n      if (Utils.isObject(messages)) messages = [messageFromValues(messages)];\r\n      else if (Array.isArray(messages)) messages = messagesFromValuesArray(messages);\r\n      else\r\n        throw new ErrorInfo(\r\n          'The single-argument form of publish() expects a message object or an array of message objects',\r\n          40013,\r\n          400,\r\n        );\r\n    } else {\r\n      messages = [messageFromValues({ name: args[0], data: args[1] })];\r\n    }\r\n    const maxMessageSize = this.client.options.maxMessageSize;\r\n    await encodeMessagesArray(messages, this.channelOptions as CipherOptions);\r\n    /* RSL1i */\r\n    const size = getMessagesSize(messages);\r\n    if (size > maxMessageSize) {\r\n      throw new ErrorInfo(\r\n        'Maximum size of messages that can be published at once exceeded ( was ' +\r\n          size +\r\n          ' bytes; limit is ' +\r\n          maxMessageSize +\r\n          ' bytes)',\r\n        40009,\r\n        400,\r\n      );\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      this._publish(messages, (err) => (err ? reject(err) : resolve()));\r\n    });\r\n  }\r\n\r\n  _publish(messages: Array<Message>, callback: ErrCallback) {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);\r\n    const state = this.state;\r\n    switch (state) {\r\n      case 'failed':\r\n      case 'suspended':\r\n        callback(ErrorInfo.fromValues(this.invalidStateError()));\r\n        break;\r\n      default: {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          'RealtimeChannel.publish()',\r\n          'sending message; channel state is ' + state,\r\n        );\r\n        const msg = new ProtocolMessage();\r\n        msg.action = actions.MESSAGE;\r\n        msg.channel = this.name;\r\n        msg.messages = messages;\r\n        this.sendMessage(msg, callback);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  onEvent(messages: Array<any>): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');\r\n    const subscriptions = this.subscriptions;\r\n    for (let i = 0; i < messages.length; i++) {\r\n      const message = messages[i];\r\n      subscriptions.emit(message.name, message);\r\n    }\r\n  }\r\n\r\n  async attach(): Promise<ChannelStateChange | null> {\r\n    if (this.state === 'attached') {\r\n      return null;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      this._attach(false, null, (err, result) => (err ? reject(err) : resolve(result!)));\r\n    });\r\n  }\r\n\r\n  _attach(\r\n    forceReattach: boolean,\r\n    attachReason: ErrorInfo | null,\r\n    callback?: StandardCallback<ChannelStateChange>,\r\n  ): void {\r\n    if (!callback) {\r\n      callback = (err?: ErrorInfo | null) => {\r\n        if (err) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_ERROR,\r\n            'RealtimeChannel._attach()',\r\n            'Channel attach failed: ' + err.toString(),\r\n          );\r\n        }\r\n      };\r\n    }\r\n\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      callback(connectionManager.getError());\r\n      return;\r\n    }\r\n\r\n    if (this.state !== 'attaching' || forceReattach) {\r\n      this.requestState('attaching', attachReason);\r\n    }\r\n\r\n    this.once(function (this: { event: string }, stateChange: ChannelStateChange) {\r\n      switch (this.event) {\r\n        case 'attached':\r\n          callback?.(null, stateChange);\r\n          break;\r\n        case 'detached':\r\n        case 'suspended':\r\n        case 'failed':\r\n          callback?.(\r\n            stateChange.reason ||\r\n              connectionManager.getError() ||\r\n              new ErrorInfo('Unable to attach; reason unknown; state = ' + this.event, 90000, 500),\r\n          );\r\n          break;\r\n        case 'detaching':\r\n          callback?.(new ErrorInfo('Attach request superseded by a subsequent detach request', 90000, 409));\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  attachImpl(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');\r\n    const attachMsg = protocolMessageFromValues({\r\n      action: actions.ATTACH,\r\n      channel: this.name,\r\n      params: this.channelOptions.params,\r\n      // RTL4c1: Includes the channel serial to resume from a previous message\r\n      // or attachment.\r\n      channelSerial: this.properties.channelSerial,\r\n    });\r\n    if (this._requestedFlags) {\r\n      attachMsg.encodeModesToFlags(this._requestedFlags);\r\n    } else if (this.channelOptions.modes) {\r\n      attachMsg.encodeModesToFlags(Utils.allToUpperCase(this.channelOptions.modes) as API.ChannelMode[]);\r\n    }\r\n    if (this._attachResume) {\r\n      attachMsg.setFlag('ATTACH_RESUME');\r\n    }\r\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\r\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\r\n    }\r\n    this.sendMessage(attachMsg, noop);\r\n  }\r\n\r\n  async detach(): Promise<void> {\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      throw connectionManager.getError();\r\n    }\r\n    switch (this.state) {\r\n      case 'suspended':\r\n        this.notifyState('detached');\r\n        return;\r\n      case 'detached':\r\n        return;\r\n      case 'failed':\r\n        throw new ErrorInfo('Unable to detach; channel state = failed', 90001, 400);\r\n      default:\r\n        this.requestState('detaching');\r\n      // eslint-disable-next-line no-fallthrough\r\n      case 'detaching':\r\n        return new Promise((resolve, reject) => {\r\n          this.once(function (this: { event: string }, stateChange: ChannelStateChange) {\r\n            switch (this.event) {\r\n              case 'detached':\r\n                resolve();\r\n                break;\r\n              case 'attached':\r\n              case 'suspended':\r\n              case 'failed':\r\n                reject(\r\n                  stateChange.reason ||\r\n                    connectionManager.getError() ||\r\n                    new ErrorInfo('Unable to detach; reason unknown; state = ' + this.event, 90000, 500),\r\n                );\r\n                break;\r\n              case 'attaching':\r\n                reject(new ErrorInfo('Detach request superseded by a subsequent attach request', 90000, 409));\r\n                break;\r\n            }\r\n          });\r\n        });\r\n    }\r\n  }\r\n\r\n  detachImpl(callback?: ErrCallback): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');\r\n    const msg = protocolMessageFromValues({ action: actions.DETACH, channel: this.name });\r\n    this.sendMessage(msg, callback || noop);\r\n  }\r\n\r\n  async subscribe(...args: unknown[] /* [event], listener */): Promise<ChannelStateChange | null> {\r\n    const [event, listener] = RealtimeChannel.processListenerArgs(args);\r\n\r\n    if (this.state === 'failed') {\r\n      throw ErrorInfo.fromValues(this.invalidStateError());\r\n    }\r\n\r\n    // Filtered\r\n    if (event && typeof event === 'object' && !Array.isArray(event)) {\r\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\r\n    } else {\r\n      this.subscriptions.on(event, listener);\r\n    }\r\n\r\n    return this.attach();\r\n  }\r\n\r\n  unsubscribe(...args: unknown[] /* [event], listener */): void {\r\n    const [event, listener] = RealtimeChannel.processListenerArgs(args);\r\n\r\n    // If we either have a filtered listener, a filter or both we need to do additional processing to find the original function(s)\r\n    if ((typeof event === 'object' && !listener) || this.filteredSubscriptions?.has(listener)) {\r\n      this.client._FilteredSubscriptions\r\n        .getAndDeleteFilteredSubscriptions(this, event, listener)\r\n        .forEach((l) => this.subscriptions.off(l));\r\n      return;\r\n    }\r\n\r\n    this.subscriptions.off(event, listener);\r\n  }\r\n\r\n  sync(): void {\r\n    /* check preconditions */\r\n    switch (this.state) {\r\n      case 'initialized':\r\n      case 'detaching':\r\n      case 'detached':\r\n        throw new PartialErrorInfo('Unable to sync to channel; not attached', 40000);\r\n      default:\r\n    }\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      throw connectionManager.getError();\r\n    }\r\n\r\n    /* send sync request */\r\n    const syncMessage = protocolMessageFromValues({ action: actions.SYNC, channel: this.name });\r\n    if (this.syncChannelSerial) {\r\n      syncMessage.channelSerial = this.syncChannelSerial;\r\n    }\r\n    connectionManager.send(syncMessage);\r\n  }\r\n\r\n  sendMessage(msg: ProtocolMessage, callback?: ErrCallback): void {\r\n    this.connectionManager.send(msg, this.client.options.queueMessages, callback);\r\n  }\r\n\r\n  sendPresence(presence: PresenceMessage | PresenceMessage[], callback?: ErrCallback): void {\r\n    const msg = protocolMessageFromValues({\r\n      action: actions.PRESENCE,\r\n      channel: this.name,\r\n      presence: Array.isArray(presence)\r\n        ? this.client._RealtimePresence!.presenceMessagesFromValuesArray(presence)\r\n        : [this.client._RealtimePresence!.presenceMessageFromValues(presence)],\r\n    });\r\n    this.sendMessage(msg, callback);\r\n  }\r\n\r\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\r\n  async processMessage(message: ProtocolMessage): Promise<void> {\r\n    if (\r\n      message.action === actions.ATTACHED ||\r\n      message.action === actions.MESSAGE ||\r\n      message.action === actions.PRESENCE\r\n    ) {\r\n      // RTL15b\r\n      this.setChannelSerial(message.channelSerial);\r\n    }\r\n\r\n    let syncChannelSerial,\r\n      isSync = false;\r\n    switch (message.action) {\r\n      case actions.ATTACHED: {\r\n        this.properties.attachSerial = message.channelSerial;\r\n        this._mode = message.getMode();\r\n        this.params = (message as any).params || {};\r\n        const modesFromFlags = message.decodeModesFromFlags();\r\n        this.modes = (modesFromFlags && Utils.allToLowerCase(modesFromFlags)) || undefined;\r\n        const resumed = message.hasFlag('RESUMED');\r\n        const hasPresence = message.hasFlag('HAS_PRESENCE');\r\n        const hasBacklog = message.hasFlag('HAS_BACKLOG');\r\n        if (this.state === 'attached') {\r\n          if (!resumed) {\r\n            /* On a loss of continuity, the presence set needs to be re-synced */\r\n            if (this._presence) {\r\n              this._presence.onAttached(hasPresence);\r\n            }\r\n          }\r\n          const change = new ChannelStateChange(this.state, this.state, resumed, hasBacklog, message.error);\r\n          this._allChannelChanges.emit('update', change);\r\n          if (!resumed || this.channelOptions.updateOnAttached) {\r\n            this.emit('update', change);\r\n          }\r\n        } else if (this.state === 'detaching') {\r\n          /* RTL5i: re-send DETACH and remain in the 'detaching' state */\r\n          this.checkPendingState();\r\n        } else {\r\n          this.notifyState('attached', message.error, resumed, hasPresence, hasBacklog);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case actions.DETACHED: {\r\n        const detachErr = message.error\r\n          ? ErrorInfo.fromValues(message.error)\r\n          : new ErrorInfo('Channel detached', 90001, 404);\r\n        if (this.state === 'detaching') {\r\n          this.notifyState('detached', detachErr);\r\n        } else if (this.state === 'attaching') {\r\n          /* Only retry immediately if we were previously attached. If we were\r\n           * attaching, go into suspended, fail messages, and wait a few seconds\r\n           * before retrying */\r\n          this.notifyState('suspended', detachErr);\r\n        } else {\r\n          this.requestState('attaching', detachErr);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case actions.SYNC:\r\n        /* syncs can have channelSerials, but might not if the sync is one page long */\r\n        isSync = true;\r\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\r\n        /* syncs can happen on channels with no presence data as part of connection\r\n         * resuming, in which case protocol message has no presence property */\r\n        if (!message.presence) break;\r\n      // eslint-disable-next-line no-fallthrough\r\n      case actions.PRESENCE: {\r\n        const presence = message.presence;\r\n\r\n        if (!presence) {\r\n          break;\r\n        }\r\n\r\n        const { id, connectionId, timestamp } = message;\r\n\r\n        const options = this.channelOptions;\r\n        let presenceMsg: PresenceMessage;\r\n        for (let i = 0; i < presence.length; i++) {\r\n          try {\r\n            presenceMsg = presence[i];\r\n            await decodePresenceMessage(presenceMsg, options);\r\n            if (!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;\r\n            if (!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;\r\n            if (!presenceMsg.id) presenceMsg.id = id + ':' + i;\r\n          } catch (e) {\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_ERROR,\r\n              'RealtimeChannel.processMessage()',\r\n              (e as Error).toString(),\r\n            );\r\n          }\r\n        }\r\n        if (this._presence) {\r\n          this._presence.setPresence(presence, isSync, syncChannelSerial as any);\r\n        }\r\n        break;\r\n      }\r\n      case actions.MESSAGE: {\r\n        //RTL17\r\n        if (this.state !== 'attached') {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MAJOR,\r\n            'RealtimeChannel.processMessage()',\r\n            'Message \"' +\r\n              message.id +\r\n              '\" skipped as this channel \"' +\r\n              this.name +\r\n              '\" state is not \"attached\" (state is \"' +\r\n              this.state +\r\n              '\").',\r\n          );\r\n          return;\r\n        }\r\n\r\n        const messages = message.messages as Array<Message>,\r\n          firstMessage = messages[0],\r\n          lastMessage = messages[messages.length - 1],\r\n          id = message.id,\r\n          connectionId = message.connectionId,\r\n          timestamp = message.timestamp;\r\n\r\n        if (\r\n          firstMessage.extras &&\r\n          firstMessage.extras.delta &&\r\n          firstMessage.extras.delta.from !== this._lastPayload.messageId\r\n        ) {\r\n          const msg =\r\n            'Delta message decode failure - previous message not available for message \"' +\r\n            message.id +\r\n            '\" on this channel \"' +\r\n            this.name +\r\n            '\".';\r\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'RealtimeChannel.processMessage()', msg);\r\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\r\n          break;\r\n        }\r\n\r\n        for (let i = 0; i < messages.length; i++) {\r\n          const msg = messages[i];\r\n          try {\r\n            await decodeMessage(msg, this._decodingContext);\r\n          } catch (e) {\r\n            /* decrypt failed .. the most likely cause is that we have the wrong key */\r\n            Logger.logAction(\r\n              this.logger,\r\n              Logger.LOG_ERROR,\r\n              'RealtimeChannel.processMessage()',\r\n              (e as Error).toString(),\r\n            );\r\n            switch ((e as ErrorInfo).code) {\r\n              case 40018:\r\n                /* decode failure */\r\n                this._startDecodeFailureRecovery(e as ErrorInfo);\r\n                return;\r\n              case 40019:\r\n              /* No vcdiff plugin passed in - no point recovering, give up */\r\n              // eslint-disable-next-line no-fallthrough\r\n              case 40021:\r\n                /* Browser does not support deltas, similarly no point recovering */\r\n                this.notifyState('failed', e as ErrorInfo);\r\n                return;\r\n            }\r\n          }\r\n          if (!msg.connectionId) msg.connectionId = connectionId;\r\n          if (!msg.timestamp) msg.timestamp = timestamp;\r\n          if (!msg.id) msg.id = id + ':' + i;\r\n        }\r\n        this._lastPayload.messageId = lastMessage.id;\r\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\r\n        this.onEvent(messages);\r\n        break;\r\n      }\r\n\r\n      case actions.ERROR: {\r\n        /* there was a channel-specific error */\r\n        const err = message.error as ErrorInfo;\r\n        if (err && err.code == 80016) {\r\n          /* attach/detach operation attempted on superseded transport handle */\r\n          this.checkPendingState();\r\n        } else {\r\n          this.notifyState('failed', ErrorInfo.fromValues(err));\r\n        }\r\n        break;\r\n      }\r\n\r\n      default:\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_ERROR,\r\n          'RealtimeChannel.processMessage()',\r\n          'Fatal protocol error: unrecognised action (' + message.action + ')',\r\n        );\r\n        this.connectionManager.abort(ConnectionErrors.unknownChannelErr());\r\n    }\r\n  }\r\n\r\n  _startDecodeFailureRecovery(reason: ErrorInfo): void {\r\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MAJOR,\r\n        'RealtimeChannel.processMessage()',\r\n        'Starting decode failure recovery process.',\r\n      );\r\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\r\n      this._attach(true, reason, () => {\r\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\r\n      });\r\n    }\r\n  }\r\n\r\n  onAttached(): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'RealtimeChannel.onAttached',\r\n      'activating channel; name = ' + this.name,\r\n    );\r\n  }\r\n\r\n  notifyState(\r\n    state: API.ChannelState,\r\n    reason?: ErrorInfo | null,\r\n    resumed?: boolean,\r\n    hasPresence?: boolean,\r\n    hasBacklog?: boolean,\r\n  ): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'RealtimeChannel.notifyState',\r\n      'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state,\r\n    );\r\n    this.clearStateTimer();\r\n\r\n    // RTP5a1\r\n    if (['detached', 'suspended', 'failed'].includes(state)) {\r\n      this.properties.channelSerial = null;\r\n    }\r\n\r\n    if (state === this.state) {\r\n      return;\r\n    }\r\n    if (this._presence) {\r\n      this._presence.actOnChannelState(state, hasPresence, reason);\r\n    }\r\n    if (state === 'suspended' && this.connectionManager.state.sendEvents) {\r\n      this.startRetryTimer();\r\n    } else {\r\n      this.cancelRetryTimer();\r\n    }\r\n    if (reason) {\r\n      this.errorReason = reason;\r\n    }\r\n    const change = new ChannelStateChange(this.state, state, resumed, hasBacklog, reason);\r\n    const action = 'Channel state for channel \"' + this.name + '\"';\r\n    const message = state + (reason ? '; reason: ' + reason : '');\r\n    if (state === 'failed') {\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, action, message);\r\n    } else {\r\n      Logger.logAction(this.logger, Logger.LOG_MAJOR, action, message);\r\n    }\r\n\r\n    if (state !== 'attaching' && state !== 'suspended') {\r\n      this.retryCount = 0;\r\n    }\r\n\r\n    /* Note: we don't set inProgress for pending states until the request is actually in progress */\r\n    if (state === 'attached') {\r\n      this.onAttached();\r\n    }\r\n\r\n    if (state === 'attached') {\r\n      this._attachResume = true;\r\n    } else if (state === 'detaching' || state === 'failed') {\r\n      this._attachResume = false;\r\n    }\r\n\r\n    this.state = state;\r\n    this._allChannelChanges.emit(state, change);\r\n    this.emit(state, change);\r\n  }\r\n\r\n  requestState(state: API.ChannelState, reason?: ErrorInfo | null): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'RealtimeChannel.requestState',\r\n      'name = ' + this.name + ', state = ' + state,\r\n    );\r\n    this.notifyState(state, reason);\r\n    /* send the event and await response */\r\n    this.checkPendingState();\r\n  }\r\n\r\n  checkPendingState(): void {\r\n    /* if can't send events, do nothing */\r\n    const cmState = this.connectionManager.state;\r\n    if (!cmState.sendEvents) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'RealtimeChannel.checkPendingState',\r\n        'sendEvents is false; state is ' + this.connectionManager.state.state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'RealtimeChannel.checkPendingState',\r\n      'name = ' + this.name + ', state = ' + this.state,\r\n    );\r\n    /* Only start the state timer running when actually sending the event */\r\n    switch (this.state) {\r\n      case 'attaching':\r\n        this.startStateTimerIfNotRunning();\r\n        this.attachImpl();\r\n        break;\r\n      case 'detaching':\r\n        this.startStateTimerIfNotRunning();\r\n        this.detachImpl();\r\n        break;\r\n      case 'attached':\r\n        /* resume any sync operation that was in progress */\r\n        this.sync();\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  timeoutPendingState(): void {\r\n    switch (this.state) {\r\n      case 'attaching': {\r\n        const err = new ErrorInfo('Channel attach timed out', 90007, 408);\r\n        this.notifyState('suspended', err);\r\n        break;\r\n      }\r\n      case 'detaching': {\r\n        const err = new ErrorInfo('Channel detach timed out', 90007, 408);\r\n        this.notifyState('attached', err);\r\n        break;\r\n      }\r\n      default:\r\n        this.checkPendingState();\r\n        break;\r\n    }\r\n  }\r\n\r\n  startStateTimerIfNotRunning(): void {\r\n    if (!this.stateTimer) {\r\n      this.stateTimer = setTimeout(() => {\r\n        Logger.logAction(this.logger, Logger.LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');\r\n        this.stateTimer = null;\r\n        this.timeoutPendingState();\r\n      }, this.client.options.timeouts.realtimeRequestTimeout);\r\n    }\r\n  }\r\n\r\n  clearStateTimer(): void {\r\n    const stateTimer = this.stateTimer;\r\n    if (stateTimer) {\r\n      clearTimeout(stateTimer);\r\n      this.stateTimer = null;\r\n    }\r\n  }\r\n\r\n  startRetryTimer(): void {\r\n    if (this.retryTimer) return;\r\n\r\n    this.retryCount++;\r\n    const retryDelay = Utils.getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\r\n\r\n    this.retryTimer = setTimeout(() => {\r\n      /* If connection is not connected, just leave in suspended, a reattach\r\n       * will be triggered once it connects again */\r\n      if (this.state === 'suspended' && this.connectionManager.state.sendEvents) {\r\n        this.retryTimer = null;\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MINOR,\r\n          'RealtimeChannel retry timer expired',\r\n          'attempting a new attach',\r\n        );\r\n        this.requestState('attaching');\r\n      }\r\n    }, retryDelay);\r\n  }\r\n\r\n  cancelRetryTimer(): void {\r\n    if (this.retryTimer) {\r\n      clearTimeout(this.retryTimer as NodeJS.Timeout);\r\n      this.retryTimer = null;\r\n    }\r\n  }\r\n\r\n  history = async function (\r\n    this: RealtimeChannel,\r\n    params: RealtimeHistoryParams | null,\r\n  ): Promise<PaginatedResult<Message>> {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);\r\n\r\n    // We fetch this first so that any plugin-not-provided error takes priority over other errors\r\n    const restMixin = this.client.rest.channelMixin;\r\n\r\n    if (params && params.untilAttach) {\r\n      if (this.state !== 'attached') {\r\n        throw new ErrorInfo('option untilAttach requires the channel to be attached', 40000, 400);\r\n      }\r\n      if (!this.properties.attachSerial) {\r\n        throw new ErrorInfo(\r\n          'untilAttach was specified and channel is attached, but attachSerial is not defined',\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n      delete params.untilAttach;\r\n      params.from_serial = this.properties.attachSerial;\r\n    }\r\n\r\n    return restMixin.history(this, params);\r\n  } as any;\r\n\r\n  whenState = ((state: string) => {\r\n    return EventEmitter.prototype.whenState.call(this, state, this.state);\r\n  }) as any;\r\n\r\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\r\n  getReleaseErr(): ErrorInfo | null {\r\n    const s = this.state;\r\n    if (s === 'initialized' || s === 'detached' || s === 'failed') {\r\n      return null;\r\n    }\r\n    return new ErrorInfo(\r\n      'Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' +\r\n        s,\r\n      90001,\r\n      400,\r\n    );\r\n  }\r\n\r\n  setChannelSerial(channelSerial?: string | null): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'RealtimeChannel.setChannelSerial()',\r\n      'Updating channel serial; serial = ' + channelSerial + '; previous = ' + this.properties.channelSerial,\r\n    );\r\n\r\n    // RTP17h: Only update the channel serial if its present (it won't always\r\n    // be set).\r\n    if (channelSerial) {\r\n      this.properties.channelSerial = channelSerial;\r\n    }\r\n  }\r\n\r\n  async status(): Promise<API.ChannelDetails> {\r\n    return this.client.rest.channelMixin.status(this);\r\n  }\r\n}\r\n\r\nfunction omitAgent(channelParams?: API.ChannelParams) {\r\n  const { agent: _, ...paramsWithoutAgent } = channelParams || {};\r\n  return paramsWithoutAgent;\r\n}\r\n\r\nexport default RealtimeChannel;\r\n", "import * as Utils from '../util/utils';\r\nimport BaseClient from './baseclient';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport Connection from './connection';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport ProtocolMessage from '../types/protocolmessage';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport * as API from '../../../../ably';\r\nimport { ModularPlugins, RealtimePresencePlugin } from './modularplugins';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\nimport { TransportImplementations } from 'common/platform';\r\nimport Defaults from '../util/defaults';\r\n\r\n/**\r\n `BaseRealtime` is an export of the tree-shakable version of the SDK, and acts as the base class for the `DefaultRealtime` class exported by the non tree-shakable version.\r\n */\r\nclass BaseRealtime extends BaseClient {\r\n  readonly _RealtimePresence: RealtimePresencePlugin | null;\r\n  // Extra transport implementations available to this client, in addition to those in Platform.Transports.bundledImplementations\r\n  readonly _additionalTransportImplementations: TransportImplementations;\r\n  _channels: any;\r\n  connection: Connection;\r\n\r\n  /*\r\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\r\n   *\r\n   * 1. passes a string (which is quite likely if they\u2019re e.g. migrating from the default variant to the modular variant)\r\n   * 2. passes no argument at all\r\n   *\r\n   * tell the compiler that these cases are possible so that it forces us to handle them.\r\n   */\r\n  constructor(options?: ClientOptions | string) {\r\n    super(Defaults.objectifyOptions(options, false, 'BaseRealtime', Logger.defaultLogger));\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime()', '');\r\n\r\n    // currently we cannot support using Ably.Realtime instances in Vercel Edge runtime.\r\n    // this error can be removed after fixing https://github.com/ably/ably-js/issues/1731,\r\n    // and https://github.com/ably/ably-js/issues/1732\r\n    // @ts-ignore\r\n    if (typeof EdgeRuntime === 'string') {\r\n      throw new ErrorInfo(\r\n        `Ably.Realtime instance cannot be used in Vercel Edge runtime.` +\r\n          ` If you are running Vercel Edge functions, please replace your` +\r\n          ` \"new Ably.Realtime()\" with \"new Ably.Rest()\" and use Ably Rest API` +\r\n          ` instead of the Realtime API. If you are server-rendering your application` +\r\n          ` in the Vercel Edge runtime, please use the condition \"if (typeof EdgeRuntime === 'string')\"` +\r\n          ` to prevent instantiating Ably.Realtime instance during SSR in the Vercel Edge runtime.`,\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    this._additionalTransportImplementations = BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\r\n    this._RealtimePresence = this.options.plugins?.RealtimePresence ?? null;\r\n    this.connection = new Connection(this, this.options);\r\n    this._channels = new Channels(this);\r\n    if (this.options.autoConnect !== false) this.connect();\r\n  }\r\n\r\n  private static transportImplementationsFromPlugins(plugins?: ModularPlugins) {\r\n    const transports: TransportImplementations = {};\r\n\r\n    if (plugins?.WebSocketTransport) {\r\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\r\n    }\r\n    if (plugins?.XHRPolling) {\r\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\r\n    }\r\n\r\n    return transports;\r\n  }\r\n\r\n  get channels() {\r\n    return this._channels;\r\n  }\r\n\r\n  connect(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime.connect()', '');\r\n    this.connection.connect();\r\n  }\r\n\r\n  close(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'Realtime.close()', '');\r\n    this.connection.close();\r\n  }\r\n}\r\n\r\nclass Channels extends EventEmitter {\r\n  realtime: BaseRealtime;\r\n  all: Record<string, RealtimeChannel>;\r\n\r\n  constructor(realtime: BaseRealtime) {\r\n    super(realtime.logger);\r\n    this.realtime = realtime;\r\n    this.all = Object.create(null);\r\n    realtime.connection.connectionManager.on('transport.active', () => {\r\n      this.onTransportActive();\r\n    });\r\n  }\r\n\r\n  channelSerials(): { [name: string]: string } {\r\n    let serials: { [name: string]: string } = {};\r\n    for (const name of Utils.keysArray(this.all, true)) {\r\n      const channel = this.all[name];\r\n      if (channel.properties.channelSerial) {\r\n        serials[name] = channel.properties.channelSerial;\r\n      }\r\n    }\r\n    return serials;\r\n  }\r\n\r\n  // recoverChannels gets the given channels and sets their channel serials.\r\n  recoverChannels(channelSerials: { [name: string]: string }) {\r\n    for (const name of Utils.keysArray(channelSerials, true)) {\r\n      const channel = this.get(name);\r\n      channel.properties.channelSerial = channelSerials[name];\r\n    }\r\n  }\r\n\r\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\r\n  async processChannelMessage(msg: ProtocolMessage) {\r\n    const channelName = msg.channel;\r\n    if (channelName === undefined) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'Channels.processChannelMessage()',\r\n        'received event unspecified channel, action = ' + msg.action,\r\n      );\r\n      return;\r\n    }\r\n    const channel = this.all[channelName];\r\n    if (!channel) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'Channels.processChannelMessage()',\r\n        'received event for non-existent channel: ' + channelName,\r\n      );\r\n      return;\r\n    }\r\n    await channel.processMessage(msg);\r\n  }\r\n\r\n  /* called when a transport becomes connected; reattempt attach/detach\r\n   * for channels that are attaching or detaching. */\r\n  onTransportActive() {\r\n    for (const channelName in this.all) {\r\n      const channel = this.all[channelName];\r\n      if (channel.state === 'attaching' || channel.state === 'detaching') {\r\n        channel.checkPendingState();\r\n      } else if (channel.state === 'suspended') {\r\n        channel._attach(false, null);\r\n      } else if (channel.state === 'attached') {\r\n        // Note explicity request the state, channel.attach() would do nothing\r\n        // as its already attached.\r\n        channel.requestState('attaching');\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Connection interruptions (ie when the connection will no longer queue\r\n   * events) imply connection state changes for any channel which is either\r\n   * attached, pending, or will attempt to become attached in the future */\r\n  propogateConnectionInterruption(connectionState: string, reason: ErrorInfo) {\r\n    const connectionStateToChannelState: Record<string, API.ChannelState> = {\r\n      closing: 'detached',\r\n      closed: 'detached',\r\n      failed: 'failed',\r\n      suspended: 'suspended',\r\n    };\r\n    const fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];\r\n    const toChannelState = connectionStateToChannelState[connectionState];\r\n\r\n    for (const channelId in this.all) {\r\n      const channel = this.all[channelId];\r\n      if (fromChannelStates.includes(channel.state)) {\r\n        channel.notifyState(toChannelState, reason);\r\n      }\r\n    }\r\n  }\r\n\r\n  get(name: string, channelOptions?: ChannelOptions) {\r\n    name = String(name);\r\n    let channel = this.all[name];\r\n    if (!channel) {\r\n      channel = this.all[name] = new RealtimeChannel(this.realtime, name, channelOptions);\r\n    } else if (channelOptions) {\r\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\r\n        throw new ErrorInfo(\r\n          'Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.',\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n      channel.setOptions(channelOptions);\r\n    }\r\n    return channel;\r\n  }\r\n\r\n  getDerived(name: string, deriveOptions: API.DeriveOptions, channelOptions?: ChannelOptions) {\r\n    if (deriveOptions.filter) {\r\n      const filter = Utils.toBase64(deriveOptions.filter);\r\n      const match = Utils.matchDerivedChannel(name);\r\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\r\n    }\r\n    return this.get(name, channelOptions);\r\n  }\r\n\r\n  /* Included to support certain niche use-cases; most users should ignore this.\r\n   * Please do not use this unless you know what you're doing */\r\n  release(name: string) {\r\n    name = String(name);\r\n    const channel = this.all[name];\r\n    if (!channel) {\r\n      return;\r\n    }\r\n    const releaseErr = channel.getReleaseErr();\r\n    if (releaseErr) {\r\n      throw releaseErr;\r\n    }\r\n    delete this.all[name];\r\n  }\r\n}\r\n\r\nexport default BaseRealtime;\r\n", "import * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport PresenceMessage, {\r\n  fromValues as presenceMessageFromValues,\r\n  fromData as presenceMessageFromData,\r\n  encode as encodePresenceMessage,\r\n} from '../types/presencemessage';\r\nimport ErrorInfo, { PartialErrorInfo } from '../types/errorinfo';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport Multicaster from '../util/multicaster';\r\nimport ChannelStateChange from './channelstatechange';\r\nimport { CipherOptions } from '../types/message';\r\nimport { ErrCallback } from '../../types/utils';\r\nimport { PaginatedResult } from './paginatedresource';\r\n\r\ninterface RealtimePresenceParams {\r\n  waitForSync?: boolean;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n}\r\n\r\ninterface RealtimeHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n  untilAttach?: boolean;\r\n  from_serial?: string | null;\r\n}\r\n\r\nfunction getClientId(realtimePresence: RealtimePresence) {\r\n  return realtimePresence.channel.client.auth.clientId;\r\n}\r\n\r\nfunction isAnonymousOrWildcard(realtimePresence: RealtimePresence) {\r\n  const realtime = realtimePresence.channel.client;\r\n  /* If not currently connected, we can't assume that we're an anonymous\r\n   * client, as realtime may inform us of our clientId in the CONNECTED\r\n   * message. So assume we're not anonymous and leave it to realtime to\r\n   * return an error if we are */\r\n  const clientId = realtime.auth.clientId;\r\n  return (!clientId || clientId === '*') && realtime.connection.state === 'connected';\r\n}\r\n\r\n/* Callback is called only in the event of an error */\r\nfunction waitAttached(channel: RealtimeChannel, callback: ErrCallback, action: () => void) {\r\n  switch (channel.state) {\r\n    case 'attached':\r\n    case 'suspended':\r\n      action();\r\n      break;\r\n    case 'initialized':\r\n    case 'detached':\r\n    case 'detaching':\r\n    case 'attaching':\r\n      Utils.whenPromiseSettles(channel.attach(), function (err: Error | null) {\r\n        if (err) callback(err);\r\n        else action();\r\n      });\r\n      break;\r\n    default:\r\n      callback(ErrorInfo.fromValues(channel.invalidStateError()));\r\n  }\r\n}\r\n\r\nfunction newerThan(item: PresenceMessage, existing: PresenceMessage) {\r\n  /* RTP2b1: if either is synthesised, compare by timestamp */\r\n  if (item.isSynthesized() || existing.isSynthesized()) {\r\n    // RTP2b1a: if equal, prefer the newly-arrived one\r\n    return (item.timestamp as number) >= (existing.timestamp as number);\r\n  }\r\n\r\n  /* RTP2b2 */\r\n  const itemOrderings = item.parseId(),\r\n    existingOrderings = existing.parseId();\r\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\r\n    return itemOrderings.index > existingOrderings.index;\r\n  } else {\r\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\r\n  }\r\n}\r\n\r\nclass RealtimePresence extends EventEmitter {\r\n  channel: RealtimeChannel;\r\n  pendingPresence: { presence: PresenceMessage; callback: ErrCallback }[];\r\n  syncComplete: boolean;\r\n  members: PresenceMap;\r\n  _myMembers: PresenceMap;\r\n  subscriptions: EventEmitter;\r\n  name?: string;\r\n\r\n  constructor(channel: RealtimeChannel) {\r\n    super(channel.logger);\r\n    this.channel = channel;\r\n    this.syncComplete = false;\r\n    this.members = new PresenceMap(this, (item) => item.clientId + ':' + item.connectionId);\r\n    // RTP17h: Store own members by clientId only.\r\n    this._myMembers = new PresenceMap(this, (item) => item.clientId!);\r\n    this.subscriptions = new EventEmitter(this.logger);\r\n    this.pendingPresence = [];\r\n  }\r\n\r\n  async enter(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must be specified to enter a presence channel', 40012, 400);\r\n    }\r\n    return this._enterOrUpdateClient(undefined, undefined, data, 'enter');\r\n  }\r\n\r\n  async update(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must be specified to update presence data', 40012, 400);\r\n    }\r\n    return this._enterOrUpdateClient(undefined, undefined, data, 'update');\r\n  }\r\n\r\n  async enterClient(clientId: string, data: unknown): Promise<void> {\r\n    return this._enterOrUpdateClient(undefined, clientId, data, 'enter');\r\n  }\r\n\r\n  async updateClient(clientId: string, data: unknown): Promise<void> {\r\n    return this._enterOrUpdateClient(undefined, clientId, data, 'update');\r\n  }\r\n\r\n  async _enterOrUpdateClient(\r\n    id: string | undefined,\r\n    clientId: string | undefined,\r\n    data: unknown,\r\n    action: string,\r\n  ): Promise<void> {\r\n    const channel = this.channel;\r\n    if (!channel.connectionManager.activeState()) {\r\n      throw channel.connectionManager.getError();\r\n    }\r\n\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.' + action + 'Client()',\r\n      'channel = ' + channel.name + ', id = ' + id + ', client = ' + (clientId || '(implicit) ' + getClientId(this)),\r\n    );\r\n\r\n    const presence = presenceMessageFromData(data);\r\n    presence.action = action;\r\n    if (id) {\r\n      presence.id = id;\r\n    }\r\n    if (clientId) {\r\n      presence.clientId = clientId;\r\n    }\r\n\r\n    await encodePresenceMessage(presence, channel.channelOptions as CipherOptions);\r\n    switch (channel.state) {\r\n      case 'attached':\r\n        return new Promise((resolve, reject) => {\r\n          channel.sendPresence(presence, (err) => (err ? reject(err) : resolve()));\r\n        });\r\n      case 'initialized':\r\n      case 'detached':\r\n        channel.attach();\r\n      // eslint-disable-next-line no-fallthrough\r\n      case 'attaching':\r\n        return new Promise((resolve, reject) => {\r\n          this.pendingPresence.push({\r\n            presence: presence,\r\n            callback: (err) => (err ? reject(err) : resolve()),\r\n          });\r\n        });\r\n      default: {\r\n        const err = new PartialErrorInfo(\r\n          'Unable to ' + action + ' presence channel while in ' + channel.state + ' state',\r\n          90001,\r\n        );\r\n        err.code = 90001;\r\n        throw err;\r\n      }\r\n    }\r\n  }\r\n\r\n  async leave(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must have been specified to enter or leave a presence channel', 40012, 400);\r\n    }\r\n    return this.leaveClient(undefined, data);\r\n  }\r\n\r\n  async leaveClient(clientId?: string, data?: unknown): Promise<void> {\r\n    const channel = this.channel;\r\n    if (!channel.connectionManager.activeState()) {\r\n      throw channel.connectionManager.getError();\r\n    }\r\n\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.leaveClient()',\r\n      'leaving; channel = ' + this.channel.name + ', client = ' + clientId,\r\n    );\r\n    const presence = presenceMessageFromData(data);\r\n    presence.action = 'leave';\r\n    if (clientId) {\r\n      presence.clientId = clientId;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      switch (channel.state) {\r\n        case 'attached':\r\n          channel.sendPresence(presence, (err) => (err ? reject(err) : resolve()));\r\n          break;\r\n        case 'attaching':\r\n          this.pendingPresence.push({\r\n            presence: presence,\r\n            callback: (err) => (err ? reject(err) : resolve()),\r\n          });\r\n          break;\r\n        case 'initialized':\r\n        case 'failed': {\r\n          /* we're not attached; therefore we let any entered status\r\n           * timeout by itself instead of attaching just in order to leave */\r\n          const err = new PartialErrorInfo('Unable to leave presence channel (incompatible state)', 90001);\r\n          reject(err);\r\n          break;\r\n        }\r\n        default:\r\n          reject(channel.invalidStateError());\r\n      }\r\n    });\r\n  }\r\n\r\n  async get(params?: RealtimePresenceParams): Promise<PresenceMessage[]> {\r\n    const waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      function returnMembers(members: PresenceMap) {\r\n        resolve(params ? members.list(params) : members.values());\r\n      }\r\n\r\n      /* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */\r\n      if (this.channel.state === 'suspended') {\r\n        if (waitForSync) {\r\n          reject(\r\n            ErrorInfo.fromValues({\r\n              statusCode: 400,\r\n              code: 91005,\r\n              message: 'Presence state is out of sync due to channel being in the SUSPENDED state',\r\n            }),\r\n          );\r\n        } else {\r\n          returnMembers(this.members);\r\n        }\r\n        return;\r\n      }\r\n\r\n      waitAttached(\r\n        this.channel,\r\n        (err) => reject(err),\r\n        () => {\r\n          const members = this.members;\r\n          if (waitForSync) {\r\n            members.waitSync(function () {\r\n              returnMembers(members);\r\n            });\r\n          } else {\r\n            returnMembers(members);\r\n          }\r\n        },\r\n      );\r\n    });\r\n  }\r\n\r\n  async history(params: RealtimeHistoryParams | null): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);\r\n    // We fetch this first so that any plugin-not-provided error takes priority over other errors\r\n    const restMixin = this.channel.client.rest.presenceMixin;\r\n\r\n    if (params && params.untilAttach) {\r\n      if (this.channel.state === 'attached') {\r\n        delete params.untilAttach;\r\n        params.from_serial = this.channel.properties.attachSerial;\r\n      } else {\r\n        throw new ErrorInfo(\r\n          'option untilAttach requires the channel to be attached, was: ' + this.channel.state,\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n    }\r\n\r\n    return restMixin.history(this, params);\r\n  }\r\n\r\n  setPresence(presenceSet: PresenceMessage[], isSync: boolean, syncChannelSerial?: string): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.setPresence()',\r\n      'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial,\r\n    );\r\n    let syncCursor, match;\r\n    const members = this.members,\r\n      myMembers = this._myMembers,\r\n      broadcastMessages = [],\r\n      connId = this.channel.connectionManager.connectionId;\r\n\r\n    if (isSync) {\r\n      this.members.startSync();\r\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\r\n        syncCursor = match[1];\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < presenceSet.length; i++) {\r\n      const presence = presenceMessageFromValues(presenceSet[i]);\r\n      switch (presence.action) {\r\n        case 'leave':\r\n          if (members.remove(presence)) {\r\n            broadcastMessages.push(presence);\r\n          }\r\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\r\n            myMembers.remove(presence);\r\n          }\r\n          break;\r\n        case 'enter':\r\n        case 'present':\r\n        case 'update':\r\n          if (members.put(presence)) {\r\n            broadcastMessages.push(presence);\r\n          }\r\n          if (presence.connectionId === connId) {\r\n            myMembers.put(presence);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    /* if this is the last (or only) message in a sequence of sync updates, end the sync */\r\n    if (isSync && !syncCursor) {\r\n      members.endSync();\r\n      this.channel.syncChannelSerial = null;\r\n    }\r\n\r\n    /* broadcast to listeners */\r\n    for (let i = 0; i < broadcastMessages.length; i++) {\r\n      const presence = broadcastMessages[i];\r\n      this.subscriptions.emit(presence.action as string, presence);\r\n    }\r\n  }\r\n\r\n  onAttached(hasPresence?: boolean): void {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'RealtimePresence.onAttached()',\r\n      'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence,\r\n    );\r\n\r\n    if (hasPresence) {\r\n      this.members.startSync();\r\n    } else {\r\n      this._synthesizeLeaves(this.members.values());\r\n      this.members.clear();\r\n    }\r\n\r\n    // RTP17f: Re-enter own members when moving into the attached state.\r\n    this._ensureMyMembersPresent();\r\n\r\n    /* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */\r\n    const pendingPresence = this.pendingPresence,\r\n      pendingPresCount = pendingPresence.length;\r\n\r\n    if (pendingPresCount) {\r\n      this.pendingPresence = [];\r\n      const presenceArray = [];\r\n      const multicaster = Multicaster.create(this.logger);\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'RealtimePresence.onAttached',\r\n        'sending ' + pendingPresCount + ' queued presence messages',\r\n      );\r\n      for (let i = 0; i < pendingPresCount; i++) {\r\n        const event = pendingPresence[i];\r\n        presenceArray.push(event.presence);\r\n        multicaster.push(event.callback);\r\n      }\r\n      this.channel.sendPresence(presenceArray, multicaster);\r\n    }\r\n  }\r\n\r\n  actOnChannelState(state: string, hasPresence?: boolean, err?: ErrorInfo | null): void {\r\n    switch (state) {\r\n      case 'attached':\r\n        this.onAttached(hasPresence);\r\n        break;\r\n      case 'detached':\r\n      case 'failed':\r\n        this._clearMyMembers();\r\n        this.members.clear();\r\n      /* falls through */\r\n      case 'suspended':\r\n        this.failPendingPresence(err);\r\n        break;\r\n    }\r\n  }\r\n\r\n  failPendingPresence(err?: ErrorInfo | null): void {\r\n    if (this.pendingPresence.length) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'RealtimeChannel.failPendingPresence',\r\n        'channel; name = ' + this.channel.name + ', err = ' + Utils.inspectError(err),\r\n      );\r\n      for (let i = 0; i < this.pendingPresence.length; i++)\r\n        try {\r\n          this.pendingPresence[i].callback(err);\r\n          // eslint-disable-next-line no-empty\r\n        } catch (e) {}\r\n      this.pendingPresence = [];\r\n    }\r\n  }\r\n\r\n  _clearMyMembers(): void {\r\n    this._myMembers.clear();\r\n  }\r\n\r\n  _ensureMyMembersPresent(): void {\r\n    const myMembers = this._myMembers,\r\n      reenterCb = (err?: ErrorInfo | null) => {\r\n        if (err) {\r\n          const msg = 'Presence auto-re-enter failed: ' + err.toString();\r\n          const wrappedErr = new ErrorInfo(msg, 91004, 400);\r\n          Logger.logAction(this.logger, Logger.LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);\r\n          const change = new ChannelStateChange(this.channel.state, this.channel.state, true, false, wrappedErr);\r\n          this.channel.emit('update', change);\r\n        }\r\n      };\r\n\r\n    for (const memberKey in myMembers.map) {\r\n      const entry = myMembers.map[memberKey];\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MICRO,\r\n        'RealtimePresence._ensureMyMembersPresent()',\r\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set',\r\n      );\r\n      // RTP17g: Send ENTER containing the member id, clientId and data\r\n      // attributes.\r\n      Utils.whenPromiseSettles(this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, 'enter'), reenterCb);\r\n    }\r\n  }\r\n\r\n  _synthesizeLeaves(items: PresenceMessage[]): void {\r\n    const subscriptions = this.subscriptions;\r\n    items.forEach(function (item) {\r\n      const presence = presenceMessageFromValues({\r\n        action: 'leave',\r\n        connectionId: item.connectionId,\r\n        clientId: item.clientId,\r\n        data: item.data,\r\n        encoding: item.encoding,\r\n        timestamp: Date.now(),\r\n      });\r\n      subscriptions.emit('leave', presence);\r\n    });\r\n  }\r\n\r\n  async subscribe(..._args: unknown[] /* [event], listener */): Promise<void> {\r\n    const args = RealtimeChannel.processListenerArgs(_args);\r\n    const event = args[0];\r\n    const listener = args[1];\r\n    const channel = this.channel;\r\n\r\n    if (channel.state === 'failed') {\r\n      throw ErrorInfo.fromValues(channel.invalidStateError());\r\n    }\r\n\r\n    this.subscriptions.on(event, listener);\r\n    await channel.attach();\r\n  }\r\n\r\n  unsubscribe(..._args: unknown[] /* [event], listener */): void {\r\n    const args = RealtimeChannel.processListenerArgs(_args);\r\n    const event = args[0];\r\n    const listener = args[1];\r\n    this.subscriptions.off(event, listener);\r\n  }\r\n}\r\n\r\nclass PresenceMap extends EventEmitter {\r\n  map: Record<string, PresenceMessage>;\r\n  residualMembers: Record<string, PresenceMessage> | null;\r\n  syncInProgress: boolean;\r\n  presence: RealtimePresence;\r\n  memberKey: (item: PresenceMessage) => string;\r\n\r\n  constructor(presence: RealtimePresence, memberKey: (item: PresenceMessage) => string) {\r\n    super(presence.logger);\r\n    this.presence = presence;\r\n    this.map = Object.create(null);\r\n    this.syncInProgress = false;\r\n    this.residualMembers = null;\r\n    this.memberKey = memberKey;\r\n  }\r\n\r\n  get(key: string) {\r\n    return this.map[key];\r\n  }\r\n\r\n  getClient(clientId: string) {\r\n    const map = this.map,\r\n      result = [];\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.clientId == clientId && item.action != 'absent') result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  list(params: RealtimePresenceParams) {\r\n    const map = this.map,\r\n      clientId = params && params.clientId,\r\n      connectionId = params && params.connectionId,\r\n      result = [];\r\n\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.action === 'absent') continue;\r\n      if (clientId && clientId != item.clientId) continue;\r\n      if (connectionId && connectionId != item.connectionId) continue;\r\n      result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  put(item: PresenceMessage) {\r\n    if (item.action === 'enter' || item.action === 'update') {\r\n      item = presenceMessageFromValues(item);\r\n      item.action = 'present';\r\n    }\r\n    const map = this.map,\r\n      key = this.memberKey(item);\r\n    /* we've seen this member, so do not remove it at the end of sync */\r\n    if (this.residualMembers) delete this.residualMembers[key];\r\n\r\n    /* compare the timestamp of the new item with any existing member (or ABSENT witness) */\r\n    const existingItem = map[key];\r\n    if (existingItem && !newerThan(item, existingItem)) {\r\n      return false;\r\n    }\r\n    map[key] = item;\r\n    return true;\r\n  }\r\n\r\n  values() {\r\n    const map = this.map,\r\n      result = [];\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.action != 'absent') result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  remove(item: PresenceMessage) {\r\n    const map = this.map,\r\n      key = this.memberKey(item);\r\n    const existingItem = map[key];\r\n\r\n    if (existingItem && !newerThan(item, existingItem)) {\r\n      return false;\r\n    }\r\n\r\n    /* RTP2f */\r\n    if (this.syncInProgress) {\r\n      item = presenceMessageFromValues(item);\r\n      item.action = 'absent';\r\n      map[key] = item;\r\n    } else {\r\n      delete map[key];\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  startSync() {\r\n    const map = this.map,\r\n      syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.startSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    /* we might be called multiple times while a sync is in progress */\r\n    if (!this.syncInProgress) {\r\n      this.residualMembers = Utils.copy(map);\r\n      this.setInProgress(true);\r\n    }\r\n  }\r\n\r\n  endSync() {\r\n    const map = this.map,\r\n      syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.endSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    if (syncInProgress) {\r\n      /* we can now strip out the ABSENT members, as we have\r\n       * received all of the out-of-order sync messages */\r\n      for (const memberKey in map) {\r\n        const entry = map[memberKey];\r\n        if (entry.action === 'absent') {\r\n          delete map[memberKey];\r\n        }\r\n      }\r\n      /* any members that were present at the start of the sync,\r\n       * and have not been seen in sync, can be removed, and leave events emitted */\r\n      this.presence._synthesizeLeaves(Utils.valuesArray(this.residualMembers as Record<string, PresenceMessage>));\r\n      for (const memberKey in this.residualMembers) {\r\n        delete map[memberKey];\r\n      }\r\n      this.residualMembers = null;\r\n\r\n      /* finish, notifying any waiters */\r\n      this.setInProgress(false);\r\n    }\r\n    this.emit('sync');\r\n  }\r\n\r\n  waitSync(callback: () => void) {\r\n    const syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.waitSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    if (!syncInProgress) {\r\n      callback();\r\n      return;\r\n    }\r\n    this.once('sync', callback);\r\n  }\r\n\r\n  clear() {\r\n    this.map = {};\r\n    this.setInProgress(false);\r\n    this.residualMembers = null;\r\n  }\r\n\r\n  setInProgress(inProgress: boolean) {\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);\r\n    this.syncInProgress = inProgress;\r\n    this.presence.syncComplete = !inProgress;\r\n  }\r\n}\r\n\r\nexport default RealtimePresence;\r\n", "import Platform from 'common/platform';\r\nimport * as Utils from '../util/utils';\r\nimport Transport from './transport';\r\nimport Defaults from '../util/defaults';\r\nimport Logger from '../util/logger';\r\nimport ProtocolMessage, {\r\n  serialize as serializeProtocolMessage,\r\n  deserialize as deserializeProtocolMessage,\r\n} from '../types/protocolmessage';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport NodeWebSocket from 'ws';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport Auth from '../client/auth';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nconst shortName = TransportNames.WebSocket;\r\n\r\nfunction isNodeWebSocket(ws: WebSocket | NodeWebSocket): ws is NodeWebSocket {\r\n  return !!(ws as NodeWebSocket).on;\r\n}\r\n\r\nclass WebSocketTransport extends Transport {\r\n  shortName = shortName;\r\n  wsHost: string;\r\n  uri?: string;\r\n  wsConnection?: WebSocket | NodeWebSocket;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params);\r\n    /* If is a browser, can't detect pings, so request protocol heartbeats */\r\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\r\n    this.wsHost = params.host as string;\r\n  }\r\n\r\n  static isAvailable() {\r\n    return !!Platform.Config.WebSocket;\r\n  }\r\n\r\n  createWebSocket(uri: string, connectParams: Record<string, string>) {\r\n    this.uri = uri + Utils.toQueryString(connectParams);\r\n    return new Platform.Config.WebSocket(this.uri);\r\n  }\r\n\r\n  toString() {\r\n    return 'WebSocketTransport; uri=' + this.uri;\r\n  }\r\n\r\n  connect() {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'starting');\r\n    Transport.prototype.connect.call(this);\r\n    const self = this,\r\n      params = this.params,\r\n      options = params.options;\r\n    const wsScheme = options.tls ? 'wss://' : 'ws://';\r\n    const wsUri = wsScheme + this.wsHost + ':' + Defaults.getPort(options) + '/';\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);\r\n    Utils.whenPromiseSettles(\r\n      this.auth.getAuthParams(),\r\n      function (err: ErrorInfo | null, authParams?: Record<string, string>) {\r\n        if (self.isDisposed) {\r\n          return;\r\n        }\r\n        let paramStr = '';\r\n        for (const param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';\r\n        Logger.logAction(\r\n          self.logger,\r\n          Logger.LOG_MINOR,\r\n          'WebSocketTransport.connect()',\r\n          'authParams:' + paramStr + ' err: ' + err,\r\n        );\r\n        if (err) {\r\n          self.disconnect(err);\r\n          return;\r\n        }\r\n        const connectParams = params.getConnectParams(authParams!);\r\n        try {\r\n          const wsConnection = (self.wsConnection = self.createWebSocket(wsUri, connectParams));\r\n          wsConnection.binaryType = Platform.Config.binaryType;\r\n          wsConnection.onopen = function () {\r\n            self.onWsOpen();\r\n          };\r\n          wsConnection.onclose = function (ev: CloseEvent) {\r\n            self.onWsClose(ev);\r\n          };\r\n          wsConnection.onmessage = function (ev: MessageEvent) {\r\n            self.onWsData(ev.data);\r\n          };\r\n          wsConnection.onerror = function (ev: Event) {\r\n            self.onWsError(ev as ErrorEvent);\r\n          };\r\n          if (isNodeWebSocket(wsConnection)) {\r\n            /* node; browsers currently don't have a general eventemitter and can't detect\r\n             * pings. Also, no need to reply with a pong explicitly, ws lib handles that */\r\n            wsConnection.on('ping', function () {\r\n              self.onActivity();\r\n            });\r\n          }\r\n        } catch (e) {\r\n          Logger.logAction(\r\n            self.logger,\r\n            Logger.LOG_ERROR,\r\n            'WebSocketTransport.connect()',\r\n            'Unexpected exception creating websocket: err = ' + ((e as Error).stack || (e as Error).message),\r\n          );\r\n          self.disconnect(e as Error);\r\n        }\r\n      },\r\n    );\r\n  }\r\n\r\n  send(message: ProtocolMessage) {\r\n    const wsConnection = this.wsConnection;\r\n    if (!wsConnection) {\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');\r\n      return;\r\n    }\r\n    try {\r\n      (wsConnection as NodeWebSocket).send(\r\n        serializeProtocolMessage(message, this.connectionManager.realtime._MsgPack, this.params.format),\r\n      );\r\n    } catch (e) {\r\n      const msg = 'Exception from ws connection when trying to send: ' + Utils.inspectError(e);\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'WebSocketTransport.send()', msg);\r\n      /* Don't try to request a disconnect, that'll just involve sending data\r\n       * down the websocket again. Just finish the transport. */\r\n      this.finish('disconnected', new ErrorInfo(msg, 50000, 500));\r\n    }\r\n  }\r\n\r\n  onWsData(data: string) {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MICRO,\r\n      'WebSocketTransport.onWsData()',\r\n      'data received; length = ' + data.length + '; type = ' + typeof data,\r\n    );\r\n    try {\r\n      this.onProtocolMessage(\r\n        deserializeProtocolMessage(\r\n          data,\r\n          this.connectionManager.realtime._MsgPack,\r\n          this.connectionManager.realtime._RealtimePresence,\r\n          this.format,\r\n        ),\r\n      );\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'WebSocketTransport.onWsData()',\r\n        'Unexpected exception handing channel message: ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  onWsOpen() {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');\r\n    this.emit('preconnect');\r\n  }\r\n\r\n  onWsClose(ev: number | CloseEvent) {\r\n    let wasClean, code;\r\n    if (typeof ev == 'object') {\r\n      /* W3C spec-compatible */\r\n      code = ev.code;\r\n      // ev.wasClean is undefined in reactnative\r\n      wasClean = ev.wasClean || code === 1000;\r\n    } /*if(typeof(ev) == 'number')*/ else {\r\n      /* ws in node */\r\n      code = ev;\r\n      wasClean = code == 1000;\r\n    }\r\n    delete this.wsConnection;\r\n    if (wasClean) {\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');\r\n      const err = new ErrorInfo('Websocket closed', 80003, 400);\r\n      this.finish('disconnected', err);\r\n    } else {\r\n      const msg = 'Unclean disconnection of WebSocket ; code = ' + code,\r\n        err = new ErrorInfo(msg, 80003, 400);\r\n      Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);\r\n      this.finish('disconnected', err);\r\n    }\r\n    this.emit('disposed');\r\n  }\r\n\r\n  onWsError(err: ErrorEvent) {\r\n    Logger.logAction(\r\n      this.logger,\r\n      Logger.LOG_MINOR,\r\n      'WebSocketTransport.onError()',\r\n      'Error from WebSocket: ' + err.message,\r\n    );\r\n    /* Wait a tick before aborting: if the websocket was connected, this event\r\n     * will be immediately followed by an onclose event with a close code. Allow\r\n     * that to close it (so we see the close code) rather than anticipating it */\r\n    Platform.Config.nextTick(() => {\r\n      this.disconnect(Error(err.message));\r\n    });\r\n  }\r\n\r\n  dispose() {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'WebSocketTransport.dispose()', '');\r\n    this.isDisposed = true;\r\n    const wsConnection = this.wsConnection;\r\n    if (wsConnection) {\r\n      /* Ignore any messages that come through after dispose() is called but before\r\n       * websocket is actually closed. (mostly would be harmless, but if it's a\r\n       * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */\r\n      wsConnection.onmessage = function () {};\r\n      delete this.wsConnection;\r\n      /* defer until the next event loop cycle before closing the socket,\r\n       * giving some implementations the opportunity to send any outstanding close message */\r\n      Platform.Config.nextTick(() => {\r\n        Logger.logAction(this.logger, Logger.LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');\r\n        if (!wsConnection) {\r\n          throw new Error('WebSocketTransport.dispose(): wsConnection is not defined');\r\n        }\r\n        wsConnection.close();\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport default WebSocketTransport;\r\n", "import * as API from '../../../../ably';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport Message from '../types/message';\r\n\r\nexport class FilteredSubscriptions {\r\n  static subscribeFilter(channel: RealtimeChannel, filter: API.MessageFilter, listener: API.messageCallback<Message>) {\r\n    const filteredListener = (m: Message) => {\r\n      const mapping: { [key in keyof API.MessageFilter]: any } = {\r\n        name: m.name,\r\n        refTimeserial: m.extras?.ref?.timeserial,\r\n        refType: m.extras?.ref?.type,\r\n        isRef: !!m.extras?.ref?.timeserial,\r\n        clientId: m.clientId,\r\n      };\r\n      // Check if any values are defined in the filter and if they match the value in the message object\r\n      if (\r\n        Object.entries(filter).find(([key, value]) =>\r\n          value !== undefined ? mapping[key as keyof API.MessageFilter] !== value : false,\r\n        )\r\n      ) {\r\n        return;\r\n      }\r\n      listener(m);\r\n    };\r\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\r\n    channel.subscriptions.on(filteredListener);\r\n  }\r\n\r\n  // Adds a new filtered subscription\r\n  static addFilteredSubscription(\r\n    channel: RealtimeChannel,\r\n    filter: API.MessageFilter,\r\n    realListener: API.messageCallback<Message>,\r\n    filteredListener: API.messageCallback<Message>,\r\n  ) {\r\n    if (!channel.filteredSubscriptions) {\r\n      channel.filteredSubscriptions = new Map<\r\n        API.messageCallback<Message>,\r\n        Map<API.MessageFilter, API.messageCallback<Message>[]>\r\n      >();\r\n    }\r\n    if (channel.filteredSubscriptions.has(realListener)) {\r\n      const realListenerMap = channel.filteredSubscriptions.get(realListener) as Map<\r\n        API.MessageFilter,\r\n        API.messageCallback<Message>[]\r\n      >;\r\n      // Add the filtered listener to the map, or append to the array if this filter has already been used\r\n      realListenerMap.set(filter, realListenerMap?.get(filter)?.concat(filteredListener) || [filteredListener]);\r\n    } else {\r\n      channel.filteredSubscriptions.set(\r\n        realListener,\r\n        new Map<API.MessageFilter, API.messageCallback<Message>[]>([[filter, [filteredListener]]]),\r\n      );\r\n    }\r\n  }\r\n\r\n  static getAndDeleteFilteredSubscriptions(\r\n    channel: RealtimeChannel,\r\n    filter: API.MessageFilter | undefined,\r\n    realListener: API.messageCallback<Message> | undefined,\r\n  ): API.messageCallback<Message>[] {\r\n    // No filtered subscriptions map means there has been no filtered subscriptions yet, so return nothing\r\n    if (!channel.filteredSubscriptions) {\r\n      return [];\r\n    }\r\n    // Only a filter is passed in with no specific listener\r\n    if (!realListener && filter) {\r\n      // Return each listener which is attached to the specified filter object\r\n      return Array.from(channel.filteredSubscriptions.entries())\r\n        .map(([key, filterMaps]) => {\r\n          // Get (then delete) the maps matching this filter\r\n          let listenerMaps = filterMaps.get(filter);\r\n          filterMaps.delete(filter);\r\n          // Clear the parent if nothing is left\r\n          if (filterMaps.size === 0) {\r\n            channel.filteredSubscriptions?.delete(key);\r\n          }\r\n          return listenerMaps;\r\n        })\r\n        .reduce(\r\n          (prev, cur) => (cur ? (prev as API.messageCallback<Message>[]).concat(...cur) : prev),\r\n          [],\r\n        ) as API.messageCallback<Message>[];\r\n    }\r\n\r\n    // No subscriptions for this listener\r\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\r\n      return [];\r\n    }\r\n    const realListenerMap = channel.filteredSubscriptions.get(realListener) as Map<\r\n      API.MessageFilter,\r\n      API.messageCallback<Message>[]\r\n    >;\r\n    // If no filter is specified return all listeners using that function\r\n    if (!filter) {\r\n      // array.flat is not available unless we support es2019 or higher\r\n      const listeners = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\r\n      // remove the listener from the map\r\n      channel.filteredSubscriptions.delete(realListener);\r\n      return listeners;\r\n    }\r\n\r\n    let listeners = realListenerMap.get(filter);\r\n    realListenerMap.delete(filter);\r\n\r\n    return listeners || [];\r\n  }\r\n}\r\n", "import BaseRealtime from './baserealtime';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { allCommonModularPlugins } from './modularplugins';\r\nimport * as Utils from '../util/utils';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport ProtocolMessage from '../types/protocolmessage';\r\nimport Platform from 'common/platform';\r\nimport { DefaultMessage } from '../types/defaultmessage';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport RealtimePresence from './realtimepresence';\r\nimport { DefaultPresenceMessage } from '../types/defaultpresencemessage';\r\nimport WebSocketTransport from '../transport/websockettransport';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\nimport {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from '../types/presencemessage';\r\nimport { Http } from 'common/types/http';\r\nimport Defaults from '../util/defaults';\r\nimport Logger from '../util/logger';\r\n\r\n/**\r\n `DefaultRealtime` is the class that the non tree-shakable version of the SDK exports as `Realtime`. It ensures that this version of the SDK includes all of the functionality which is optionally available in the tree-shakable version.\r\n */\r\nexport class DefaultRealtime extends BaseRealtime {\r\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\r\n  constructor(options?: ClientOptions | string) {\r\n    const MsgPack = DefaultRealtime._MsgPack;\r\n    if (!MsgPack) {\r\n      throw new Error('Expected DefaultRealtime._MsgPack to have been set');\r\n    }\r\n\r\n    super(\r\n      Defaults.objectifyOptions(options, true, 'Realtime', Logger.defaultLogger, {\r\n        ...allCommonModularPlugins,\r\n        Crypto: DefaultRealtime.Crypto ?? undefined,\r\n        MsgPack,\r\n        RealtimePresence: {\r\n          RealtimePresence,\r\n          presenceMessageFromValues,\r\n          presenceMessagesFromValuesArray,\r\n        },\r\n        WebSocketTransport,\r\n        MessageInteractions: FilteredSubscriptions,\r\n      }),\r\n    );\r\n  }\r\n\r\n  static Utils = Utils;\r\n  static ConnectionManager = ConnectionManager;\r\n  static ProtocolMessage = ProtocolMessage;\r\n\r\n  private static _Crypto: typeof Platform.Crypto = null;\r\n  static get Crypto() {\r\n    if (this._Crypto === null) {\r\n      throw new Error('Encryption not enabled; use ably.encryption.js instead');\r\n    }\r\n\r\n    return this._Crypto;\r\n  }\r\n  static set Crypto(newValue: typeof Platform.Crypto) {\r\n    this._Crypto = newValue;\r\n  }\r\n\r\n  static Message = DefaultMessage;\r\n  static PresenceMessage = DefaultPresenceMessage;\r\n\r\n  static _MsgPack: MsgPack | null = null;\r\n\r\n  // Used by tests\r\n  static _Http = Http;\r\n}\r\n", "/**\r\n * Copied from https://gist.github.com/stevendesu/2d52f7b5e1f1184af3b667c0b5e054b8\r\n *\r\n * \"A simple, open-source, HMAC-SHA256 implementation in pure JavaScript. Designed for efficient minification.\"\r\n *\r\n * I asked about licensing, and the author said:\r\n *\r\n * > Feel free to use it however you'd like \uD83D\uDE04 As the gist title indicates,\r\n * > this is \"a simple open source implementation\". Feel free to choose whatever\r\n * > license you find most permissible, but I offer no warranty for the code.\r\n * > It's 100% free to do with as you please.\r\n */\r\n\r\n// To ensure cross-browser support even without a proper SubtleCrypto\r\n// impelmentation (or without access to the impelmentation, as is the case with\r\n// Chrome loaded over HTTP instead of HTTPS), this library can create SHA-256\r\n// HMAC signatures using nothing but raw JavaScript\r\n\r\n/* eslint-disable no-magic-numbers, id-length, no-param-reassign, new-cap */\r\n\r\n// By giving internal functions names that we can mangle, future calls to\r\n// them are reduced to a single byte (minor space savings in minified file)\r\nvar uint8Array = Uint8Array;\r\nvar uint32Array = Uint32Array;\r\nvar pow = Math.pow;\r\n\r\n// Will be initialized below\r\n// Using a Uint32Array instead of a simple array makes the minified code\r\n// a bit bigger (we lose our `unshift()` hack), but comes with huge\r\n// performance gains\r\nvar DEFAULT_STATE = new uint32Array(8);\r\nvar ROUND_CONSTANTS: number[] = [];\r\n\r\n// Reusable object for expanded message\r\n// Using a Uint32Array instead of a simple array makes the minified code\r\n// 7 bytes larger, but comes with huge performance gains\r\nvar M = new uint32Array(64);\r\n\r\n// After minification the code to compute the default state and round\r\n// constants is smaller than the output. More importantly, this serves as a\r\n// good educational aide for anyone wondering where the magic numbers come\r\n// from. No magic numbers FTW!\r\nfunction getFractionalBits(n: number) {\r\n  return ((n - (n | 0)) * pow(2, 32)) | 0;\r\n}\r\n\r\nvar n = 2,\r\n  nPrime = 0;\r\nwhile (nPrime < 64) {\r\n  // isPrime() was in-lined from its original function form to save\r\n  // a few bytes\r\n  var isPrime = true;\r\n  // Math.sqrt() was replaced with pow(n, 1/2) to save a few bytes\r\n  // var sqrtN = pow(n, 1 / 2);\r\n  // So technically to determine if a number is prime you only need to\r\n  // check numbers up to the square root. However this function only runs\r\n  // once and we're only computing the first 64 primes (up to 311), so on\r\n  // any modern CPU this whole function runs in a couple milliseconds.\r\n  // By going to n / 2 instead of sqrt(n) we net 8 byte savings and no\r\n  // scaling performance cost\r\n  for (var factor = 2; factor <= n / 2; factor++) {\r\n    if (n % factor === 0) {\r\n      isPrime = false;\r\n    }\r\n  }\r\n  if (isPrime) {\r\n    if (nPrime < 8) {\r\n      DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));\r\n    }\r\n    ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));\r\n\r\n    nPrime++;\r\n  }\r\n\r\n  n++;\r\n}\r\n\r\n// For cross-platform support we need to ensure that all 32-bit words are\r\n// in the same endianness. A UTF-8 TextEncoder will return BigEndian data,\r\n// so upon reading or writing to our ArrayBuffer we'll only swap the bytes\r\n// if our system is LittleEndian (which is about 99% of CPUs)\r\nvar LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];\r\n\r\nfunction convertEndian(word: number) {\r\n  if (LittleEndian) {\r\n    return (\r\n      // byte 1 -> byte 4\r\n      (word >>> 24) |\r\n      // byte 2 -> byte 3\r\n      (((word >>> 16) & 0xff) << 8) |\r\n      // byte 3 -> byte 2\r\n      ((word & 0xff00) << 8) |\r\n      // byte 4 -> byte 1\r\n      (word << 24)\r\n    );\r\n  } else {\r\n    return word;\r\n  }\r\n}\r\n\r\nfunction rightRotate(word: number, bits: number) {\r\n  return (word >>> bits) | (word << (32 - bits));\r\n}\r\n\r\nfunction sha256(data: Uint8Array) {\r\n  // Copy default state\r\n  var STATE = DEFAULT_STATE.slice();\r\n\r\n  // Caching this reduces occurrences of \".length\" in minified JavaScript\r\n  // 3 more byte savings! :D\r\n  var legth = data.length;\r\n\r\n  // Pad data\r\n  var bitLength = legth * 8;\r\n  var newBitLength = 512 - ((bitLength + 64) % 512) - 1 + bitLength + 65;\r\n\r\n  // \"bytes\" and \"words\" are stored BigEndian\r\n  var bytes = new uint8Array(newBitLength / 8);\r\n  var words = new uint32Array(bytes.buffer);\r\n\r\n  bytes.set(data, 0);\r\n  // Append a 1\r\n  bytes[legth] = 0b10000000;\r\n  // Store length in BigEndian\r\n  words[words.length - 1] = convertEndian(bitLength);\r\n\r\n  // Loop iterator (avoid two instances of \"var\") -- saves 2 bytes\r\n  var round;\r\n\r\n  // Process blocks (512 bits / 64 bytes / 16 words at a time)\r\n  for (var block = 0; block < newBitLength / 32; block += 16) {\r\n    var workingState = STATE.slice();\r\n\r\n    // Rounds\r\n    for (round = 0; round < 64; round++) {\r\n      var MRound;\r\n      // Expand message\r\n      if (round < 16) {\r\n        // Convert to platform Endianness for later math\r\n        MRound = convertEndian(words[block + round]);\r\n      } else {\r\n        var gamma0x = M[round - 15];\r\n        var gamma1x = M[round - 2];\r\n        MRound =\r\n          M[round - 7] +\r\n          M[round - 16] +\r\n          (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ (gamma0x >>> 3)) +\r\n          (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ (gamma1x >>> 10));\r\n      }\r\n\r\n      // M array matches platform endianness\r\n      M[round] = MRound |= 0;\r\n\r\n      // Computation\r\n      var t1 =\r\n        (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) +\r\n        ((workingState[4] & workingState[5]) ^ (~workingState[4] & workingState[6])) +\r\n        workingState[7] +\r\n        MRound +\r\n        ROUND_CONSTANTS[round];\r\n      var t2 =\r\n        (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) +\r\n        ((workingState[0] & workingState[1]) ^ (workingState[2] & (workingState[0] ^ workingState[1])));\r\n      for (var i = 7; i > 0; i--) {\r\n        workingState[i] = workingState[i - 1];\r\n      }\r\n      workingState[0] = (t1 + t2) | 0;\r\n      workingState[4] = (workingState[4] + t1) | 0;\r\n    }\r\n\r\n    // Update state\r\n    for (round = 0; round < 8; round++) {\r\n      STATE[round] = (STATE[round] + workingState[round]) | 0;\r\n    }\r\n  }\r\n\r\n  // Finally the state needs to be converted to BigEndian for output\r\n  // And we want to return a Uint8Array, not a Uint32Array\r\n  return new uint8Array(\r\n    new uint32Array(\r\n      STATE.map(function (val) {\r\n        return convertEndian(val);\r\n      }),\r\n    ).buffer,\r\n  );\r\n}\r\n\r\nexport function hmac(key: Uint8Array, data: Uint8Array) {\r\n  if (key.length > 64) key = sha256(key);\r\n\r\n  if (key.length < 64) {\r\n    const tmp = new Uint8Array(64);\r\n    tmp.set(key, 0);\r\n    key = tmp;\r\n  }\r\n\r\n  // Generate inner and outer keys\r\n  var innerKey = new Uint8Array(64);\r\n  var outerKey = new Uint8Array(64);\r\n  for (var i = 0; i < 64; i++) {\r\n    innerKey[i] = 0x36 ^ key[i];\r\n    outerKey[i] = 0x5c ^ key[i];\r\n  }\r\n\r\n  // Append the innerKey\r\n  var msg = new Uint8Array(data.length + 64);\r\n  msg.set(innerKey, 0);\r\n  msg.set(data, 64);\r\n\r\n  // Has the previous message and append the outerKey\r\n  var result = new Uint8Array(64 + 32);\r\n  result.set(outerKey, 0);\r\n  result.set(sha256(msg), 64);\r\n\r\n  // Hash the previous message\r\n  return sha256(result);\r\n}\r\n", "import Platform from 'common/platform';\r\nimport IBufferUtils from 'common/types/IBufferUtils';\r\nimport { hmac as hmacSha256 } from './hmac-sha256';\r\n\r\n/* Most BufferUtils methods that return a binary object return an ArrayBuffer\r\n * The exception is toBuffer, which returns a Uint8Array */\r\n\r\nexport type Bufferlike = BufferSource;\r\nexport type Output = Bufferlike;\r\nexport type ToBufferOutput = Uint8Array;\r\n\r\nclass BufferUtils implements IBufferUtils<Bufferlike, Output, ToBufferOutput> {\r\n  base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n  hexCharSet = '0123456789abcdef';\r\n\r\n  // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js\r\n  private uint8ViewToBase64(bytes: Uint8Array): string {\r\n    let base64 = '';\r\n    const encodings = this.base64CharSet;\r\n\r\n    const byteLength = bytes.byteLength;\r\n    const byteRemainder = byteLength % 3;\r\n    const mainLength = byteLength - byteRemainder;\r\n\r\n    let a, b, c, d;\r\n    let chunk;\r\n\r\n    // Main loop deals with bytes in chunks of 3\r\n    for (let i = 0; i < mainLength; i = i + 3) {\r\n      // Combine the three bytes into a single integer\r\n      chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\r\n\r\n      // Use bitmasks to extract 6-bit segments from the triplet\r\n      a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\r\n      b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\r\n      c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\r\n      d = chunk & 63; // 63       = 2^6 - 1\r\n\r\n      // Convert the raw binary segments to the appropriate ASCII encoding\r\n      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\r\n    }\r\n\r\n    // Deal with the remaining bytes and padding\r\n    if (byteRemainder == 1) {\r\n      chunk = bytes[mainLength];\r\n\r\n      a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\r\n\r\n      // Set the 4 least significant bits to zero\r\n      b = (chunk & 3) << 4; // 3   = 2^2 - 1\r\n\r\n      base64 += encodings[a] + encodings[b] + '==';\r\n    } else if (byteRemainder == 2) {\r\n      chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\r\n\r\n      a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\r\n      b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\r\n\r\n      // Set the 2 least significant bits to zero\r\n      c = (chunk & 15) << 2; // 15    = 2^4 - 1\r\n\r\n      base64 += encodings[a] + encodings[b] + encodings[c] + '=';\r\n    }\r\n\r\n    return base64;\r\n  }\r\n\r\n  private base64ToArrayBuffer(base64: string): Output {\r\n    const binary_string = atob?.(base64) as string; // this will always be defined in browser so it's safe to cast\r\n    const len = binary_string.length;\r\n    const bytes = new Uint8Array(len);\r\n    for (let i = 0; i < len; i++) {\r\n      const ascii = binary_string.charCodeAt(i);\r\n      bytes[i] = ascii;\r\n    }\r\n    return this.toArrayBuffer(bytes);\r\n  }\r\n\r\n  isBuffer(buffer: unknown): buffer is Bufferlike {\r\n    return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\r\n  }\r\n\r\n  toBuffer(buffer: Bufferlike): ToBufferOutput {\r\n    if (!ArrayBuffer) {\r\n      throw new Error(\"Can't convert to Buffer: browser does not support the necessary types\");\r\n    }\r\n\r\n    if (buffer instanceof ArrayBuffer) {\r\n      return new Uint8Array(buffer);\r\n    }\r\n\r\n    if (ArrayBuffer.isView(buffer)) {\r\n      return new Uint8Array(this.toArrayBuffer(buffer));\r\n    }\r\n\r\n    throw new Error('BufferUtils.toBuffer expected an ArrayBuffer or a view onto one');\r\n  }\r\n\r\n  toArrayBuffer(buffer: Bufferlike): ArrayBuffer {\r\n    if (!ArrayBuffer) {\r\n      throw new Error(\"Can't convert to ArrayBuffer: browser does not support the necessary types\");\r\n    }\r\n\r\n    if (buffer instanceof ArrayBuffer) {\r\n      return buffer;\r\n    }\r\n\r\n    if (ArrayBuffer.isView(buffer)) {\r\n      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n    }\r\n\r\n    throw new Error('BufferUtils.toArrayBuffer expected an ArrayBuffer or a view onto one');\r\n  }\r\n\r\n  base64Encode(buffer: Bufferlike): string {\r\n    return this.uint8ViewToBase64(this.toBuffer(buffer));\r\n  }\r\n\r\n  base64Decode(str: string): Output {\r\n    if (ArrayBuffer && Platform.Config.atob) {\r\n      return this.base64ToArrayBuffer(str);\r\n    } else {\r\n      throw new Error('Expected ArrayBuffer to exist and Platform.Config.atob to be configured');\r\n    }\r\n  }\r\n\r\n  hexEncode(buffer: Bufferlike): string {\r\n    const uint8Array = this.toBuffer(buffer);\r\n    return uint8Array.reduce((accum, byte) => accum + byte.toString(16).padStart(2, '0'), '');\r\n  }\r\n\r\n  hexDecode(hexEncodedBytes: string): Output {\r\n    if (hexEncodedBytes.length % 2 !== 0) {\r\n      throw new Error(\"Can't create a byte array from a hex string of odd length\");\r\n    }\r\n\r\n    const uint8Array = new Uint8Array(hexEncodedBytes.length / 2);\r\n\r\n    for (let i = 0; i < uint8Array.length; i++) {\r\n      uint8Array[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);\r\n    }\r\n\r\n    return this.toArrayBuffer(uint8Array);\r\n  }\r\n\r\n  utf8Encode(string: string): Output {\r\n    if (Platform.Config.TextEncoder) {\r\n      const encodedByteArray = new Platform.Config.TextEncoder().encode(string);\r\n      return this.toArrayBuffer(encodedByteArray);\r\n    } else {\r\n      throw new Error('Expected TextEncoder to be configured');\r\n    }\r\n  }\r\n\r\n  /* For utf8 decoding we apply slightly stricter input validation than to\r\n   * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from\r\n   * can take (in particular allowing strings, which are just interpreted as\r\n   * binary); here we ensure that the input is actually a buffer since trying\r\n   * to utf8-decode a string to another string is almost certainly a mistake */\r\n  utf8Decode(buffer: Bufferlike): string {\r\n    if (!this.isBuffer(buffer)) {\r\n      throw new Error('Expected input of utf8decode to be an arraybuffer or typed array');\r\n    }\r\n    if (TextDecoder) {\r\n      return new TextDecoder().decode(buffer);\r\n    } else {\r\n      throw new Error('Expected TextDecoder to be configured');\r\n    }\r\n  }\r\n\r\n  areBuffersEqual(buffer1: Bufferlike, buffer2: Bufferlike): boolean {\r\n    if (!buffer1 || !buffer2) return false;\r\n    const arrayBuffer1 = this.toArrayBuffer(buffer1);\r\n    const arrayBuffer2 = this.toArrayBuffer(buffer2);\r\n\r\n    if (arrayBuffer1.byteLength != arrayBuffer2.byteLength) return false;\r\n\r\n    const bytes1 = new Uint8Array(arrayBuffer1);\r\n    const bytes2 = new Uint8Array(arrayBuffer2);\r\n\r\n    for (var i = 0; i < bytes1.length; i++) {\r\n      if (bytes1[i] != bytes2[i]) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  byteLength(buffer: Bufferlike): number {\r\n    if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {\r\n      return buffer.byteLength;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  arrayBufferViewToBuffer(arrayBufferView: ArrayBufferView): ArrayBuffer {\r\n    return this.toArrayBuffer(arrayBufferView);\r\n  }\r\n\r\n  hmacSha256(message: Bufferlike, key: Bufferlike): Output {\r\n    const hash = hmacSha256(this.toBuffer(key), this.toBuffer(message));\r\n    return this.toArrayBuffer(hash);\r\n  }\r\n}\r\n\r\nexport default new BufferUtils();\r\n", "import Logger from '../../../../common/lib/util/logger';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport * as API from '../../../../../ably';\r\nimport ICryptoStatic, { IGetCipherParams } from '../../../../common/types/ICryptoStatic';\r\nimport ICipher from '../../../../common/types/ICipher';\r\nimport { CryptoDataTypes } from '../../../../common/types/cryptoDataTypes';\r\nimport BufferUtils, { Bufferlike, Output as BufferUtilsOutput } from './bufferutils';\r\nimport { IPlatformConfig } from 'common/types/IPlatformConfig';\r\n\r\n// The type to which ./msgpack.ts deserializes elements of the `bin` or `ext` type\r\ntype MessagePackBinaryType = ArrayBuffer;\r\n\r\ntype IV = CryptoDataTypes.IV<BufferUtilsOutput>;\r\ntype InputPlaintext = CryptoDataTypes.InputPlaintext<Bufferlike, BufferUtilsOutput>;\r\ntype OutputCiphertext = ArrayBuffer;\r\ntype InputCiphertext = CryptoDataTypes.InputCiphertext<MessagePackBinaryType, BufferUtilsOutput>;\r\ntype OutputPlaintext = ArrayBuffer;\r\n\r\nvar createCryptoClass = function (config: IPlatformConfig, bufferUtils: typeof BufferUtils) {\r\n  var DEFAULT_ALGORITHM = 'aes';\r\n  var DEFAULT_KEYLENGTH = 256; // bits\r\n  var DEFAULT_MODE = 'cbc';\r\n  var DEFAULT_BLOCKLENGTH = 16; // bytes\r\n\r\n  /**\r\n   * Internal: checks that the cipherParams are a valid combination. Currently\r\n   * just checks that the calculated keyLength is a valid one for aes-cbc\r\n   */\r\n  function validateCipherParams(params: API.CipherParams) {\r\n    if (params.algorithm === 'aes' && params.mode === 'cbc') {\r\n      if (params.keyLength === 128 || params.keyLength === 256) {\r\n        return;\r\n      }\r\n      throw new Error(\r\n        'Unsupported key length ' +\r\n          params.keyLength +\r\n          ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)',\r\n      );\r\n    }\r\n  }\r\n\r\n  function normaliseBase64(string: string) {\r\n    /* url-safe base64 strings use _ and - instread of / and + */\r\n    return string.replace('_', '/').replace('-', '+');\r\n  }\r\n\r\n  function isCipherParams(params: API.CipherParams | API.CipherParamOptions): params is API.CipherParams {\r\n    // Although API.CipherParams is an interface, the documentation for its `key` property makes it clear that the only valid way to form one is by using getDefaultParams. The implementation of getDefaultParams returns an instance of CipherParams.\r\n    return params instanceof CipherParams;\r\n  }\r\n\r\n  /**\r\n   * A class encapsulating the client-specifiable parameters for\r\n   * the cipher.\r\n   *\r\n   * algorithm is the name of the algorithm in the default system provider,\r\n   * or the lower-cased version of it; eg \"aes\" or \"AES\".\r\n   *\r\n   * Clients are recommended to not call this directly, but instead to use the\r\n   * Crypto.getDefaultParams helper, which will fill in any fields not supplied\r\n   * with default values and validation the result.\r\n   */\r\n  class CipherParams implements API.CipherParams {\r\n    algorithm: string;\r\n    keyLength: number;\r\n    mode: string;\r\n    key: ArrayBuffer;\r\n\r\n    constructor(algorithm: string, keyLength: number, mode: string, key: ArrayBuffer) {\r\n      this.algorithm = algorithm;\r\n      this.keyLength = keyLength;\r\n      this.mode = mode;\r\n      this.key = key;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Utility classes and interfaces for message payload encryption.\r\n   *\r\n   * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits\r\n   * but supporting other keylengths. Other algorithms and chaining modes are\r\n   * not supported directly, but supportable by extending/implementing the base\r\n   * classes and interfaces here.\r\n   *\r\n   * Secure random data for creation of Initialization Vectors (IVs) and keys\r\n   * is obtained from window.crypto.getRandomValues.\r\n   *\r\n   * Each message payload is encrypted with an IV in CBC mode, and the IV is\r\n   * concatenated with the resulting raw ciphertext to construct the \"ciphertext\"\r\n   * data passed to the recipient.\r\n   */\r\n  class Crypto {\r\n    static CipherParams = CipherParams;\r\n\r\n    /**\r\n     * Obtain a complete CipherParams instance from the provided params, filling\r\n     * in any not provided with default values, calculating a keyLength from\r\n     * the supplied key, and validating the result.\r\n     * @param params an object containing at a minimum a `key` key with value the\r\n     * key, as either a binary or a base64-encoded string.\r\n     * May optionally also contain: algorithm (defaults to AES),\r\n     * mode (defaults to 'cbc')\r\n     */\r\n    static getDefaultParams(params: API.CipherParamOptions) {\r\n      var key: ArrayBuffer;\r\n\r\n      if (!params.key) {\r\n        throw new Error('Crypto.getDefaultParams: a key is required');\r\n      }\r\n\r\n      if (typeof params.key === 'string') {\r\n        key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));\r\n      } else if (params.key instanceof ArrayBuffer) {\r\n        key = params.key;\r\n      } else {\r\n        key = bufferUtils.toArrayBuffer(params.key);\r\n      }\r\n\r\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\r\n      var keyLength = key.byteLength * 8;\r\n      var mode = params.mode || DEFAULT_MODE;\r\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\r\n\r\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\r\n        throw new Error(\r\n          'Crypto.getDefaultParams: a keyLength of ' +\r\n            params.keyLength +\r\n            ' was specified, but the key actually has length ' +\r\n            cipherParams.keyLength,\r\n        );\r\n      }\r\n\r\n      validateCipherParams(cipherParams);\r\n      return cipherParams;\r\n    }\r\n\r\n    /**\r\n     * Generate a random encryption key from the supplied keylength (or the\r\n     * default keyLength if none supplied) as an ArrayBuffer\r\n     * @param keyLength (optional) the required keyLength in bits\r\n     */\r\n    static async generateRandomKey(keyLength?: number): Promise<API.CipherKey> {\r\n      try {\r\n        return config.getRandomArrayBuffer((keyLength || DEFAULT_KEYLENGTH) / 8);\r\n      } catch (err) {\r\n        throw new ErrorInfo('Failed to generate random key: ' + (err as Error).message, 400, 50000, err as Error);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Internal; get a ChannelCipher instance based on the given cipherParams\r\n     * @param params either a CipherParams instance or some subset of its\r\n     * fields that includes a key\r\n     */\r\n    static getCipher(params: IGetCipherParams<IV>, logger: Logger) {\r\n      var cipherParams = isCipherParams(params) ? (params as CipherParams) : this.getDefaultParams(params);\r\n\r\n      return {\r\n        cipherParams: cipherParams,\r\n        cipher: new CBCCipher(cipherParams, params.iv ?? null, logger),\r\n      };\r\n    }\r\n  }\r\n\r\n  Crypto satisfies ICryptoStatic<IV, InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext>;\r\n\r\n  class CBCCipher implements ICipher<InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext> {\r\n    algorithm: string;\r\n    webCryptoAlgorithm: string;\r\n    key: ArrayBuffer;\r\n    iv: ArrayBuffer | null;\r\n\r\n    constructor(params: CipherParams, iv: IV | null, private readonly logger: Logger) {\r\n      if (!crypto.subtle) {\r\n        if (isSecureContext) {\r\n          throw new Error(\r\n            'Crypto operations are not possible since the browser\u2019s SubtleCrypto class is unavailable (reason unknown).',\r\n          );\r\n        } else {\r\n          throw new Error(\r\n            'Crypto operations are is not possible since the current environment is a non-secure context and hence the browser\u2019s SubtleCrypto class is not available.',\r\n          );\r\n        }\r\n      }\r\n\r\n      this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;\r\n      this.webCryptoAlgorithm = params.algorithm + '-' + params.mode;\r\n      this.key = bufferUtils.toArrayBuffer(params.key);\r\n      this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;\r\n    }\r\n\r\n    private concat(buffer1: Bufferlike, buffer2: Bufferlike) {\r\n      const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);\r\n      const outputView = new DataView(output);\r\n\r\n      const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));\r\n      for (let i = 0; i < buffer1View.byteLength; i++) {\r\n        outputView.setInt8(i, buffer1View.getInt8(i));\r\n      }\r\n\r\n      const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));\r\n      for (let i = 0; i < buffer2View.byteLength; i++) {\r\n        outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));\r\n      }\r\n\r\n      return output;\r\n    }\r\n\r\n    async encrypt(plaintext: InputPlaintext): Promise<OutputCiphertext> {\r\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'CBCCipher.encrypt()', '');\r\n\r\n      const iv = await this.getIv();\r\n      const cryptoKey = await crypto.subtle.importKey('raw', this.key, this.webCryptoAlgorithm, false, ['encrypt']);\r\n      const ciphertext = await crypto.subtle.encrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, plaintext);\r\n\r\n      return this.concat(iv, ciphertext);\r\n    }\r\n\r\n    async decrypt(ciphertext: InputCiphertext): Promise<OutputPlaintext> {\r\n      Logger.logAction(this.logger, Logger.LOG_MICRO, 'CBCCipher.decrypt()', '');\r\n\r\n      const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);\r\n      const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);\r\n      const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);\r\n\r\n      const cryptoKey = await crypto.subtle.importKey('raw', this.key, this.webCryptoAlgorithm, false, ['decrypt']);\r\n      return crypto.subtle.decrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, ciphertextBody);\r\n    }\r\n\r\n    async getIv(): Promise<ArrayBuffer> {\r\n      if (this.iv) {\r\n        var iv = this.iv;\r\n        this.iv = null;\r\n        return iv;\r\n      }\r\n\r\n      const randomBlock = await config.getRandomArrayBuffer(DEFAULT_BLOCKLENGTH);\r\n      return bufferUtils.toArrayBuffer(randomBlock);\r\n    }\r\n  }\r\n\r\n  return Crypto;\r\n};\r\n\r\nexport { createCryptoClass };\r\n", "enum XHRStates {\r\n  REQ_SEND = 0,\r\n  REQ_RECV = 1,\r\n  REQ_RECV_POLL = 2,\r\n  REQ_RECV_STREAM = 3,\r\n}\r\n\r\nexport default XHRStates;\r\n", "import Platform from 'common/platform';\r\nimport Defaults from 'common/lib/util/defaults';\r\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport { RequestBody, RequestResultError, RequestParams, RequestResult } from 'common/types/http';\r\nimport HttpMethods from 'common/constants/HttpMethods';\r\nimport BaseClient from 'common/lib/client/baseclient';\r\nimport XHRStates from 'common/constants/XHRStates';\r\nimport Logger from 'common/lib/util/logger';\r\nimport { StandardCallback } from 'common/types/utils';\r\nimport { isSuccessCode } from 'common/constants/HttpStatusCodes';\r\nimport { ModularPlugins } from 'common/lib/client/modularplugins';\r\n\r\nexport type HTTPRequestImplementations = Pick<ModularPlugins, 'XHRRequest' | 'FetchRequest'>;\r\n\r\nfunction createMissingImplementationError() {\r\n  return new ErrorInfo(\r\n    'No HTTP request plugin provided. Provide at least one of the FetchRequest or XHRRequest plugins.',\r\n    400,\r\n    40000,\r\n  );\r\n}\r\n\r\nconst Http = class {\r\n  static methods = [HttpMethods.Get, HttpMethods.Delete, HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\r\n  static methodsWithoutBody = [HttpMethods.Get, HttpMethods.Delete];\r\n  static methodsWithBody = [HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\r\n  // HTTP request implementations that are available even without a BaseClient object (needed by some tests which directly instantiate `Http` without a client)\r\n  static bundledRequestImplementations: HTTPRequestImplementations;\r\n  checksInProgress: Array<StandardCallback<boolean>> | null = null;\r\n  private client: BaseClient | null;\r\n\r\n  constructor(client?: BaseClient) {\r\n    this.client = client ?? null;\r\n    const connectivityCheckUrl = client?.options.connectivityCheckUrl || Defaults.connectivityCheckUrl;\r\n    const connectivityCheckParams = client?.options.connectivityCheckParams ?? null;\r\n    const connectivityUrlIsDefault = !client?.options.connectivityCheckUrl;\r\n\r\n    const requestImplementations = {\r\n      ...Http.bundledRequestImplementations,\r\n      ...client?._additionalHTTPRequestImplementations,\r\n    };\r\n    const xhrRequestImplementation = requestImplementations.XHRRequest;\r\n    const fetchRequestImplementation = requestImplementations.FetchRequest;\r\n    const hasImplementation = !!(xhrRequestImplementation || fetchRequestImplementation);\r\n\r\n    if (!hasImplementation) {\r\n      throw createMissingImplementationError();\r\n    }\r\n\r\n    if (Platform.Config.xhrSupported && xhrRequestImplementation) {\r\n      this.supportsAuthHeaders = true;\r\n      this.Request = async function (\r\n        method: HttpMethods,\r\n        uri: string,\r\n        headers: Record<string, string> | null,\r\n        params: RequestParams,\r\n        body: RequestBody | null,\r\n      ) {\r\n        return new Promise((resolve) => {\r\n          const req = xhrRequestImplementation.createRequest(\r\n            uri,\r\n            headers,\r\n            params,\r\n            body,\r\n            XHRStates.REQ_SEND,\r\n            (client && client.options.timeouts) ?? null,\r\n            this.logger,\r\n            method,\r\n          );\r\n          req.once(\r\n            'complete',\r\n            (\r\n              error: RequestResult['error'],\r\n              body: RequestResult['body'],\r\n              headers: RequestResult['headers'],\r\n              unpacked: RequestResult['unpacked'],\r\n              statusCode: RequestResult['statusCode'],\r\n            ) => resolve({ error, body, headers, unpacked, statusCode }),\r\n          );\r\n          req.exec();\r\n        });\r\n      };\r\n      if (client?.options.disableConnectivityCheck) {\r\n        this.checkConnectivity = async function () {\r\n          return true;\r\n        };\r\n      } else {\r\n        this.checkConnectivity = async function () {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_MICRO,\r\n            '(XHRRequest)Http.checkConnectivity()',\r\n            'Sending; ' + connectivityCheckUrl,\r\n          );\r\n\r\n          const requestResult = await this.doUri(\r\n            HttpMethods.Get,\r\n            connectivityCheckUrl,\r\n            null,\r\n            null,\r\n            connectivityCheckParams,\r\n          );\r\n\r\n          let result = false;\r\n          if (!connectivityUrlIsDefault) {\r\n            result = !requestResult.error && isSuccessCode(requestResult.statusCode as number);\r\n          } else {\r\n            result = !requestResult.error && (requestResult.body as string)?.replace(/\\n/, '') == 'yes';\r\n          }\r\n\r\n          Logger.logAction(this.logger, Logger.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);\r\n          return result;\r\n        };\r\n      }\r\n    } else if (Platform.Config.fetchSupported && fetchRequestImplementation) {\r\n      this.supportsAuthHeaders = true;\r\n      this.Request = async (method, uri, headers, params, body) => {\r\n        return fetchRequestImplementation(method, client ?? null, uri, headers, params, body);\r\n      };\r\n      this.checkConnectivity = async function () {\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_MICRO,\r\n          '(Fetch)Http.checkConnectivity()',\r\n          'Sending; ' + connectivityCheckUrl,\r\n        );\r\n        const requestResult = await this.doUri(HttpMethods.Get, connectivityCheckUrl, null, null, null);\r\n        const result = !requestResult.error && (requestResult.body as string)?.replace(/\\n/, '') == 'yes';\r\n        Logger.logAction(this.logger, Logger.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Result: ' + result);\r\n        return result;\r\n      };\r\n    } else {\r\n      this.Request = async () => {\r\n        const error = hasImplementation\r\n          ? new PartialErrorInfo('no supported HTTP transports available', null, 400)\r\n          : createMissingImplementationError();\r\n        return { error };\r\n      };\r\n    }\r\n  }\r\n\r\n  get logger(): Logger {\r\n    return this.client?.logger ?? Logger.defaultLogger;\r\n  }\r\n\r\n  async doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    if (!this.Request) {\r\n      return { error: new PartialErrorInfo('Request invoked before assigned to', null, 500) };\r\n    }\r\n    return this.Request(method, uri, headers, params, body);\r\n  }\r\n\r\n  private Request?: (\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n  ) => Promise<RequestResult>;\r\n\r\n  checkConnectivity?: () => Promise<boolean> = undefined;\r\n\r\n  supportsAuthHeaders = false;\r\n  supportsLinkHeaders = false;\r\n\r\n  shouldFallback(errorInfo: RequestResultError) {\r\n    const statusCode = errorInfo.statusCode as number;\r\n    /* 400 + no code = a generic xhr onerror. Browser doesn't give us enough\r\n     * detail to know whether it's fallback-fixable, but it may be (eg if a\r\n     * network issue), so try just in case */\r\n    return (\r\n      (statusCode === 408 && !errorInfo.code) ||\r\n      (statusCode === 400 && !errorInfo.code) ||\r\n      (statusCode >= 500 && statusCode <= 504)\r\n    );\r\n  }\r\n};\r\n\r\nexport default Http;\r\n", "import { IPlatformConfig } from '../../common/types/IPlatformConfig';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\n// Workaround for salesforce lightning locker compat\r\nconst globalObject = Utils.getGlobalObject();\r\n\r\n// @ts-ignore\r\nconst isVercelEdgeRuntime = typeof EdgeRuntime === 'string';\r\n\r\n// We get false positive result here in the Vercel Edge runtime because it lacks the usual global browser objects, such as Window.\r\n// However, it is closer to the browser environment, so it intentionally uses browser bundles when importing packages.\r\n// Therefore, we do an additional check to avoid logging this incorrect warning for Vercel Edge runtime.\r\nif (typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined' && !isVercelEdgeRuntime) {\r\n  console.log(\r\n    \"Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm\",\r\n  );\r\n}\r\n\r\nfunction allowComet() {\r\n  /* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg\r\n   * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask\r\n   * So if websockets are supported, then just forget about comet transports and use that */\r\n  const loc = globalObject.location;\r\n  return !globalObject.WebSocket || !loc || !loc.origin || loc.origin.indexOf('http') > -1;\r\n}\r\n\r\n// from: https://stackoverflow.com/a/18002694\r\nexport function isWebWorkerContext(): boolean {\r\n  // run this in global scope of window or worker. since window.self = window, we're ok\r\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nconst userAgent = globalObject.navigator && globalObject.navigator.userAgent.toString();\r\nconst currentUrl = globalObject.location && globalObject.location.href;\r\n\r\nconst Config: IPlatformConfig = {\r\n  agent: 'browser',\r\n  logTimestamps: true,\r\n  userAgent: userAgent,\r\n  currentUrl: currentUrl,\r\n  binaryType: 'arraybuffer',\r\n  WebSocket: globalObject.WebSocket,\r\n  fetchSupported: !!globalObject.fetch,\r\n  xhrSupported: globalObject.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),\r\n  allowComet: allowComet(),\r\n  useProtocolHeartbeats: true,\r\n  supportsBinary: !!globalObject.TextDecoder,\r\n  /* Per Paddy (https://ably-real-time.slack.com/archives/CURL4U2FP/p1705674537763479) web intentionally prefers JSON to MessagePack:\r\n   *\r\n   * > browsers' support for binary types in general was historically poor, and JSON transport performance is significantly better in a browser than msgpack. In modern browsers then binary is supported consistently, but I'd still expect that JSON encode/decode performance is dramatically better than msgpack in a browser.\r\n   */\r\n  preferBinary: false,\r\n  ArrayBuffer: globalObject.ArrayBuffer,\r\n  atob: globalObject.atob,\r\n  nextTick:\r\n    typeof globalObject.setImmediate !== 'undefined'\r\n      ? globalObject.setImmediate.bind(globalObject)\r\n      : function (f: () => void) {\r\n          setTimeout(f, 0);\r\n        },\r\n  addEventListener: globalObject.addEventListener,\r\n  inspect: JSON.stringify,\r\n  stringByteSize: function (str: string) {\r\n    /* str.length will be an underestimate for non-ascii strings. But if we're\r\n     * in a browser too old to support TextDecoder, not much we can do. Better\r\n     * to underestimate, so if we do go over-size, the server will reject the\r\n     * message */\r\n    return (globalObject.TextDecoder && new globalObject.TextEncoder().encode(str).length) || str.length;\r\n  },\r\n  TextEncoder: globalObject.TextEncoder,\r\n  TextDecoder: globalObject.TextDecoder,\r\n  getRandomArrayBuffer: async function (byteLength: number): Promise<ArrayBuffer> {\r\n    const byteArray = new Uint8Array(byteLength);\r\n    globalObject.crypto.getRandomValues(byteArray);\r\n    return byteArray.buffer;\r\n  },\r\n  isWebworker: isWebWorkerContext(),\r\n};\r\n\r\nexport default Config;\r\n", "import * as Utils from '../util/utils';\r\nimport ProtocolMessage, {\r\n  actions,\r\n  fromValues as protocolMessageFromValues,\r\n  fromDeserialized as protocolMessageFromDeserialized,\r\n} from '../types/protocolmessage';\r\nimport Transport from './transport';\r\nimport Logger from '../util/logger';\r\nimport Defaults from '../util/defaults';\r\nimport ConnectionErrors from './connectionerrors';\r\nimport Auth from '../client/auth';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport IXHRRequest from '../../types/IXHRRequest';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport XHRStates from '../../constants/XHRStates';\r\nimport Platform from 'common/platform';\r\n\r\n/* TODO: can remove once realtime sends protocol message responses for comet errors */\r\nfunction shouldBeErrorAction(err: ErrorInfo) {\r\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\r\n  if (err.code) {\r\n    if (Auth.isTokenErr(err)) return false;\r\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code)) return true;\r\n    return err.code >= 40000 && err.code < 50000;\r\n  } else {\r\n    /* Likely a network or transport error of some kind. Certainly not fatal to the connection */\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction protocolMessageFromRawError(err: ErrorInfo) {\r\n  /* err will be either a legacy (non-protocolmessage) comet error response\r\n   * (which will have an err.code), or a xhr/network error (which won't). */\r\n  if (shouldBeErrorAction(err)) {\r\n    return [protocolMessageFromValues({ action: actions.ERROR, error: err })];\r\n  } else {\r\n    return [protocolMessageFromValues({ action: actions.DISCONNECTED, error: err })];\r\n  }\r\n}\r\n\r\n/*\r\n * A base comet transport class\r\n */\r\nabstract class CometTransport extends Transport {\r\n  stream: string | boolean;\r\n  sendRequest: IXHRRequest | null;\r\n  recvRequest: null | IXHRRequest;\r\n  pendingCallback: null;\r\n  pendingItems: null | Array<ProtocolMessage>;\r\n  baseUri?: string;\r\n  authParams?: Record<string, any>;\r\n  closeUri?: string;\r\n  disconnectUri?: string;\r\n  sendUri?: string;\r\n  recvUri?: string;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params, /* binary not supported for comet so force JSON protocol */ true);\r\n    this.stream = 'stream' in params ? params.stream : true;\r\n    this.sendRequest = null;\r\n    this.recvRequest = null;\r\n    this.pendingCallback = null;\r\n    this.pendingItems = null;\r\n  }\r\n\r\n  abstract createRequest(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params?: Record<string, unknown> | null,\r\n    body?: unknown,\r\n    requestMode?: number,\r\n  ): IXHRRequest;\r\n\r\n  connect(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.connect()', 'starting');\r\n    Transport.prototype.connect.call(this);\r\n    const params = this.params;\r\n    const options = params.options;\r\n    const host = Defaults.getHost(options, params.host);\r\n    const port = Defaults.getPort(options);\r\n    const cometScheme = options.tls ? 'https://' : 'http://';\r\n\r\n    this.baseUri = cometScheme + host + ':' + port + '/comet/';\r\n    const connectUri = this.baseUri + 'connect';\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);\r\n    Utils.whenPromiseSettles(this.auth.getAuthParams(), (err: Error | null, authParams?: Record<string, any>) => {\r\n      if (err) {\r\n        this.disconnect(err);\r\n        return;\r\n      }\r\n      if (this.isDisposed) {\r\n        return;\r\n      }\r\n      this.authParams = authParams;\r\n      const connectParams = this.params.getConnectParams(authParams!);\r\n      if ('stream' in connectParams) this.stream = connectParams.stream;\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_MINOR,\r\n        'CometTransport.connect()',\r\n        'connectParams:' + Utils.toQueryString(connectParams),\r\n      );\r\n\r\n      /* this will be the 'recvRequest' so this connection can stream messages */\r\n      let preconnected = false;\r\n      const connectRequest = (this.recvRequest = this.createRequest(\r\n        connectUri,\r\n        null,\r\n        connectParams,\r\n        null,\r\n        this.stream ? XHRStates.REQ_RECV_STREAM : XHRStates.REQ_RECV,\r\n      ));\r\n\r\n      connectRequest.on('data', (data: any) => {\r\n        if (!this.recvRequest) {\r\n          /* the transport was disposed before we connected */\r\n          return;\r\n        }\r\n        if (!preconnected) {\r\n          preconnected = true;\r\n          this.emit('preconnect');\r\n        }\r\n        this.onData(data);\r\n      });\r\n      connectRequest.on('complete', (err: ErrorInfo) => {\r\n        if (!this.recvRequest) {\r\n          /* the transport was disposed before we connected */\r\n          err = err || new ErrorInfo('Request cancelled', 80003, 400);\r\n        }\r\n        this.recvRequest = null;\r\n        /* Connect request may complete without a emitting 'data' event since that is not\r\n         * emitted for e.g. a non-streamed error response. Still implies preconnect. */\r\n        if (!preconnected && !err) {\r\n          preconnected = true;\r\n          this.emit('preconnect');\r\n        }\r\n        this.onActivity();\r\n        if (err) {\r\n          if (err.code) {\r\n            /* A protocol error received from realtime. TODO: once realtime\r\n             * consistendly sends errors wrapped in protocol messages, should be\r\n             * able to remove this */\r\n            this.onData(protocolMessageFromRawError(err));\r\n          } else {\r\n            /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n             * just disconnect the transport */\r\n            this.disconnect(err);\r\n          }\r\n          return;\r\n        }\r\n        Platform.Config.nextTick(() => {\r\n          this.recv();\r\n        });\r\n      });\r\n      connectRequest.exec();\r\n    });\r\n  }\r\n\r\n  requestClose(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.requestClose()');\r\n    this._requestCloseOrDisconnect(true);\r\n  }\r\n\r\n  requestDisconnect(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.requestDisconnect()');\r\n    this._requestCloseOrDisconnect(false);\r\n  }\r\n\r\n  _requestCloseOrDisconnect(closing: boolean): void {\r\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\r\n    if (closeOrDisconnectUri) {\r\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates.REQ_SEND);\r\n\r\n      request.on('complete', (err: ErrorInfo) => {\r\n        if (err) {\r\n          Logger.logAction(\r\n            this.logger,\r\n            Logger.LOG_ERROR,\r\n            'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'),\r\n            'request returned err = ' + Utils.inspectError(err),\r\n          );\r\n          this.finish('disconnected', err);\r\n        }\r\n      });\r\n      request.exec();\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.dispose()', '');\r\n    if (!this.isDisposed) {\r\n      this.isDisposed = true;\r\n      if (this.recvRequest) {\r\n        Logger.logAction(this.logger, Logger.LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');\r\n        this.recvRequest.abort();\r\n        this.recvRequest = null;\r\n      }\r\n      /* In almost all cases the transport will be finished before it's\r\n       * disposed. Finish here just to make sure. */\r\n      this.finish('disconnected', ConnectionErrors.disconnected());\r\n      Platform.Config.nextTick(() => {\r\n        this.emit('disposed');\r\n      });\r\n    }\r\n  }\r\n\r\n  onConnect(message: ProtocolMessage): void {\r\n    /* if this transport has been disposed whilst awaiting connection, do nothing */\r\n    if (this.isDisposed) {\r\n      return;\r\n    }\r\n\r\n    /* the connectionKey in a comet connected response is really\r\n     * <instId>-<connectionKey> */\r\n    const connectionStr = message.connectionDetails?.connectionKey;\r\n    Transport.prototype.onConnect.call(this, message);\r\n\r\n    const baseConnectionUri = (this.baseUri as string) + connectionStr;\r\n    Logger.logAction(this.logger, Logger.LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri);\r\n    this.sendUri = baseConnectionUri + '/send';\r\n    this.recvUri = baseConnectionUri + '/recv';\r\n    this.closeUri = baseConnectionUri + '/close';\r\n    this.disconnectUri = baseConnectionUri + '/disconnect';\r\n  }\r\n\r\n  send(message: ProtocolMessage): void {\r\n    if (this.sendRequest) {\r\n      /* there is a pending send, so queue this message */\r\n      this.pendingItems = this.pendingItems || [];\r\n      this.pendingItems.push(message);\r\n      return;\r\n    }\r\n    /* send this, plus any pending, now */\r\n    const pendingItems = this.pendingItems || [];\r\n    pendingItems.push(message);\r\n    this.pendingItems = null;\r\n\r\n    this.sendItems(pendingItems);\r\n  }\r\n\r\n  sendAnyPending(): void {\r\n    const pendingItems = this.pendingItems;\r\n\r\n    if (!pendingItems) {\r\n      return;\r\n    }\r\n\r\n    this.pendingItems = null;\r\n    this.sendItems(pendingItems);\r\n  }\r\n\r\n  sendItems(items: Array<ProtocolMessage>): void {\r\n    const sendRequest = (this.sendRequest = this.createRequest(\r\n      this.sendUri as string,\r\n      null,\r\n      this.authParams,\r\n      this.encodeRequest(items),\r\n      XHRStates.REQ_SEND,\r\n    ));\r\n\r\n    sendRequest.on('complete', (err: ErrorInfo, data: string) => {\r\n      if (err)\r\n        Logger.logAction(\r\n          this.logger,\r\n          Logger.LOG_ERROR,\r\n          'CometTransport.sendItems()',\r\n          'on complete: err = ' + Utils.inspectError(err),\r\n        );\r\n      this.sendRequest = null;\r\n\r\n      /* the result of the request, even if a nack, is usually a protocol response\r\n       * contained in the data. An err is anomolous, and indicates some issue with the\r\n       * network,transport, or connection */\r\n      if (err) {\r\n        if (err.code) {\r\n          /* A protocol error received from realtime. TODO: once realtime\r\n           * consistendly sends errors wrapped in protocol messages, should be\r\n           * able to remove this */\r\n          this.onData(protocolMessageFromRawError(err));\r\n        } else {\r\n          /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n           * just disconnect the transport */\r\n          this.disconnect(err);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (data) {\r\n        this.onData(data);\r\n      }\r\n\r\n      if (this.pendingItems) {\r\n        Platform.Config.nextTick(() => {\r\n          /* If there's a new send request by now, any pending items will have\r\n           * been picked up by that; any new ones added since then will be\r\n           * picked up after that one completes */\r\n          if (!this.sendRequest) {\r\n            this.sendAnyPending();\r\n          }\r\n        });\r\n      }\r\n    });\r\n    sendRequest.exec();\r\n  }\r\n\r\n  recv(): void {\r\n    /* do nothing if there is an active request, which might be streaming */\r\n    if (this.recvRequest) return;\r\n\r\n    /* If we're no longer connected, do nothing */\r\n    if (!this.isConnected) return;\r\n\r\n    const recvRequest = (this.recvRequest = this.createRequest(\r\n      this.recvUri as string,\r\n      null,\r\n      this.authParams,\r\n      null,\r\n      this.stream ? XHRStates.REQ_RECV_STREAM : XHRStates.REQ_RECV_POLL,\r\n    ));\r\n\r\n    recvRequest.on('data', (data: string) => {\r\n      this.onData(data);\r\n    });\r\n    recvRequest.on('complete', (err: ErrorInfo) => {\r\n      this.recvRequest = null;\r\n      /* A request completing must be considered activity, as realtime sends\r\n       * heartbeats every 15s since a request began, not every 15s absolutely */\r\n      this.onActivity();\r\n      if (err) {\r\n        if (err.code) {\r\n          /* A protocol error received from realtime. TODO: once realtime\r\n           * consistently sends errors wrapped in protocol messages, should be\r\n           * able to remove this */\r\n          this.onData(protocolMessageFromRawError(err));\r\n        } else {\r\n          /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n           * just disconnect the transport */\r\n          this.disconnect(err);\r\n        }\r\n        return;\r\n      }\r\n      Platform.Config.nextTick(() => {\r\n        this.recv();\r\n      });\r\n    });\r\n    recvRequest.exec();\r\n  }\r\n\r\n  onData(responseData: string | Record<string, any>): void {\r\n    try {\r\n      const items = this.decodeResponse(responseData);\r\n      if (items && items.length)\r\n        for (let i = 0; i < items.length; i++)\r\n          this.onProtocolMessage(\r\n            protocolMessageFromDeserialized(items[i], this.connectionManager.realtime._RealtimePresence),\r\n          );\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        this.logger,\r\n        Logger.LOG_ERROR,\r\n        'CometTransport.onData()',\r\n        'Unexpected exception handing channel event: ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  encodeRequest(requestItems: Array<ProtocolMessage>): string {\r\n    return JSON.stringify(requestItems);\r\n  }\r\n\r\n  decodeResponse(responseData: string | Record<string, any>): Record<string, any> {\r\n    if (typeof responseData == 'string') return JSON.parse(responseData);\r\n    return responseData;\r\n  }\r\n\r\n  /* Historical comment, back from when we supported JSONP:\r\n   *\r\n   * > For comet, we could do the auth update by aborting the current recv and\r\n   * > starting a new one with the new token, that'd be sufficient for realtime.\r\n   * > Problem is JSONP - you can't cancel truly abort a recv once started. So\r\n   * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\r\n   * > comet transports the same and do it for all of them. So we send the AUTH\r\n   * > instead, and don't need to abort the recv\r\n   *\r\n   * Now that we\u2019ve dropped JSONP support, we may be able to revisit the above;\r\n   * see https://github.com/ably/ably-js/issues/1214.\r\n   */\r\n  onAuthUpdated = (tokenDetails: API.TokenDetails): void => {\r\n    this.authParams = { access_token: tokenDetails.token };\r\n  };\r\n}\r\n\r\nexport default CometTransport;\r\n", "import * as Utils from 'common/lib/util/utils';\r\nimport EventEmitter from 'common/lib/util/eventemitter';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport Logger from 'common/lib/util/logger';\r\nimport Defaults from 'common/lib/util/defaults';\r\nimport HttpMethods from 'common/constants/HttpMethods';\r\nimport IXHRRequest from 'common/types/IXHRRequest';\r\nimport { RequestBody, RequestParams } from 'common/types/http';\r\nimport XHRStates from 'common/constants/XHRStates';\r\nimport Platform from 'common/platform';\r\n\r\nfunction isAblyError(responseBody: unknown, headers: Record<string, string>): responseBody is { error?: ErrorInfo } {\r\n  return Utils.allToLowerCase(Utils.keysArray(headers)).includes('x-ably-errorcode');\r\n}\r\n\r\nfunction getAblyError(responseBody: unknown, headers: Record<string, string>) {\r\n  if (isAblyError(responseBody, headers)) {\r\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\r\n  }\r\n}\r\n\r\nconst noop = function () {};\r\nlet idCounter = 0;\r\nconst pendingRequests: Record<string, XHRRequest> = {};\r\n\r\nfunction getHeader(xhr: XMLHttpRequest, header: string) {\r\n  return xhr.getResponseHeader && xhr.getResponseHeader(header);\r\n}\r\n\r\n/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact\r\n * it is 'chunked'. So instead, decide that it is chunked when\r\n * transfer-encoding is present or content-length is absent.  ('or' because\r\n * when using http2 streaming, there's no transfer-encoding header, but can\r\n * still deduce streaming from lack of content-length) */\r\nfunction isEncodingChunked(xhr: XMLHttpRequest) {\r\n  return (\r\n    xhr.getResponseHeader && (xhr.getResponseHeader('transfer-encoding') || !xhr.getResponseHeader('content-length'))\r\n  );\r\n}\r\n\r\nfunction getHeadersAsObject(xhr: XMLHttpRequest) {\r\n  const headerPairs = xhr.getAllResponseHeaders().trim().split('\\r\\n');\r\n  const headers: Record<string, string> = {};\r\n  for (let i = 0; i < headerPairs.length; i++) {\r\n    const parts = headerPairs[i].split(':').map((x) => x.trim());\r\n    headers[parts[0].toLowerCase()] = parts[1];\r\n  }\r\n  return headers;\r\n}\r\n\r\nclass XHRRequest extends EventEmitter implements IXHRRequest {\r\n  uri: string;\r\n  headers: Record<string, string>;\r\n  body: RequestBody | null;\r\n  method: string;\r\n  requestMode: number;\r\n  timeouts: Record<string, number>;\r\n  timedOut: boolean;\r\n  requestComplete: boolean;\r\n  id: string;\r\n  streamComplete?: boolean;\r\n  xhr?: XMLHttpRequest | null;\r\n  timer?: NodeJS.Timeout | number | null;\r\n\r\n  constructor(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: Record<string, string>,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n    timeouts: Record<string, number>,\r\n    logger: Logger,\r\n    method?: HttpMethods,\r\n  ) {\r\n    super(logger);\r\n    params = params || {};\r\n    params.rnd = Utils.cheapRandStr();\r\n    this.uri = uri + Utils.toQueryString(params);\r\n    this.headers = headers || {};\r\n    this.body = body;\r\n    this.method = method ? method.toUpperCase() : Utils.isNil(body) ? 'GET' : 'POST';\r\n    this.requestMode = requestMode;\r\n    this.timeouts = timeouts;\r\n    this.timedOut = false;\r\n    this.requestComplete = false;\r\n    this.id = String(++idCounter);\r\n    pendingRequests[this.id] = this;\r\n  }\r\n\r\n  static createRequest(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n    timeouts: Record<string, number> | null,\r\n    logger: Logger,\r\n    method?: HttpMethods,\r\n  ): XHRRequest {\r\n    /* XHR requests are used either with the context being a realtime\r\n     * transport, or with timeouts passed in (for when used by a rest client),\r\n     * or completely standalone.  Use the appropriate timeouts in each case */\r\n    const _timeouts = timeouts || Defaults.TIMEOUTS;\r\n    return new XHRRequest(\r\n      uri,\r\n      headers,\r\n      Utils.copy(params) as Record<string, string>,\r\n      body,\r\n      requestMode,\r\n      _timeouts,\r\n      logger,\r\n      method,\r\n    );\r\n  }\r\n\r\n  complete(\r\n    err?: IPartialErrorInfo | null,\r\n    body?: unknown,\r\n    headers?: Record<string, string> | null,\r\n    unpacked?: boolean | null,\r\n    statusCode?: number,\r\n  ): void {\r\n    if (!this.requestComplete) {\r\n      this.requestComplete = true;\r\n      if (!err && body) {\r\n        this.emit('data', body);\r\n      }\r\n      this.emit('complete', err, body, headers, unpacked, statusCode);\r\n      this.dispose();\r\n    }\r\n  }\r\n\r\n  abort(): void {\r\n    this.dispose();\r\n  }\r\n\r\n  exec(): void {\r\n    let headers = this.headers;\r\n    const timeout =\r\n        this.requestMode == XHRStates.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,\r\n      timer = (this.timer = setTimeout(() => {\r\n        this.timedOut = true;\r\n        xhr.abort();\r\n      }, timeout)),\r\n      method = this.method,\r\n      xhr = (this.xhr = new XMLHttpRequest()),\r\n      accept = headers['accept'];\r\n    let body = this.body;\r\n    let responseType: XMLHttpRequestResponseType = 'text';\r\n\r\n    if (!accept) {\r\n      // Default to JSON\r\n      headers['accept'] = 'application/json';\r\n    } else if (accept.indexOf('application/x-msgpack') === 0) {\r\n      // Msgpack responses will be typed as ArrayBuffer\r\n      responseType = 'arraybuffer';\r\n    }\r\n\r\n    if (body) {\r\n      const contentType = headers['content-type'] || (headers['content-type'] = 'application/json');\r\n      if (contentType.indexOf('application/json') > -1 && typeof body != 'string') body = JSON.stringify(body);\r\n    }\r\n\r\n    // Can probably remove this directive if https://github.com/nodesecurity/eslint-plugin-security/issues/26 is resolved\r\n    // eslint-disable-next-line security/detect-non-literal-fs-filename\r\n    xhr.open(method, this.uri, true);\r\n    xhr.responseType = responseType;\r\n\r\n    if ('authorization' in headers) {\r\n      xhr.withCredentials = true;\r\n    }\r\n\r\n    for (const h in headers) xhr.setRequestHeader(h, headers[h]);\r\n\r\n    const errorHandler = (\r\n      errorEvent: ProgressEvent<EventTarget>,\r\n      message: string,\r\n      code: number | null,\r\n      statusCode: number,\r\n    ) => {\r\n      let errorMessage = message + ' (event type: ' + errorEvent.type + ')';\r\n      if (this?.xhr?.statusText) errorMessage += ', current statusText is ' + this.xhr.statusText;\r\n      Logger.logAction(this.logger, Logger.LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);\r\n      this.complete(new PartialErrorInfo(errorMessage, code, statusCode));\r\n    };\r\n    xhr.onerror = function (errorEvent) {\r\n      errorHandler(errorEvent, 'XHR error occurred', null, 400);\r\n    };\r\n    xhr.onabort = (errorEvent) => {\r\n      if (this.timedOut) {\r\n        errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);\r\n      } else {\r\n        errorHandler(errorEvent, 'Request cancelled', null, 400);\r\n      }\r\n    };\r\n    xhr.ontimeout = function (errorEvent) {\r\n      errorHandler(errorEvent, 'Request timed out', null, 408);\r\n    };\r\n\r\n    let streaming: boolean | string;\r\n    let statusCode: number;\r\n    let successResponse: boolean;\r\n    let streamPos = 0;\r\n    let unpacked = false;\r\n\r\n    const onResponse = () => {\r\n      clearTimeout(timer);\r\n      successResponse = statusCode < 400;\r\n      if (statusCode == 204) {\r\n        this.complete(null, null, null, null, statusCode);\r\n        return;\r\n      }\r\n      streaming = this.requestMode == XHRStates.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);\r\n    };\r\n\r\n    const onEnd = () => {\r\n      let parsedResponse: any;\r\n      try {\r\n        const contentType = getHeader(xhr, 'content-type');\r\n        /* Be liberal in what we accept; buggy auth servers may respond\r\n         * without the correct contenttype, but assume they're still\r\n         * responding with json */\r\n        const json = contentType ? contentType.indexOf('application/json') >= 0 : xhr.responseType == 'text';\r\n\r\n        if (json) {\r\n          /* If we requested msgpack but server responded with json, then since\r\n           * we set the responseType expecting msgpack, the response will be\r\n           * an ArrayBuffer containing json */\r\n          const jsonResponseBody =\r\n            xhr.responseType === 'arraybuffer'\r\n              ? Platform.BufferUtils.utf8Decode(xhr.response)\r\n              : String(xhr.responseText);\r\n          if (jsonResponseBody.length) {\r\n            parsedResponse = JSON.parse(jsonResponseBody);\r\n          } else {\r\n            parsedResponse = jsonResponseBody;\r\n          }\r\n          unpacked = true;\r\n        } else {\r\n          parsedResponse = xhr.response;\r\n        }\r\n\r\n        if (parsedResponse.response !== undefined) {\r\n          /* unwrap JSON envelope */\r\n          statusCode = parsedResponse.statusCode;\r\n          successResponse = statusCode < 400;\r\n          headers = parsedResponse.headers;\r\n          parsedResponse = parsedResponse.response;\r\n        } else {\r\n          headers = getHeadersAsObject(xhr);\r\n        }\r\n      } catch (e) {\r\n        this.complete(new PartialErrorInfo('Malformed response body from server: ' + (e as Error).message, null, 400));\r\n        return;\r\n      }\r\n\r\n      /* If response is an array, it's an array of protocol messages -- even if\r\n       * is contains an error action (hence the nonsuccess statuscode), we can\r\n       * consider the request to have succeeded, just pass it on to\r\n       * onProtocolMessage to decide what to do */\r\n      if (successResponse || Array.isArray(parsedResponse)) {\r\n        this.complete(null, parsedResponse, headers, unpacked, statusCode);\r\n        return;\r\n      }\r\n\r\n      let err: IPartialErrorInfo | undefined = getAblyError(parsedResponse, headers);\r\n      if (!err) {\r\n        err = new PartialErrorInfo(\r\n          'Error response received from server: ' +\r\n            statusCode +\r\n            ' body was: ' +\r\n            Platform.Config.inspect(parsedResponse),\r\n          null,\r\n          statusCode,\r\n        );\r\n      }\r\n      this.complete(err, parsedResponse, headers, unpacked, statusCode);\r\n    };\r\n\r\n    function onProgress() {\r\n      const responseText = xhr.responseText;\r\n      const bodyEnd = responseText.length - 1;\r\n      let idx, chunk;\r\n      while (streamPos < bodyEnd && (idx = responseText.indexOf('\\n', streamPos)) > -1) {\r\n        chunk = responseText.slice(streamPos, idx);\r\n        streamPos = idx + 1;\r\n        onChunk(chunk);\r\n      }\r\n    }\r\n\r\n    const onChunk = (chunk: string) => {\r\n      try {\r\n        chunk = JSON.parse(chunk);\r\n      } catch (e) {\r\n        this.complete(new PartialErrorInfo('Malformed response body from server: ' + (e as Error).message, null, 400));\r\n        return;\r\n      }\r\n      this.emit('data', chunk);\r\n    };\r\n\r\n    const onStreamEnd = () => {\r\n      onProgress();\r\n      this.streamComplete = true;\r\n      Platform.Config.nextTick(() => {\r\n        this.complete();\r\n      });\r\n    };\r\n\r\n    xhr.onreadystatechange = function () {\r\n      const readyState = xhr.readyState;\r\n      if (readyState < 3) return;\r\n      if (xhr.status !== 0) {\r\n        if (statusCode === undefined) {\r\n          statusCode = xhr.status;\r\n          onResponse();\r\n        }\r\n        if (readyState == 3 && streaming) {\r\n          onProgress();\r\n        } else if (readyState == 4) {\r\n          if (streaming) onStreamEnd();\r\n          else onEnd();\r\n        }\r\n      }\r\n    };\r\n    xhr.send(body as any);\r\n  }\r\n\r\n  dispose(): void {\r\n    const xhr = this.xhr;\r\n    if (xhr) {\r\n      xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;\r\n      this.xhr = null;\r\n      const timer = this.timer;\r\n      if (timer) {\r\n        clearTimeout(timer as NodeJS.Timeout);\r\n        this.timer = null;\r\n      }\r\n      if (!this.requestComplete) xhr.abort();\r\n    }\r\n    delete pendingRequests[this.id];\r\n  }\r\n}\r\n\r\nexport default XHRRequest;\r\n", "import Platform from '../../../../common/platform';\r\nimport CometTransport from '../../../../common/lib/transport/comettransport';\r\nimport XHRRequest from '../http/request/xhrrequest';\r\nimport ConnectionManager, { TransportParams } from 'common/lib/transport/connectionmanager';\r\nimport Auth from 'common/lib/client/auth';\r\nimport { RequestBody, RequestParams } from 'common/types/http';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nvar shortName = TransportNames.XhrPolling;\r\nclass XHRPollingTransport extends CometTransport {\r\n  shortName = shortName;\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params);\r\n    params.stream = false;\r\n    this.shortName = shortName;\r\n  }\r\n\r\n  static isAvailable() {\r\n    return !!(Platform.Config.xhrSupported && Platform.Config.allowComet);\r\n  }\r\n\r\n  toString() {\r\n    return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;\r\n  }\r\n\r\n  createRequest(\r\n    uri: string,\r\n    headers: Record<string, string>,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n  ) {\r\n    return XHRRequest.createRequest(uri, headers, params, body, requestMode, this.timeouts, this.logger);\r\n  }\r\n}\r\n\r\nexport default XHRPollingTransport;\r\n", "import TransportName from 'common/constants/TransportName';\r\nimport Platform from 'common/platform';\r\nimport XhrPollingTransport from './xhrpollingtransport';\r\nimport WebSocketTransport from '../../../../common/lib/transport/websockettransport';\r\n\r\n// For reasons that I don\u2019t understand, if we use [TransportNames.XhrPolling] for the keys in defaultTransports\u2019s, then defaultTransports does not get tree-shaken. Hence using literals instead. They\u2019re still correctly type-checked.\r\n\r\nconst order: TransportName[] = ['xhr_polling'];\r\n\r\nconst defaultTransports: (typeof Platform)['Transports'] = {\r\n  order,\r\n  bundledImplementations: {\r\n    web_socket: WebSocketTransport,\r\n    xhr_polling: XhrPollingTransport,\r\n  },\r\n};\r\n\r\nexport default defaultTransports;\r\n\r\nexport const ModularTransports: (typeof Platform)['Transports'] = {\r\n  order,\r\n  bundledImplementations: {},\r\n};\r\n", "import IWebStorage from 'common/types/IWebStorage';\r\n\r\nconst test = 'ablyjs-storage-test';\r\n\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nclass Webstorage implements IWebStorage {\r\n  sessionSupported: boolean;\r\n  localSupported: boolean;\r\n\r\n  constructor() {\r\n    /* Even just accessing the session/localStorage object can throw a\r\n     * security exception in some circumstances with some browsers. In\r\n     * others, calling setItem will throw. So have to check in this\r\n     * somewhat roundabout way. (If unsupported or no global object,\r\n     * will throw on accessing a property of undefined) */\r\n    try {\r\n      globalObject.sessionStorage.setItem(test, test);\r\n      globalObject.sessionStorage.removeItem(test);\r\n      this.sessionSupported = true;\r\n    } catch (e) {\r\n      this.sessionSupported = false;\r\n    }\r\n\r\n    try {\r\n      globalObject.localStorage.setItem(test, test);\r\n      globalObject.localStorage.removeItem(test);\r\n      this.localSupported = true;\r\n    } catch (e) {\r\n      this.localSupported = false;\r\n    }\r\n  }\r\n\r\n  get(name: string): any {\r\n    return this._get(name, false);\r\n  }\r\n\r\n  getSession(name: string): any {\r\n    return this._get(name, true);\r\n  }\r\n\r\n  remove(name: string): void {\r\n    return this._remove(name, false);\r\n  }\r\n\r\n  removeSession(name: string): void {\r\n    return this._remove(name, true);\r\n  }\r\n\r\n  set(name: string, value: string, ttl?: number): void {\r\n    return this._set(name, value, ttl, false);\r\n  }\r\n\r\n  setSession(name: string, value: string, ttl?: number): void {\r\n    return this._set(name, value, ttl, true);\r\n  }\r\n\r\n  private _set(name: string, value: string, ttl: number | undefined, session: any) {\r\n    const wrappedValue: Record<string, any> = { value: value };\r\n    if (ttl) {\r\n      wrappedValue.expires = Date.now() + ttl;\r\n    }\r\n    return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));\r\n  }\r\n\r\n  private _get(name: string, session?: boolean) {\r\n    if (session && !this.sessionSupported) throw new Error('Session Storage not supported');\r\n    if (!session && !this.localSupported) throw new Error('Local Storage not supported');\r\n    const rawItem = this.storageInterface(session).getItem(name);\r\n    if (!rawItem) return null;\r\n    const wrappedValue = JSON.parse(rawItem);\r\n    if (wrappedValue.expires && wrappedValue.expires < Date.now()) {\r\n      this.storageInterface(session).removeItem(name);\r\n      return null;\r\n    }\r\n    return wrappedValue.value;\r\n  }\r\n\r\n  private _remove(name: string, session?: boolean) {\r\n    return this.storageInterface(session).removeItem(name);\r\n  }\r\n\r\n  private storageInterface(session?: boolean) {\r\n    return session ? globalObject.sessionStorage : globalObject.localStorage;\r\n  }\r\n}\r\n\r\nexport default new Webstorage();\r\n", "import IDefaults from 'common/types/IDefaults';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nconst Defaults: IDefaults = {\r\n  connectivityCheckUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',\r\n  wsConnectivityUrl: 'wss://ws-up.ably-realtime.com',\r\n  /* Order matters here: the base transport is the leftmost one in the\r\n   * intersection of baseTransportOrder and the transports clientOption that's\r\n   * supported. */\r\n  defaultTransports: [TransportNames.XhrPolling, TransportNames.WebSocket],\r\n};\r\n\r\nexport default Defaults;\r\n", "function inspect(buffer: undefined | ArrayBuffer | DataView) {\r\n  if (buffer === undefined) return 'undefined';\r\n  let view;\r\n  let type;\r\n  if (buffer instanceof ArrayBuffer) {\r\n    type = 'ArrayBuffer';\r\n    view = new DataView(buffer);\r\n  } else if (buffer instanceof DataView) {\r\n    type = 'DataView';\r\n    view = buffer;\r\n  }\r\n  if (!view) return JSON.stringify(buffer);\r\n  const bytes = [];\r\n  for (let i = 0; i < buffer.byteLength; i++) {\r\n    if (i > 20) {\r\n      bytes.push('...');\r\n      break;\r\n    }\r\n    let byte_ = view.getUint8(i).toString(16);\r\n    if (byte_.length === 1) byte_ = '0' + byte_;\r\n    bytes.push(byte_);\r\n  }\r\n  return '<' + type + ' ' + bytes.join(' ') + '>';\r\n}\r\n\r\n// Encode string as utf8 into dataview at offset\r\nfunction utf8Write(view: DataView, offset: number, string: string) {\r\n  for (let i = 0, l = string.length; i < l; i++) {\r\n    const codePoint = string.charCodeAt(i);\r\n\r\n    // One byte of UTF-8\r\n    if (codePoint < 0x80) {\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x7f) | 0x00);\r\n      continue;\r\n    }\r\n\r\n    // Two bytes of UTF-8\r\n    if (codePoint < 0x800) {\r\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x1f) | 0xc0);\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\r\n      continue;\r\n    }\r\n\r\n    // Three bytes of UTF-8.\r\n    if (codePoint < 0x10000) {\r\n      view.setUint8(offset++, ((codePoint >>> 12) & 0x0f) | 0xe0);\r\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\r\n      continue;\r\n    }\r\n\r\n    // Four bytes of UTF-8\r\n    if (codePoint < 0x110000) {\r\n      view.setUint8(offset++, ((codePoint >>> 18) & 0x07) | 0xf0);\r\n      view.setUint8(offset++, ((codePoint >>> 12) & 0x3f) | 0x80);\r\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\r\n      continue;\r\n    }\r\n    throw new Error('bad codepoint ' + codePoint);\r\n  }\r\n}\r\n\r\nfunction utf8Read(view: DataView, offset: number, length: number) {\r\n  let string = '';\r\n  for (let i = offset, end = offset + length; i < end; i++) {\r\n    const byte_ = view.getUint8(i);\r\n    // One byte character\r\n    if ((byte_ & 0x80) === 0x00) {\r\n      string += String.fromCharCode(byte_);\r\n      continue;\r\n    }\r\n    // Two byte character\r\n    if ((byte_ & 0xe0) === 0xc0) {\r\n      string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));\r\n      continue;\r\n    }\r\n    // Three byte character\r\n    if ((byte_ & 0xf0) === 0xe0) {\r\n      string += String.fromCharCode(\r\n        ((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0),\r\n      );\r\n      continue;\r\n    }\r\n    // Four byte character\r\n    if ((byte_ & 0xf8) === 0xf0) {\r\n      string += String.fromCharCode(\r\n        ((byte_ & 0x07) << 18) |\r\n          ((view.getUint8(++i) & 0x3f) << 12) |\r\n          ((view.getUint8(++i) & 0x3f) << 6) |\r\n          ((view.getUint8(++i) & 0x3f) << 0),\r\n      );\r\n      continue;\r\n    }\r\n    throw new Error('Invalid byte ' + byte_.toString(16));\r\n  }\r\n  return string;\r\n}\r\n\r\nfunction utf8ByteCount(string: string) {\r\n  let count = 0;\r\n  for (let i = 0, l = string.length; i < l; i++) {\r\n    const codePoint = string.charCodeAt(i);\r\n    if (codePoint < 0x80) {\r\n      count += 1;\r\n      continue;\r\n    }\r\n    if (codePoint < 0x800) {\r\n      count += 2;\r\n      continue;\r\n    }\r\n    if (codePoint < 0x10000) {\r\n      count += 3;\r\n      continue;\r\n    }\r\n    if (codePoint < 0x110000) {\r\n      count += 4;\r\n      continue;\r\n    }\r\n    throw new Error('bad codepoint ' + codePoint);\r\n  }\r\n  return count;\r\n}\r\n\r\nfunction encode(value: unknown, sparse?: boolean) {\r\n  const size = sizeof(value, sparse);\r\n  if (size === 0) return undefined;\r\n  const buffer = new ArrayBuffer(size);\r\n  const view = new DataView(buffer);\r\n  _encode(value, view, 0, sparse);\r\n  return buffer;\r\n}\r\n\r\nconst SH_L_32 = (1 << 16) * (1 << 16),\r\n  SH_R_32 = 1 / SH_L_32;\r\nfunction getInt64(view: DataView, offset: number) {\r\n  offset = offset || 0;\r\n  return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);\r\n}\r\n\r\nfunction getUint64(view: DataView, offset: number) {\r\n  offset = offset || 0;\r\n  return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);\r\n}\r\n\r\nfunction setInt64(view: DataView, offset: number, val: number) {\r\n  if (val < 0x8000000000000000) {\r\n    view.setInt32(offset, Math.floor(val * SH_R_32));\r\n    view.setInt32(offset + 4, val & -1);\r\n  } else {\r\n    view.setUint32(offset, 0x7fffffff);\r\n    view.setUint32(offset + 4, 0x7fffffff);\r\n  }\r\n}\r\n\r\nfunction setUint64(view: DataView, offset: number, val: number) {\r\n  if (val < 0x10000000000000000) {\r\n    view.setUint32(offset, Math.floor(val * SH_R_32));\r\n    view.setInt32(offset + 4, val & -1);\r\n  } else {\r\n    view.setUint32(offset, 0xffffffff);\r\n    view.setUint32(offset + 4, 0xffffffff);\r\n  }\r\n}\r\n\r\n// https://gist.github.com/frsyuki/5432559 - v5 spec\r\n//\r\n// I've used one extension point from `fixext 1` to store `undefined`. On the wire this\r\n// should translate to exactly 0xd40000\r\n//\r\n// +--------+--------+--------+\r\n// |  0xd4  |  0x00  |  0x00  |\r\n// +--------+--------+--------+\r\n//    ^ fixext |        ^ value part unused (fixed to be 0)\r\n//             ^ indicates undefined value\r\n//\r\n\r\nclass Decoder {\r\n  offset: number;\r\n  view: DataView;\r\n\r\n  constructor(view: DataView, offset?: number) {\r\n    this.offset = offset || 0;\r\n    this.view = view;\r\n  }\r\n\r\n  map = (length: number) => {\r\n    const value: { [key: string]: ArrayBuffer } = {};\r\n    for (let i = 0; i < length; i++) {\r\n      const key = this.parse();\r\n      value[key as string] = this.parse() as ArrayBuffer;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  bin = (length: number) => {\r\n    const value = new ArrayBuffer(length);\r\n    new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);\r\n    this.offset += length;\r\n    return value;\r\n  };\r\n\r\n  buf = this.bin;\r\n\r\n  str = (length: number) => {\r\n    const value = utf8Read(this.view, this.offset, length);\r\n    this.offset += length;\r\n    return value;\r\n  };\r\n\r\n  array = (length: number) => {\r\n    const value = new Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n      value[i] = this.parse();\r\n    }\r\n    return value;\r\n  };\r\n\r\n  ext = (length: number) => {\r\n    this.offset += length;\r\n    return {\r\n      type: this.view.getInt8(this.offset),\r\n      data: this.buf(length),\r\n    };\r\n  };\r\n\r\n  parse = (): unknown => {\r\n    const type = this.view.getUint8(this.offset);\r\n    let value, length;\r\n\r\n    // Positive FixInt - 0xxxxxxx\r\n    if ((type & 0x80) === 0x00) {\r\n      this.offset++;\r\n      return type;\r\n    }\r\n\r\n    // FixMap - 1000xxxx\r\n    if ((type & 0xf0) === 0x80) {\r\n      length = type & 0x0f;\r\n      this.offset++;\r\n      return this.map(length);\r\n    }\r\n\r\n    // FixArray - 1001xxxx\r\n    if ((type & 0xf0) === 0x90) {\r\n      length = type & 0x0f;\r\n      this.offset++;\r\n      return this.array(length);\r\n    }\r\n\r\n    // FixStr - 101xxxxx\r\n    if ((type & 0xe0) === 0xa0) {\r\n      length = type & 0x1f;\r\n      this.offset++;\r\n      return this.str(length);\r\n    }\r\n\r\n    // Negative FixInt - 111xxxxx\r\n    if ((type & 0xe0) === 0xe0) {\r\n      value = this.view.getInt8(this.offset);\r\n      this.offset++;\r\n      return value;\r\n    }\r\n\r\n    switch (type) {\r\n      // nil\r\n      case 0xc0:\r\n        this.offset++;\r\n        return null;\r\n\r\n      // 0xc1 never used - use for undefined (NON-STANDARD)\r\n      case 0xc1:\r\n        this.offset++;\r\n        return undefined;\r\n\r\n      // false\r\n      case 0xc2:\r\n        this.offset++;\r\n        return false;\r\n\r\n      // true\r\n      case 0xc3:\r\n        this.offset++;\r\n        return true;\r\n\r\n      // bin 8\r\n      case 0xc4:\r\n        length = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return this.bin(length);\r\n\r\n      // bin 16\r\n      case 0xc5:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.bin(length);\r\n\r\n      // bin 32\r\n      case 0xc6:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.bin(length);\r\n\r\n      // ext 8\r\n      case 0xc7:\r\n        length = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return this.ext(length);\r\n\r\n      // ext 16\r\n      case 0xc8:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.ext(length);\r\n\r\n      // ext 32\r\n      case 0xc9:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.ext(length);\r\n\r\n      // float 32\r\n      case 0xca:\r\n        value = this.view.getFloat32(this.offset + 1);\r\n        this.offset += 5;\r\n        return value;\r\n\r\n      // float 64\r\n      case 0xcb:\r\n        value = this.view.getFloat64(this.offset + 1);\r\n        this.offset += 9;\r\n        return value;\r\n\r\n      // uint8\r\n      case 0xcc:\r\n        value = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return value;\r\n\r\n      // uint 16\r\n      case 0xcd:\r\n        value = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return value;\r\n\r\n      // uint 32\r\n      case 0xce:\r\n        value = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return value;\r\n\r\n      // uint 64\r\n      case 0xcf:\r\n        value = getUint64(this.view, this.offset + 1);\r\n        this.offset += 9;\r\n        return value;\r\n\r\n      // int 8\r\n      case 0xd0:\r\n        value = this.view.getInt8(this.offset + 1);\r\n        this.offset += 2;\r\n        return value;\r\n\r\n      // int 16\r\n      case 0xd1:\r\n        value = this.view.getInt16(this.offset + 1);\r\n        this.offset += 3;\r\n        return value;\r\n\r\n      // int 32\r\n      case 0xd2:\r\n        value = this.view.getInt32(this.offset + 1);\r\n        this.offset += 5;\r\n        return value;\r\n\r\n      // int 64\r\n      case 0xd3:\r\n        value = getInt64(this.view, this.offset + 1);\r\n        this.offset += 9;\r\n        return value;\r\n\r\n      // fixext 1\r\n      case 0xd4:\r\n        length = 1;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 2\r\n      case 0xd5:\r\n        length = 2;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 4\r\n      case 0xd6:\r\n        length = 4;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 8\r\n      case 0xd7:\r\n        length = 8;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 16\r\n      case 0xd8:\r\n        length = 16;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // str8\r\n      case 0xd9:\r\n        length = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return this.str(length);\r\n\r\n      // str 16\r\n      case 0xda:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.str(length);\r\n\r\n      // str 32\r\n      case 0xdb:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.str(length);\r\n\r\n      // array 16\r\n      case 0xdc:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.array(length);\r\n\r\n      // array 32\r\n      case 0xdd:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.array(length);\r\n\r\n      // map 16\r\n      case 0xde:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.map(length);\r\n\r\n      // map 32\r\n      case 0xdf:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.map(length);\r\n    }\r\n    throw new Error('Unknown type 0x' + type.toString(16));\r\n  };\r\n}\r\n\r\nfunction decode(buffer: ArrayBuffer) {\r\n  const view = new DataView(buffer);\r\n  const decoder = new Decoder(view);\r\n  const value = decoder.parse();\r\n  if (decoder.offset !== buffer.byteLength) throw new Error(buffer.byteLength - decoder.offset + ' trailing bytes');\r\n  return value;\r\n}\r\n\r\nfunction encodeableKeys(value: { [key: string]: unknown }, sparse?: boolean) {\r\n  return Object.keys(value).filter(function (e) {\r\n    const val = value[e],\r\n      type = typeof val;\r\n    return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!(val as Date).toJSON);\r\n  });\r\n}\r\n\r\nfunction _encode(value: unknown, view: DataView, offset: number, sparse?: boolean): number {\r\n  const type = typeof value;\r\n\r\n  // Strings Bytes\r\n  // There are four string types: fixstr/str8/str16/str32\r\n  if (typeof value === 'string') {\r\n    const length = utf8ByteCount(value);\r\n\r\n    // fixstr\r\n    if (length < 0x20) {\r\n      view.setUint8(offset, length | 0xa0);\r\n      utf8Write(view, offset + 1, value);\r\n      return 1 + length;\r\n    }\r\n\r\n    // str8\r\n    if (length < 0x100) {\r\n      view.setUint8(offset, 0xd9);\r\n      view.setUint8(offset + 1, length);\r\n      utf8Write(view, offset + 2, value);\r\n      return 2 + length;\r\n    }\r\n\r\n    // str16\r\n    if (length < 0x10000) {\r\n      view.setUint8(offset, 0xda);\r\n      view.setUint16(offset + 1, length);\r\n      utf8Write(view, offset + 3, value);\r\n      return 3 + length;\r\n    }\r\n    // str32\r\n    if (length < 0x100000000) {\r\n      view.setUint8(offset, 0xdb);\r\n      view.setUint32(offset + 1, length);\r\n      utf8Write(view, offset + 5, value);\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\r\n    // extract the arraybuffer and fallthrough\r\n    value = value.buffer;\r\n  }\r\n\r\n  // There are three bin types: bin8/bin16/bin32\r\n  if (value instanceof ArrayBuffer) {\r\n    const length = value.byteLength;\r\n\r\n    // bin8\r\n    if (length < 0x100) {\r\n      view.setUint8(offset, 0xc4);\r\n      view.setUint8(offset + 1, length);\r\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);\r\n      return 2 + length;\r\n    }\r\n\r\n    // bin16\r\n    if (length < 0x10000) {\r\n      view.setUint8(offset, 0xc5);\r\n      view.setUint16(offset + 1, length);\r\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);\r\n      return 3 + length;\r\n    }\r\n\r\n    // bin 32\r\n    if (length < 0x100000000) {\r\n      view.setUint8(offset, 0xc6);\r\n      view.setUint32(offset + 1, length);\r\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    // Floating Point\r\n    // NOTE: We're always using float64\r\n    if (Math.floor(value) !== value) {\r\n      view.setUint8(offset, 0xcb);\r\n      view.setFloat64(offset + 1, value);\r\n      return 9;\r\n    }\r\n\r\n    // Integers\r\n    if (value >= 0) {\r\n      // positive fixnum\r\n      if (value < 0x80) {\r\n        view.setUint8(offset, value);\r\n        return 1;\r\n      }\r\n      // uint 8\r\n      if (value < 0x100) {\r\n        view.setUint8(offset, 0xcc);\r\n        view.setUint8(offset + 1, value);\r\n        return 2;\r\n      }\r\n      // uint 16\r\n      if (value < 0x10000) {\r\n        view.setUint8(offset, 0xcd);\r\n        view.setUint16(offset + 1, value);\r\n        return 3;\r\n      }\r\n      // uint 32\r\n      if (value < 0x100000000) {\r\n        view.setUint8(offset, 0xce);\r\n        view.setUint32(offset + 1, value);\r\n        return 5;\r\n      }\r\n      // uint 64\r\n      if (value < 0x10000000000000000) {\r\n        view.setUint8(offset, 0xcf);\r\n        setUint64(view, offset + 1, value);\r\n        return 9;\r\n      }\r\n      throw new Error('Number too big 0x' + value.toString(16));\r\n    }\r\n\r\n    // negative fixnum\r\n    if (value >= -0x20) {\r\n      view.setInt8(offset, value);\r\n      return 1;\r\n    }\r\n    // int 8\r\n    if (value >= -0x80) {\r\n      view.setUint8(offset, 0xd0);\r\n      view.setInt8(offset + 1, value);\r\n      return 2;\r\n    }\r\n    // int 16\r\n    if (value >= -0x8000) {\r\n      view.setUint8(offset, 0xd1);\r\n      view.setInt16(offset + 1, value);\r\n      return 3;\r\n    }\r\n    // int 32\r\n    if (value >= -0x80000000) {\r\n      view.setUint8(offset, 0xd2);\r\n      view.setInt32(offset + 1, value);\r\n      return 5;\r\n    }\r\n    // int 64\r\n    if (value >= -0x8000000000000000) {\r\n      view.setUint8(offset, 0xd3);\r\n      setInt64(view, offset + 1, value);\r\n      return 9;\r\n    }\r\n    throw new Error('Number too small -0x' + (-value).toString(16).substr(1));\r\n  }\r\n\r\n  // undefined - use d4 (NON-STANDARD)\r\n  if (type === 'undefined') {\r\n    if (sparse) return 0;\r\n    view.setUint8(offset, 0xd4);\r\n    view.setUint8(offset + 1, 0x00);\r\n    view.setUint8(offset + 2, 0x00);\r\n    return 3;\r\n  }\r\n\r\n  // null\r\n  if (value === null) {\r\n    if (sparse) return 0;\r\n    view.setUint8(offset, 0xc0);\r\n    return 1;\r\n  }\r\n\r\n  // Boolean\r\n  if (type === 'boolean') {\r\n    view.setUint8(offset, value ? 0xc3 : 0xc2);\r\n    return 1;\r\n  }\r\n\r\n  if ('function' === typeof (value as Date).toJSON) return _encode((value as Date).toJSON(), view, offset, sparse);\r\n\r\n  // Container Types\r\n  if (type === 'object') {\r\n    let length: number,\r\n      size = 0;\r\n    let keys: string[] | undefined;\r\n    const isArray = Array.isArray(value);\r\n\r\n    if (isArray) {\r\n      length = (value as unknown[]).length;\r\n    } else {\r\n      keys = encodeableKeys(value as { [key: string]: unknown }, sparse);\r\n      length = keys.length;\r\n    }\r\n\r\n    if (length < 0x10) {\r\n      view.setUint8(offset, length | (isArray ? 0x90 : 0x80));\r\n      size = 1;\r\n    } else if (length < 0x10000) {\r\n      view.setUint8(offset, isArray ? 0xdc : 0xde);\r\n      view.setUint16(offset + 1, length);\r\n      size = 3;\r\n    } else if (length < 0x100000000) {\r\n      view.setUint8(offset, isArray ? 0xdd : 0xdf);\r\n      view.setUint32(offset + 1, length);\r\n      size = 5;\r\n    }\r\n\r\n    if (isArray) {\r\n      for (let i = 0; i < length; i++) {\r\n        size += _encode((value as unknown[])[i], view, offset + size, sparse);\r\n      }\r\n    } else if (keys) {\r\n      for (let i = 0; i < length; i++) {\r\n        const key = keys[i];\r\n        size += _encode(key, view, offset + size);\r\n        size += _encode((value as { [key: string]: unknown })[key], view, offset + size, sparse);\r\n      }\r\n    }\r\n\r\n    return size;\r\n  }\r\n  if (type === 'function') return 0;\r\n\r\n  throw new Error('Unknown type ' + type);\r\n}\r\n\r\nfunction sizeof(value: unknown, sparse?: boolean): number {\r\n  const type = typeof value;\r\n\r\n  // fixstr or str8 or str16 or str32\r\n  if (type === 'string') {\r\n    const length = utf8ByteCount(value as string);\r\n    if (length < 0x20) {\r\n      return 1 + length;\r\n    }\r\n    if (length < 0x100) {\r\n      return 2 + length;\r\n    }\r\n    if (length < 0x10000) {\r\n      return 3 + length;\r\n    }\r\n    if (length < 0x100000000) {\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\r\n    // extract the arraybuffer and fallthrough\r\n    value = value.buffer;\r\n  }\r\n\r\n  // bin8 or bin16 or bin32\r\n  if (value instanceof ArrayBuffer) {\r\n    const length = value.byteLength;\r\n    if (length < 0x100) {\r\n      return 2 + length;\r\n    }\r\n    if (length < 0x10000) {\r\n      return 3 + length;\r\n    }\r\n    if (length < 0x100000000) {\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    // Floating Point (32 bits)\r\n    // double\r\n    if (Math.floor(value) !== value) return 9;\r\n\r\n    // Integers\r\n    if (value >= 0) {\r\n      // positive fixint\r\n      if (value < 0x80) return 1;\r\n      // uint 8\r\n      if (value < 0x100) return 2;\r\n      // uint 16\r\n      if (value < 0x10000) return 3;\r\n      // uint 32\r\n      if (value < 0x100000000) return 5;\r\n      // uint 64\r\n      if (value < 0x10000000000000000) return 9;\r\n      // Too big\r\n      throw new Error('Number too big 0x' + value.toString(16));\r\n    }\r\n    // negative fixint\r\n    if (value >= -0x20) return 1;\r\n    // int 8\r\n    if (value >= -0x80) return 2;\r\n    // int 16\r\n    if (value >= -0x8000) return 3;\r\n    // int 32\r\n    if (value >= -0x80000000) return 5;\r\n    // int 64\r\n    if (value >= -0x8000000000000000) return 9;\r\n    // Too small\r\n    throw new Error('Number too small -0x' + value.toString(16).substr(1));\r\n  }\r\n\r\n  // Boolean\r\n  if (type === 'boolean') return 1;\r\n\r\n  // undefined, null\r\n  if (value === null) return sparse ? 0 : 1;\r\n  if (value === undefined) return sparse ? 0 : 3;\r\n\r\n  if ('function' === typeof (value as Date).toJSON) return sizeof((value as Date).toJSON(), sparse);\r\n\r\n  // Container Types\r\n  if (type === 'object') {\r\n    let length: number,\r\n      size = 0;\r\n    if (Array.isArray(value)) {\r\n      length = value.length;\r\n      for (let i = 0; i < length; i++) {\r\n        size += sizeof(value[i], sparse);\r\n      }\r\n    } else {\r\n      const keys = encodeableKeys(value as { [key: string]: unknown }, sparse);\r\n      length = keys.length;\r\n      for (let i = 0; i < length; i++) {\r\n        const key = keys[i];\r\n        size += sizeof(key) + sizeof((value as { [key: string]: unknown })[key], sparse);\r\n      }\r\n    }\r\n    if (length < 0x10) {\r\n      return 1 + size;\r\n    }\r\n    if (length < 0x10000) {\r\n      return 3 + size;\r\n    }\r\n    if (length < 0x100000000) {\r\n      return 5 + size;\r\n    }\r\n    throw new Error('Array or object too long 0x' + length.toString(16));\r\n  }\r\n  if (type === 'function') return 0;\r\n\r\n  throw new Error('Unknown type ' + type);\r\n}\r\n\r\nexport default {\r\n  encode,\r\n  decode,\r\n  inspect,\r\n  utf8Write,\r\n  utf8Read,\r\n  utf8ByteCount,\r\n};\r\n", "import HttpMethods from 'common/constants/HttpMethods';\r\nimport BaseClient from 'common/lib/client/baseclient';\r\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport { RequestBody, RequestResultError, ResponseHeaders, RequestParams, RequestResult } from 'common/types/http';\r\nimport Platform from 'common/platform';\r\nimport Defaults from 'common/lib/util/defaults';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\nfunction isAblyError(responseBody: unknown, headers: Headers): responseBody is { error?: ErrorInfo } {\r\n  return !!headers.get('x-ably-errorcode');\r\n}\r\n\r\nfunction getAblyError(responseBody: unknown, headers: Headers) {\r\n  if (isAblyError(responseBody, headers)) {\r\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\r\n  }\r\n}\r\n\r\nfunction convertHeaders(headers: Headers) {\r\n  const result: ResponseHeaders = {};\r\n\r\n  headers.forEach((value, key) => {\r\n    result[key] = value;\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nexport default async function fetchRequest(\r\n  method: HttpMethods,\r\n  client: BaseClient | null,\r\n  uri: string,\r\n  headers: Record<string, string> | null,\r\n  params: RequestParams,\r\n  body: RequestBody | null,\r\n): Promise<RequestResult> {\r\n  const fetchHeaders = new Headers(headers || {});\r\n  const _method = method ? method.toUpperCase() : Utils.isNil(body) ? 'GET' : 'POST';\r\n\r\n  const controller = new AbortController();\r\n\r\n  let timeout: ReturnType<typeof setTimeout>; // This way we don\u2019t have to worry about the fact that the TypeScript compiler is \u2014 for reasons I haven\u2019t looked into \u2014 picking up the signature of the Node version of setTimeout, which has a different return type to the web one\r\n  const timeoutPromise: Promise<RequestResult> = new Promise((resolve) => {\r\n    timeout = setTimeout(\r\n      () => {\r\n        controller.abort();\r\n        // When AbortController.abort() is called, the fetch() promise rejects with a DOMException named AbortError (source: https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\r\n        // However, we beat it in the Promise.race() by resolving our custom 'Request timed out' error on the next line, thereby exposing users to the better-formatted error.\r\n        resolve({ error: new PartialErrorInfo('Request timed out', null, 408) });\r\n      },\r\n      client ? client.options.timeouts.httpRequestTimeout : Defaults.TIMEOUTS.httpRequestTimeout,\r\n    );\r\n  });\r\n\r\n  const requestInit: RequestInit = {\r\n    method: _method,\r\n    headers: fetchHeaders,\r\n    body: body as any,\r\n    signal: controller.signal,\r\n  };\r\n\r\n  if (!Platform.Config.isWebworker) {\r\n    requestInit.credentials = fetchHeaders.has('authorization') ? 'include' : 'same-origin';\r\n  }\r\n\r\n  const resultPromise = (async (): Promise<RequestResult> => {\r\n    try {\r\n      const res = await Utils.getGlobalObject().fetch(uri + '?' + new URLSearchParams(params || {}), requestInit);\r\n\r\n      clearTimeout(timeout!);\r\n\r\n      if (res.status == 204) {\r\n        return { error: null, statusCode: res.status };\r\n      }\r\n\r\n      const contentType = res.headers.get('Content-Type');\r\n      let body;\r\n      if (contentType && contentType.indexOf('application/x-msgpack') > -1) {\r\n        body = await res.arrayBuffer();\r\n      } else if (contentType && contentType.indexOf('application/json') > -1) {\r\n        body = await res.json();\r\n      } else {\r\n        body = await res.text();\r\n      }\r\n\r\n      const unpacked = !!contentType && contentType.indexOf('application/x-msgpack') === -1;\r\n      const headers = convertHeaders(res.headers);\r\n\r\n      if (!res.ok) {\r\n        const error =\r\n          getAblyError(body, res.headers) ||\r\n          new PartialErrorInfo(\r\n            'Error response received from server: ' + res.status + ' body was: ' + Platform.Config.inspect(body),\r\n            null,\r\n            res.status,\r\n          );\r\n\r\n        return { error, body, headers, unpacked, statusCode: res.status };\r\n      } else {\r\n        return { error: null, body, headers, unpacked, statusCode: res.status };\r\n      }\r\n    } catch (error) {\r\n      clearTimeout(timeout!);\r\n      return { error: error as RequestResultError };\r\n    }\r\n  })();\r\n\r\n  return Promise.race([timeoutPromise, resultPromise]);\r\n}\r\n", "import { HTTPRequestImplementations } from '../http';\r\nimport XHRRequest from './xhrrequest';\r\nimport fetchRequest from './fetchrequest';\r\n\r\nexport const defaultBundledRequestImplementations: HTTPRequestImplementations = {\r\n  XHRRequest: XHRRequest,\r\n  FetchRequest: fetchRequest,\r\n};\r\n\r\nexport const modularBundledRequestImplementations: HTTPRequestImplementations = {};\r\n"],
  "mappings": "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",
  "names": ["web_exports", "__export", "ErrorInfo", "DefaultRealtime", "DefaultRest", "web_default", "msgpack_default", "fromDeserializedIncludingDependencies", "__toCommonJS", "Platform", "globalObject", "pad", "timeSegment", "three", "getHandler", "logger", "Platform", "msg", "time", "getDefaultLoggers", "_a", "consoleLogger", "errorLogger", "globalObject", "args", "_Logger", "description", "level", "handler", "logHandler", "logErrorHandler", "action", "message", "oldName", "newName", "className", "Logger", "logger_default", "utils_exports", "__export", "Format", "allSame", "allToLowerCase", "allToUpperCase", "arrChooseN", "arrDeleteValue", "arrEquals", "arrIntersect", "arrIntersectOb", "arrPopRandomElement", "arrSubtract", "arrWithoutValue", "cheapRandStr", "containsValue", "copy", "createMissingPluginError", "dataSizeBytes", "decodeBody", "encodeBody", "ensureArray", "forInOwnNonNullProperties", "getBackoffCoefficient", "getGlobalObject", "getJitterCoefficient", "getRetryTime", "inherits", "inspectBody", "inspectError", "intersect", "isEmpty", "isErrorInfoOrPartialErrorInfo", "isNil", "isObject", "keysArray", "matchDerivedChannel", "mixin", "parseQueryString", "prototypicalClone", "randomString", "shallowClone", "shallowEquals", "throwMissingPluginError", "toBase64", "toQueryString", "valuesArray", "whenPromiseSettles", "withTimeoutAsync", "toString", "err", "result", "inspectError", "ErrorInfo", "_ErrorInfo", "message", "code", "statusCode", "cause", "values", "Platform", "PartialErrorInfo", "_PartialErrorInfo", "isNil", "randomPosn", "arrOrStr", "mixin", "target", "args", "i", "source", "key", "copy", "src", "ensureArray", "obj", "isNil", "isObject", "ob", "isEmpty", "prop", "arg", "shallowClone", "result", "prototypicalClone", "ownProperties", "F", "inherits", "ctor", "superCtor", "Platform", "containsValue", "val", "intersect", "arr", "arrIntersect", "arrIntersectOb", "arr1", "arr2", "member", "arrSubtract", "element", "arrDeleteValue", "idx", "res", "arrWithoutValue", "newArr", "keysArray", "ownOnly", "valuesArray", "forInOwnNonNullProperties", "fn", "allSame", "first", "item", "Format", "arrPopRandomElement", "toQueryString", "params", "parts", "parseQueryString", "query", "match", "search", "isErrorInfoOrPartialErrorInfo", "err", "ErrorInfo", "PartialErrorInfo", "inspectError", "_a", "_b", "inspectBody", "body", "dataSizeBytes", "data", "cheapRandStr", "randomString", "numBytes", "buffer", "arrChooseN", "n", "numItems", "mutableArr", "whenPromiseSettles", "promise", "callback", "decodeBody", "MsgPack", "format", "throwMissingPluginError", "encodeBody", "allToLowerCase", "allToUpperCase", "getBackoffCoefficient", "count", "getJitterCoefficient", "getRetryTime", "initialTimeout", "retryAttempt", "getGlobalObject", "shallowEquals", "matchDerivedChannel", "name", "regex", "toBase64", "str", "bufferUtils", "textBuffer", "arrEquals", "a", "b", "createMissingPluginError", "pluginName", "withTimeoutAsync", "timeout", "e", "_resolve", "reject", "version", "agent", "version", "Defaults", "getHost", "getPort", "getHttpScheme", "environmentFallbackHosts", "getFallbackHosts", "getHosts", "checkHost", "objectifyOptions", "normaliseOptions", "defaultGetHeaders", "defaultPostHeaders", "options", "host", "ws", "tls", "environment", "fallbackHosts", "httpMaxRetryCount", "arrChooseN", "hosts", "ErrorInfo", "getRealtimeHost", "production", "logger", "logger_default", "getTimeouts", "timeouts", "prop", "getAgentString", "agentStr", "allowKeyOrToken", "sourceForErrorMessage", "modularPluginsToInclude", "msg", "optionsObj", "__spreadProps", "__spreadValues", "MsgPack", "loggerToUse", "restHost", "realtimeHost", "Platform", "headers", "connectivityCheckParams", "connectivityCheckUrl", "uri", "qs", "parseQueryString", "normaliseChannelOptions", "Crypto", "channelOptions", "throwMissingPluginError", "cipher", "contentTypes", "defaultHeadersOptions", "format", "protocolVersion", "contentType", "defaults_default", "getDefaults", "platformDefaults", "Multicaster", "_Multicaster", "logger", "members", "err", "result", "member", "e", "logger_default", "args", "resolve", "reject", "instance", "fn", "multicaster_default", "HttpMethods", "HttpMethods_default", "HttpStatusCodes", "isSuccessCode", "statusCode", "HttpStatusCodes_default", "MAX_TOKEN_LENGTH", "random", "isRealtime", "client", "normaliseAuthcallbackError", "err", "isErrorInfoOrPartialErrorInfo", "ErrorInfo", "inspectError", "hmac", "text", "key", "bufferUtils", "Platform", "textBuffer", "keyBuffer", "digest", "c14n", "capability", "c14nCapability", "keys", "keysArray", "i", "logAndValidateTokenAuthMethod", "authOptions", "logger", "logger_default", "msg", "basicAuthForced", "options", "useTokenAuth", "noWayToRenew", "trId", "getTokenRequestId", "Auth", "tokenParams", "tokenDetails", "resolve", "reject", "HttpStatusCodes_default", "resolvedAuthOptions", "resolvedTokenParams", "copy", "tokenRequestCallback", "params", "cb", "authHeaders", "mixin", "usePost", "providedQsParams", "queryIdx", "parseQueryString", "authParams", "authUrlRequestCallback", "result", "_a", "_b", "body", "contentType", "contentTypeHeaderOrHeaders", "inspectBody", "json", "e", "headers", "toQueryString", "whenPromiseSettles", "HttpMethods_default", "tokenRequest", "signedTokenParams", "tokenCb", "keyName", "path", "tokenUri", "host", "requestHeaders", "defaults_default", "tokenRequestCallbackTimeoutExpired", "timeoutLength", "tokenRequestCallbackTimeout", "tokenRequestOrDetails", "objectSize", "tokenResponse", "unpacked", "keyParts", "keySecret", "request", "clientId", "ttl", "nonce", "timestamp", "signText", "toBase64", "queryTime", "forceSupersede", "token", "promise", "multicaster_default", "tokenRequestId", "caughtError", "multicaster", "tokenClientId", "error", "specifiers", "auth_default", "paramString", "params", "paramPairs", "needle", "appendingParams", "uri", "logResult", "result", "method", "logger", "logger_default", "inspectError", "Platform", "logRequest", "body", "Http", "client", "_a", "_b", "connection", "connectionHost", "defaults_default", "path", "headers", "ErrorInfo", "uriFromHost", "host", "currentFallback", "hosts", "tryAHostStartedAt", "tryAHost", "candidateHosts", "persistOnSuccess", "err", "BaseClient", "options", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "logger_default", "Platform", "normalOptions", "defaults_default", "keyMatch", "msg", "ErrorInfo", "Http", "auth_default", "throwMissingPluginError", "host", "params", "method", "path", "version", "body", "customHeaders", "specOrSpecs", "channels", "logOptions", "baseclient_default", "DeviceDetails", "_DeviceDetails", "_a", "_b", "_c", "_d", "result", "body", "MsgPack", "format", "encodeBody", "decodeBody", "values", "ErrorInfo", "count", "i", "devicedetails_default", "withAuthDetails", "client", "headers", "params", "opCallback", "authHeaders", "mixin", "authParams", "unenvelope", "result", "MsgPack", "format", "HttpStatusCodes_default", "__spreadProps", "__spreadValues", "body", "decodeBody", "e", "isErrorInfoOrPartialErrorInfo", "PartialErrorInfo", "inspectError", "wrappedStatusCode", "response", "wrappedHeaders", "wrappedErr", "logResult", "method", "path", "logger", "logger_default", "appendingParams", "paramString", "Platform", "Resource", "_Resource", "envelope", "throwError", "HttpMethods_default", "doRequest", "_a", "decodedBody", "throwMissingPluginError", "decodeErr", "httpResult", "auth_default", "resource_default", "getRelParams", "linkUrl", "urlMatch", "parseQueryString", "parseRelLinks", "linkHeader", "relParams", "i", "linkMatch", "params", "returnErrOnly", "err", "body", "useHPR", "PaginatedResource", "client", "path", "headers", "envelope", "bodyHandler", "useHttpPaginatedResponse", "result", "resource_default", "logger_default", "inspectError", "items", "HttpStatusCodes_default", "e", "HttpPaginatedResponse", "PaginatedResult", "resource", "self", "_a", "res", "statusCode", "paginatedresource_default", "_PushChannelSubscription", "result", "body", "MsgPack", "format", "decodeBody", "values", "count", "i", "encodeBody", "PushChannelSubscription", "pushchannelsubscription_default", "Push", "client", "Admin", "DeviceRegistrations", "ChannelSubscriptions", "recipient", "payload", "format", "headers", "defaults_default", "params", "body", "mixin", "requestBody", "encodeBody", "resource_default", "device", "devicedetails_default", "response", "deviceIdOrDetails", "deviceId", "ErrorInfo", "envelope", "paginatedresource_default", "unpacked", "_ChannelSubscriptions", "subscription", "pushchannelsubscription_default", "parsedBody", "decodeBody", "i", "push_default", "normaliseContext", "context", "normalizeCipherOptions", "Crypto", "logger", "options", "throwMissingPluginError", "cipher", "getMessageSize", "msg", "size", "dataSizeBytes", "fromEncoded", "encoded", "inputOptions", "fromValues", "decode", "e", "logger_default", "fromEncodedArray", "encodedArray", "encrypt", "data", "encoding", "Platform", "ciphertext", "encode", "isObject", "ErrorInfo", "encodeArray", "messages", "message", "serialize", "encodeBody", "inputContext", "lastPayload", "xforms", "lastProcessedEncodingIndex", "encodingsToProcess", "xform", "match", "xformAlgorithm", "deltaBase", "deltaBaseBuffer", "err", "fromResponseBody", "body", "MsgPack", "format", "decodeBody", "i", "values", "Message", "fromValuesArray", "count", "result", "getMessagesSize", "total", "message_default", "actions", "toActionValue", "actionString", "fromEncoded", "logger", "encoded", "options", "msg", "fromValues", "decode", "e", "logger_default", "fromEncodedArray", "encodedArray", "values", "stringifyAction", "PresenceMessage", "decode", "fromResponseBody", "body", "options", "logger", "MsgPack", "format", "messages", "decodeBody", "i", "msg", "fromValues", "e", "logger_default", "fromValuesArray", "values", "count", "result", "fromData", "data", "PresenceMessage", "PresenceMessage", "parts", "data", "encoding", "Platform", "toActionValue", "result", "presencemessage_default", "RestPresence", "channel", "params", "logger_default", "client", "format", "envelope", "headers", "defaults_default", "mixin", "options", "paginatedresource_default", "body", "unpacked", "fromResponseBody", "restpresence_default", "MSG_ID_ENTROPY_BYTES", "allEmptyIds", "messages", "message", "RestChannel", "client", "name", "channelOptions", "_a", "logger_default", "restpresence_default", "normaliseChannelOptions", "options", "params", "args", "first", "second", "fromValues", "isObject", "fromValuesArray", "ErrorInfo", "format", "idempotentRestPublishing", "headers", "defaults_default", "mixin", "msgIdBase", "randomString", "index", "encodeArray", "size", "getMessagesSize", "maxMessageSize", "serialize", "requestBody", "resource_default", "restchannel_default", "Stats", "_Stats", "values", "stats_default", "RestChannelMixin", "channel", "params", "client", "format", "envelope", "headers", "defaults_default", "mixin", "options", "paginatedresource_default", "body", "unpacked", "fromResponseBody", "resource_default", "RestPresenceMixin", "presence", "RestChannelMixin", "params", "client", "format", "envelope", "headers", "defaults_default", "mixin", "options", "paginatedresource_default", "body", "unpacked", "fromResponseBody", "Rest", "client", "RestChannelMixin", "RestPresenceMixin", "Channels", "push_default", "params", "headers", "defaults_default", "format", "envelope", "mixin", "paginatedresource_default", "body", "unpacked", "statsValues", "i", "stats_default", "timeUri", "host", "error", "HttpMethods_default", "time", "ErrorInfo", "method", "path", "version", "customHeaders", "_a", "encoder", "decoder", "throwMissingPluginError", "_method", "paginatedResource", "resbody", "ensureArray", "Platform", "specOrSpecs", "requestBodyDTO", "singleSpecMode", "requestBody", "encodeBody", "response", "resource_default", "batchResults", "decodeBody", "channels", "channelsParam", "specifiers", "options", "useTokenAuth", "keyName", "resolvedOptions", "__spreadValues", "specifier", "name", "channelOptions", "channel", "restchannel_default", "BaseRest", "baseclient_default", "options", "defaults_default", "logger_default", "Rest", "allCommonModularPlugins", "Rest", "DefaultMessage", "message_default", "encoded", "inputOptions", "fromEncoded", "logger_default", "Platform", "encodedArray", "options", "fromEncodedArray", "values", "msg", "encode", "message", "inputContext", "decode", "DefaultPresenceMessage", "presencemessage_default", "encoded", "inputOptions", "fromEncoded", "logger_default", "encodedArray", "options", "fromEncodedArray", "values", "stringifyAction", "fromValues", "_DefaultRest", "BaseRest", "options", "_a", "_b", "defaults_default", "logger_default", "__spreadProps", "__spreadValues", "allCommonModularPlugins", "newValue", "DefaultMessage", "DefaultPresenceMessage", "Http", "DefaultRest", "callListener", "logger", "eventThis", "listener", "args", "e", "logger_default", "removeListener", "targetListeners", "eventFilter", "listeners", "index", "eventName", "targetListenersIndex", "isObject", "EventEmitter", "Platform", "event", "isNil", "firstArg", "secondArg", "eventsOnceListeners", "eventsListeners", "argCount", "resolve", "self", "listenerWrapper", "innerArgs", "targetState", "currentState", "eventemitter_default", "actions", "ActionName", "name", "flags", "flagNames", "toStringArray", "array", "result", "i", "channelModes", "serialize", "encodeBody", "deserialize", "serialized", "MsgPack", "presenceMessagePlugin", "format", "deserialized", "decodeBody", "fromDeserialized", "error", "ErrorInfo", "messages", "fromValues", "presence", "ProtocolMessage", "__spreadProps", "__spreadValues", "fromDeserializedIncludingDependencies", "fromValuesArray", "values", "stringify", "msg", "simpleAttributes", "attribute", "attribIndex", "stringifiedParams", "forInOwnNonNullProperties", "prop", "flag", "modes", "mode", "protocolmessage_default", "MessageQueue", "eventemitter_default", "logger", "message", "messages", "serial", "count", "err", "logger_default", "first", "startSerial", "endSerial", "completeMessages", "msg", "messagequeue_default", "PendingMessage", "message", "callback", "action", "actions", "Protocol", "eventemitter_default", "transport", "messagequeue_default", "serial", "count", "err", "logger_default", "inspectError", "ErrorInfo", "listener", "messageQueue", "pendingMessage", "stringify", "protocol_default", "ConnectionStateChange", "previous", "current", "retryIn", "reason", "connectionstatechange_default", "ConnectionErrorCodes", "ConnectionErrors", "ErrorInfo", "isRetriable", "err", "connectionerrors_default", "closeMessage", "fromValues", "actions", "disconnectMessage", "Transport", "eventemitter_default", "connectionManager", "auth", "params", "forceJsonProtocol", "connectionerrors_default", "err", "event", "_a", "message", "logger_default", "stringify", "whenPromiseSettles", "inspectError", "Platform", "maxPromisedIdle", "id", "msg", "timeout", "sinceLast", "timeRemaining", "ErrorInfo", "transportCtor", "transportParams", "callback", "transport", "transportAttemptTimer", "errorCb", "realtimeRequestTimeout", "transport_default", "TransportNames", "globalObject", "haveWebStorage", "_a", "Platform", "haveSessionStorage", "noop", "transportPreferenceName", "bundleWith", "dest", "src", "maxSize", "action", "actions", "kind", "proposed", "getMessagesSize", "allSame", "msg", "decodeRecoveryKey", "recoveryKey", "e", "TransportParams", "options", "host", "mode", "connectionKey", "authParams", "params", "copy", "recoveryContext", "defaults_default", "getAgentString", "mixin", "result", "ConnectionManager", "_ConnectionManager", "eventemitter_default", "realtime", "timeouts", "connectingTimeout", "messagequeue_default", "intersect", "TransportNames", "logger_default", "addEventListener", "additionalImplementations", "storage", "implementations", "__spreadValues", "transportName", "transport", "callback", "modeCb", "recoverFn", "lastSessionData", "sessionRecoveryName", "shouldRecover", "transportParams", "candidate", "transport_default", "wrappedErr", "state", "auth_default", "whenPromiseSettles", "err", "isRetriable", "error", "connectionId", "connectionDetails", "self", "existingState", "connectedState", "existingActiveProtocol", "protocol_default", "connectedErr", "_connectionId", "connectionstatechange_default", "currentProtocol", "wasActive", "wasPending", "noTransportsScheduledForActivation", "newConnectionState", "hasConnectionError", "prevConnId", "sinceLast", "newError", "PartialErrorInfo", "_b", "connectionerrors_default", "stateChange", "message", "newState", "transitionState", "interval", "connectivity", "ErrorInfo", "indicated", "retryImmediately", "retryDelay", "getRetryTime", "change", "autoReconnect", "request", "auth", "connectCount", "connect", "authCb", "transportPreference", "ws", "shouldContinue", "giveUp", "candidateHosts", "hostAttemptCb", "fatal", "tryFallbackHosts", "arrPopRandomElement", "tokenDetails", "activeTransport", "authMsg", "fromValues", "successListener", "failureListener", "listener", "queueEvent", "PendingMessage", "stringify", "pendingMessage", "lastQueued", "multicaster_default", "pendingMessages", "numQueued", "inspectError", "pendingChannelMessage", "pingStart", "id", "cheapRandStr", "withTimeoutAsync", "resolve", "onHeartbeat", "responseId", "HttpStatusCodes_default", "clientId", "connectionStateTtl", "reject", "finished", "value", "connectionmanager_default", "Connection", "eventemitter_default", "ably", "options", "state", "connectionmanager_default", "stateChange", "Platform", "logger_default", "connection_default", "ChannelStateChange", "previous", "current", "resumed", "hasBacklog", "reason", "channelstatechange_default", "noop", "validateChannelOptions", "options", "isObject", "ErrorInfo", "i", "currentMode", "channelModes", "RealtimeChannel", "_RealtimeChannel", "eventemitter_default", "client", "name", "_a", "params", "logger_default", "restMixin", "state", "normaliseChannelOptions", "throwMissingPluginError", "args", "previousChannelOptions", "err", "resolve", "reject", "stateChange", "prevOptions", "requestedParams", "omitAgent", "existingParams", "shallowEquals", "arrEquals", "messages", "argCount", "fromValues", "fromValuesArray", "maxMessageSize", "encodeArray", "size", "getMessagesSize", "callback", "msg", "protocolmessage_default", "actions", "subscriptions", "message", "result", "forceReattach", "attachReason", "connectionManager", "attachMsg", "allToUpperCase", "event", "listener", "l", "PartialErrorInfo", "syncMessage", "presence", "syncChannelSerial", "isSync", "modesFromFlags", "allToLowerCase", "resumed", "hasPresence", "hasBacklog", "change", "channelstatechange_default", "detachErr", "id", "connectionId", "timestamp", "presenceMsg", "decode", "e", "firstMessage", "lastMessage", "connectionerrors_default", "reason", "action", "stateTimer", "retryDelay", "getRetryTime", "s", "channelSerial", "channelParams", "_", "__objRest", "realtimechannel_default", "BaseRealtime", "_BaseRealtime", "baseclient_default", "options", "_a", "_b", "defaults_default", "logger_default", "ErrorInfo", "connection_default", "Channels", "plugins", "transports", "TransportNames", "eventemitter_default", "realtime", "serials", "name", "keysArray", "channel", "channelSerials", "msg", "channelName", "connectionState", "reason", "connectionStateToChannelState", "fromChannelStates", "toChannelState", "channelId", "channelOptions", "realtimechannel_default", "deriveOptions", "filter", "toBase64", "match", "matchDerivedChannel", "releaseErr", "baserealtime_default", "getClientId", "realtimePresence", "isAnonymousOrWildcard", "realtime", "clientId", "waitAttached", "channel", "callback", "action", "whenPromiseSettles", "err", "ErrorInfo", "newerThan", "item", "existing", "itemOrderings", "existingOrderings", "RealtimePresence", "eventemitter_default", "PresenceMap", "data", "id", "logger_default", "presence", "fromData", "encode", "resolve", "reject", "PartialErrorInfo", "params", "waitForSync", "returnMembers", "members", "restMixin", "presenceSet", "isSync", "syncChannelSerial", "syncCursor", "match", "myMembers", "broadcastMessages", "connId", "i", "fromValues", "hasPresence", "pendingPresence", "pendingPresCount", "presenceArray", "multicaster", "multicaster_default", "event", "state", "inspectError", "e", "reenterCb", "msg", "wrappedErr", "change", "channelstatechange_default", "memberKey", "entry", "items", "subscriptions", "_args", "args", "realtimechannel_default", "listener", "key", "map", "result", "connectionId", "existingItem", "syncInProgress", "copy", "valuesArray", "inProgress", "realtimepresence_default", "shortName", "TransportNames", "isNodeWebSocket", "ws", "WebSocketTransport", "transport_default", "connectionManager", "auth", "params", "Platform", "uri", "connectParams", "toQueryString", "logger_default", "self", "options", "wsUri", "defaults_default", "whenPromiseSettles", "err", "authParams", "paramStr", "param", "wsConnection", "ev", "e", "message", "serialize", "msg", "inspectError", "ErrorInfo", "data", "deserialize", "wasClean", "code", "websockettransport_default", "FilteredSubscriptions", "channel", "filter", "listener", "filteredListener", "m", "_a", "_b", "_c", "_d", "_e", "_f", "mapping", "key", "value", "realListener", "realListenerMap", "filterMaps", "listenerMaps", "prev", "cur", "listeners", "_DefaultRealtime", "baserealtime_default", "options", "_a", "MsgPack", "defaults_default", "logger_default", "__spreadProps", "__spreadValues", "allCommonModularPlugins", "realtimepresence_default", "fromValues", "fromValuesArray", "websockettransport_default", "FilteredSubscriptions", "newValue", "utils_exports", "connectionmanager_default", "protocolmessage_default", "DefaultMessage", "DefaultPresenceMessage", "Http", "DefaultRealtime", "uint8Array", "uint32Array", "pow", "DEFAULT_STATE", "ROUND_CONSTANTS", "M", "getFractionalBits", "n", "nPrime", "isPrime", "factor", "LittleEndian", "convertEndian", "word", "rightRotate", "bits", "sha256", "data", "STATE", "legth", "bitLength", "newBitLength", "bytes", "words", "round", "block", "workingState", "MRound", "gamma0x", "gamma1x", "t1", "t2", "i", "val", "hmac", "key", "tmp", "innerKey", "outerKey", "msg", "result", "BufferUtils", "bytes", "base64", "encodings", "byteLength", "byteRemainder", "mainLength", "a", "b", "c", "d", "chunk", "i", "binary_string", "len", "ascii", "buffer", "str", "Platform", "accum", "byte", "hexEncodedBytes", "uint8Array", "string", "encodedByteArray", "buffer1", "buffer2", "arrayBuffer1", "arrayBuffer2", "bytes1", "bytes2", "arrayBufferView", "message", "key", "hash", "hmac", "bufferutils_default", "createCryptoClass", "config", "bufferUtils", "DEFAULT_ALGORITHM", "DEFAULT_KEYLENGTH", "DEFAULT_MODE", "DEFAULT_BLOCKLENGTH", "validateCipherParams", "params", "normaliseBase64", "string", "isCipherParams", "CipherParams", "algorithm", "keyLength", "mode", "key", "Crypto", "cipherParams", "err", "ErrorInfo", "logger", "_a", "CBCCipher", "iv", "buffer1", "buffer2", "output", "outputView", "buffer1View", "i", "buffer2View", "plaintext", "logger_default", "cryptoKey", "ciphertext", "ciphertextArrayBuffer", "ciphertextBody", "randomBlock", "XHRStates", "XHRStates_default", "createMissingImplementationError", "ErrorInfo", "_a", "Http", "client", "connectivityCheckUrl", "defaults_default", "connectivityCheckParams", "connectivityUrlIsDefault", "requestImplementations", "__spreadValues", "xhrRequestImplementation", "fetchRequestImplementation", "hasImplementation", "Platform", "method", "uri", "headers", "params", "body", "resolve", "req", "XHRStates_default", "error", "unpacked", "statusCode", "logger_default", "requestResult", "HttpMethods_default", "result", "isSuccessCode", "PartialErrorInfo", "_b", "errorInfo", "http_default", "globalObject", "getGlobalObject", "isVercelEdgeRuntime", "allowComet", "loc", "isWebWorkerContext", "userAgent", "currentUrl", "Config", "f", "str", "byteLength", "byteArray", "config_default", "shouldBeErrorAction", "err", "UNRESOLVABLE_ERROR_CODES", "auth_default", "protocolMessageFromRawError", "fromValues", "actions", "CometTransport", "transport_default", "connectionManager", "auth", "params", "tokenDetails", "logger_default", "options", "host", "defaults_default", "port", "cometScheme", "connectUri", "whenPromiseSettles", "authParams", "connectParams", "toQueryString", "preconnected", "connectRequest", "XHRStates_default", "data", "ErrorInfo", "Platform", "closing", "closeOrDisconnectUri", "request", "inspectError", "connectionerrors_default", "message", "_a", "connectionStr", "baseConnectionUri", "pendingItems", "items", "sendRequest", "recvRequest", "responseData", "i", "fromDeserialized", "e", "requestItems", "comettransport_default", "isAblyError", "responseBody", "headers", "allToLowerCase", "keysArray", "getAblyError", "ErrorInfo", "noop", "idCounter", "pendingRequests", "getHeader", "xhr", "header", "isEncodingChunked", "getHeadersAsObject", "headerPairs", "i", "parts", "x", "XHRRequest", "_XHRRequest", "eventemitter_default", "uri", "params", "body", "requestMode", "timeouts", "logger", "method", "cheapRandStr", "toQueryString", "isNil", "_timeouts", "defaults_default", "copy", "err", "unpacked", "statusCode", "timeout", "XHRStates_default", "timer", "accept", "responseType", "h", "errorHandler", "errorEvent", "message", "code", "_a", "errorMessage", "logger_default", "PartialErrorInfo", "streaming", "successResponse", "streamPos", "onResponse", "onEnd", "parsedResponse", "contentType", "jsonResponseBody", "Platform", "e", "onProgress", "responseText", "bodyEnd", "idx", "chunk", "onChunk", "onStreamEnd", "readyState", "xhrrequest_default", "shortName", "TransportNames", "XHRPollingTransport", "comettransport_default", "connectionManager", "auth", "params", "Platform", "uri", "headers", "body", "requestMode", "xhrrequest_default", "xhrpollingtransport_default", "order", "defaultTransports", "websockettransport_default", "xhrpollingtransport_default", "transport_default", "test", "globalObject", "Webstorage", "e", "name", "value", "ttl", "session", "wrappedValue", "rawItem", "webstorage_default", "Defaults", "TransportNames", "defaults_default", "inspect", "buffer", "view", "type", "bytes", "i", "byte_", "utf8Write", "offset", "string", "l", "codePoint", "utf8Read", "length", "end", "utf8ByteCount", "count", "encode", "value", "sparse", "size", "sizeof", "_encode", "SH_L_32", "SH_R_32", "getInt64", "getUint64", "setInt64", "val", "setUint64", "Decoder", "key", "decode", "decoder", "encodeableKeys", "keys", "isArray", "msgpack_default", "isAblyError", "responseBody", "headers", "getAblyError", "ErrorInfo", "convertHeaders", "result", "value", "key", "fetchRequest", "method", "client", "uri", "params", "body", "fetchHeaders", "_method", "isNil", "controller", "timeout", "timeoutPromise", "resolve", "PartialErrorInfo", "defaults_default", "requestInit", "Platform", "resultPromise", "res", "getGlobalObject", "contentType", "unpacked", "error", "defaultBundledRequestImplementations", "xhrrequest_default", "fetchRequest", "Crypto", "createCryptoClass", "config_default", "bufferutils_default", "Platform", "http_default", "transport_default", "webstorage_default", "clientClass", "DefaultRest", "DefaultRealtime", "msgpack_default", "defaultBundledRequestImplementations", "logger_default", "getDefaults", "defaults_default", "web_default", "ErrorInfo", "DefaultRest", "DefaultRealtime", "msgpack_default"]
}
